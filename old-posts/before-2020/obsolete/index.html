<!DOCTYPE html>
<html prefix="        og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="zh_cn">
<head>
<meta charset="utf-8">
<meta name="description" content="LiYanrui's homepage.">
<meta name="viewport" content="width=device-width">
<title># rm -rf /</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="zh_cn" href="../rss.xml">
<link rel="canonical" href="#">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="../mycss/tweak.css" rel="stylesheet" type="text/css">
<base target="_parent">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">跳到主内容</a>
    <div id="container">
        
    <header id="header"><h1 id="brand"><a href="../" title="# rm -rf /" rel="home">

        <span id="blog-title"># rm -rf /</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li><a href="../categories/index.html">标签</a></li>
                <li><a href="../archive.html">文章存档</a></li>

    

    
    
    </ul></nav></header><main id="content"><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/metamorphosis.html" class="u-url">变形记</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/metamorphosis.html" rel="bookmark">
            <time class="published dt-published" datetime="2019-04-30T23:43:58+08:00" itemprop="datePublished" title="2019-04-30 23:43">2019-04-30 23:43</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p><strong>目录</strong><span id="m4-TOC"></span></p>
<ul>
<li><a href="../posts/metamorphosis.html#%E7%A3%A8%E5%88%80" target="_parent">磨刀</a></li>
<li><a href="../posts/metamorphosis.html#%E6%8A%A4%E6%89%8B" target="_parent">护手</a></li>
<li><a href="../posts/metamorphosis.html#%E9%80%80%E5%88%80%E6%A7%BD" target="_parent">退刀槽</a></li>
<li><a href="../posts/metamorphosis.html#%E8%A7%92%E7%A3%A8%E6%9C%BA" target="_parent">角磨机</a></li>
<li><a href="../posts/metamorphosis.html#%E5%BC%80%E5%88%83" target="_parent">开刃</a></li>
<li><a href="../posts/metamorphosis.html#%E4%B8%8D%E6%82%B2" target="_parent">不悲</a></li>
</ul>
<p><span id="磨刀"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">1 磨刀</a></h2>
<p>在光线明亮的地方，竖持一把刀，令其刃口正对着自己的眉心。若这把刀足够锋利，就一定没有人能够看到锋线。原因很简单，人眼分辨细微之物的极限是 0.1 mm，而一把锋利的刀，刃口的厚度可以到微米级。有的刀用起来也能让人觉得它很锋利，但是在本该看不见锋线之处，出现了连续或断续的细微亮线，此时它已经钝了。</p>
<p><img alt="" src="../images/metamorphosis/01.jpg"></p>
<p>真正的锋利是看不见的，它们要么隐匿于平整的刃区里，要么隐匿于圆滑的刃区里，只是这种隐匿有着严格的一致性。对于徒手磨一把钝得厉害的刀而言，平整的刃区可望而不可及，反而圆滑的刃区更容易得到——再不济，也是三到五重眼皮。</p>
<p>磨刀的时候，手一开始总是不那么稳定，即使饶有经验的磨刀匠也不例外。不稳定的手，会导致刃角产生难以预料的变化。刃角的变化，若是难以预料，会导致磨出的刃区也会难以预料地趋于圆滑。这种圆滑尽管与那些在砂带机上研磨出来的蛤刃（刃缘区域很像蚌壳的边缘）相比，粗笨拙陋，但是只要它能成功隐匿锋线，就很好了，总比那些一边难以忍受圆滑又一边自甘其钝的刀要好得多。</p>
<p>磨刀的时候，要稳定的并非是双手，而是双手与整个身体的关系。只有当这种关系在不断地训练中逐渐趋向于稳定和平衡，方能保证磨出来的刃面足够平整。在这个基础上，再在磨刀过程中有规律地变换刃角，方能磨出真正的蛤刃。</p>
<p>锋线无非是两个刃面的交汇，它的存在完全依赖于刃面上冗余材料的磨除。蓬生麻中，不扶而直。只要有足够好的刃面，自然就有足够好的锋线。孔子所说的中庸之道，我更喜欢从这个角度去理解。</p>
<p>不过，老子说「揣而锐之，不可长葆」，似乎是建议刀不需要太锋利。木秀于林，风必摧之，古往今来，如此附会者不乏其人。他们认为，做人不该锋芒毕露，否则会招人嫉恨。于是，在锋芒毕露的人看来，老子彻头彻尾是消极避世者。</p>
<p>在我看来，老子的话并不玄妙。他不过是在建议不要过于追求锋利。孔子说得更直白，过犹不及。在我看来，与其说老子和孔子这些人是哲学家，不如说他们是生活学家。没有生活学这种学，不过是因为当初名字取得不够正确。</p>
<p>磨刀的时候，过于追求锋利，势必缩减刃角，从而导致刀体变薄，强度下降。这样的刀，虽然锋利，但是在使用时很容易崩口、卷刃甚至断裂。倘若将「揣而锐之，不可长葆」简单理解成，愈锋利，愈容易钝，不就成了变相赞美那些自甘其钝的刀了么？没有人喜欢用钝的刀子去砍柴、切菜和割肉。这一点，一直被道家曲解成清静无为的老子应该也不会例外，类似于那些认为神明自会指引道路的最虔诚的信徒在过马路的时候，不是也要接受红绿灯的指示么？</p>
<p>我用的砥石，比我的刀便宜得多。不过，在砥石方面，我不怎么仇富。倘若有人愿意用价格上万的日本天然砥石磨刀，我不会觉得他在炫富，只会觉得他是在力所能及的前提下愿意为自己的爱好而买单，难能可贵。会磨刀的人不多，愿意用昂贵的砥石去磨刀的人必定凤毛麟角。一个亿万富翁若是每天像我这样过着粗茶淡饭的生活，那么对他而言，贫穷实在也是一种消费。</p>
<p>人应该有点能够持久的爱好，特别是已经有子女的人；否则等自己老了，唯一的爱好就是折磨子女。为了维持在刀具方面的爱好，我先是购置了一块青石、一块金刚石板，还有平时我用来当作砥石底座的一块黑色碳化硼，斥资共约一百块钱。最近购置了一个角磨机和一台小型砂带机，斥资共约四百块钱。这些东西可以用很久，有可能我化为灰烬之后许多年，他们依然可以呆在房间的角落里，在灰尘下面沉默不语。</p>
<p>与有着琴棋书画等方面爱好的人相比，我在爱好方面的投资并不太多。磨刀这种事，不需要买多么贵的刀来磨，家里的菜刀就可以。若还有生活，肯定会有菜刀。不过，那么多有生活的人，却不怎么会磨刀，否则不会有磨刀匠，陶瓷刀卖得也不会那么好。等有一天，我和朋友正常聊天，我们一定会谈自己的孩子。当朋友说起他的女儿钢琴弹得很好，舞蹈也不错的时候，我应该不会说，我的孩子菜刀磨得挺好……幸好庄子编造了一个庖丁解牛的故事，我可以说，我的孩子，庄子读得还算凑合。</p>
<p>我认为磨刀是一门艺术，和书法、画画、弹钢琴、跳舞之类的艺术本质上没什么不同。要说有不同，那肯定是不懂艺术的人的问题。譬如，快递公司可以帮我将一台偌大的钢琴（假设我有）邮寄给朋友，却拒绝帮我将一把像瑞士军刀那般大小且非管制级的小刀（这个我真的有不止三五把）寄给朋友。那么，我的小刀都是从哪里来？依然是这些快递公司。这个世界似乎企图通过快递公司让我承认并且相信，磨刀是一门巫术，见不得天光。</p>
<p>现在我试着传授这门巫术，劝学之语是，掌握此术，可以拥有任何人都看不见的锋利。练习时，只需要一把钝了的刀，再加上一根 10 cm 长并且像中性笔芯那么细的红宝石棒。红宝石棒，虽然名字很贵，但只需要十八块钱就可以买到。倘若这点钱都不想出，也可以用瓷碗的碗底。之所以要用细棒形的砥石，是因为有些刀的锋线，在刀腹区域向刀片内侧有所凹陷，还有的刀干脆就是齿刃。因此，通用的砥石是这种细棒形的砥石。</p>
<p><img alt="" src="../images/metamorphosis/02.jpg"></p>
<p>适于红宝石棒磨的刀，是轻微钝了的刀，譬如在切割食物时，刃口不小心碰到瓷质的盘子上了。在生活中，这是最容易搞钝一把刀的方法。待刃口钝掉之后，需要找一张 A4 纸或来自于一本你不喜欢的书上的纸，然后一只手捏住这张纸，另一只手持刀凌空去削它几下，去感受刃口有多么钝。不然，你不知道这把刀在磨过之后锋利程度是否有所改善。钝了的刀，凌空是削不了纸的，只能撕纸。</p>
<p>接下来要考虑的问题是，是用红宝石棒去磨刃口，还是用刃口去削红宝石棒？或者去考虑，为什么现实中的磨刀师傅还是来自电影里磨刀的杀人者给我们的印象是，磨刀是要双手持刀在砥石上来回磨呢？原因很简单，这样更容易观察刃角是否正确，而且更省力。刃面与砥石的摩擦运动是相对的，理论上可以将刀用木工夹或台钳固定，然后双手持砥石去磨刃面，只能凭借感觉去而且无法观察所磨的刃角，但是砥石比刀要重得多，所以很容易觉得累。人在累的时候，就很难去稳定那些本该稳定的东西，不然锋利就很难谈起。</p>
<p>那么，究竟是用红宝石棒去磨刃口，还是用刃口去削红宝石棒呢？都可以。选自己觉得最舒适的。有人觉得听歌，在音效好的房间里用音效好的音响来听会更舒适，而我却觉得在乏味的路上或者刷盘子洗碗时听会更舒适。觉得舒适的，就是最好的。锋利理应蕴涵于这样的舒适，而不是与自己过不去。对于小刀，我会选择用刃口去削红宝石棒，但是对于菜刀，我会选择用红宝石棒去磨刃口。</p>
<p>确定了磨刀方式，接下来就是如何磨，然而到了这一步，没人能够教你，就像没人能够教你如何生活。求解这个问题，需要你的身体做一些规律性的运动，这些运动本身便是答案。但是，我可以给出一些启示。如果你会用要磨的这把小刀削铅笔，只需要略加尝试，就应该能够找到正确的运动。真正困难的是，如何维持这种运动的可重复性。</p>
<p><img alt="" src="../images/metamorphosis/03.jpg"></p>
<p>地球日复一日的自传，年复一年的公转，它是如何维持这一切的？我们活着的每一天，即使是最为平淡的那一天，为了这一天，地球要准备 46 亿年。等到能够深切感受到习以为常的一切，都来之不易时，就差不多懂得如何用红宝石棒行施磨刀这一巫术了。若是希望更加神秘，在施术时，不妨念念有辞：挖了蘑菇累死！哇啦到黑累死！</p>
<p>10 cm 长的红宝石棒可能实在是太短了，仅仅是捏住它，就需要用掉差不多 3 cm 的长度，再加上刀片的宽度，最后能够用来磨刀的棒长大概只有 5 cm。若是有一把可以换批头的改锥，那么只需要一小块纸巾，就可为红宝石棒制作一个很不错的手柄，法力便会瞬间大增。如果没有这样的改锥，也可以用 502 之类的胶水，将红宝石棒粘到一根废弃的中性笔杆上。总之，只要你想延长它，就总是会有办法，真正难以做到的是，认识到它的短处。</p>
<p><img alt="" src="../images/metamorphosis/04.jpg"></p>
<p>现在，假设已经发现了一种可以驱动刃口削红宝石棒的可重复动作，接下来要面对的问题是，磨一个刃面的时候，什么时候停下来？虽然在熟悉了一套磨刀的动作时，无论是用刃口削红宝石棒，还是红宝石棒磨刃口，都可以有着类似拉小提琴的感觉……太夸张么……那就拉二胡的感觉，但是总不可能一直磨下去，否则整个刀片都磨没了，也不会锋利。</p>
<p>《礼记·大学》曰，知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。知道什么时候停下来，很重要。人生我还不太懂，但是我知道，正在磨的刃面出现卷边时，必须停下来，去磨另一面。只是在刃面出现卷边时，肉眼很难识别，特别是在刃材较硬的情况下，此时需要探手去试。昔人有诗为证，进退两茫然，探手试微疵。</p>
<p>将两个刃面分别称为甲和乙。假设此刻正在磨甲面，已经磨了数十次，如何用手去试甲面出现卷边了呢？对于右撇子，可以用右手拇指甲根部靠下到至第一关节且位于外侧的皮肤（或身体上任何一处足够敏感且安全的皮肤），顺向（沿着刀背到刃口的方向）轻拂乙面，若是锋线处存在轻微的刮擦感，意味着甲面就出现卷边。接下来，应该去磨乙面，直到从甲面能够感受到乙面出现卷边，再停下来。此时，磨刀过程就开始进入收尾阶段。</p>
<p>现在，是乙面出现了卷边，因此需轻磨甲面，以消除卷边。这个过程中，若力度过大，又会导致甲面出现卷边，因此需轻磨乙面，以消除卷边。如此反复，力度需愈来愈轻。最后几次，仅凭刀片的自重，让甲面和乙面交替在红宝石棒上轻轻掠过。那么，收尾阶段何时停止呢？凌空削纸，检验刃口的锋利程度是否令自己满意。对刃口锋利程度的要求会随着磨刀技艺的精进而不断提高。此时，要谨记，揣而锐之，不可长葆。</p>
<p>用刃面的卷边作为止的标志，似乎是一个悖论，因为它是揣而锐之，也是过犹不及。止，难道就是犯错么？本该如此啊，不犯错，怎么知道止？犯错没什么可怕，在磨刀的时候，至少要犯两次卷边的错误，第一次叫矫枉，或者叫定，第二次叫过正，或者叫静。有了定和静，磨刀过程就步入收尾阶段，在这个阶段也是至少要犯两次错，第一次叫安，或者叫微定，第二次是虑，或者叫微静……最后能得。古人的哲学，很容易令不会磨刀的人似懂非懂或自以为懂。</p>
<p>红宝石棒只能对付微钝的刃口。倘若刃口钝得厉害，或者需要重新开刃，只需将红宝石棒换成更为粗砺的金刚锉，磨刀方法不变，磨出两道刃面之后，再用红宝石棒精磨刃口。还有，如果掌握了磨刀棒的用法，那么双手持刀在砥石上磨，很难么？如果会在砥石上磨刀，那么，在野外一块较为平整的石头或者在城里道路两旁的路肩上磨，会很难么？我深信凡是与人有关的事，总是可以万变不离其宗。若寻其宗，一变足矣。</p>
<p>红宝石棒若是用的次数太多，棒面便会淤积许多钢屑，此时，是原本可以削铁如泥的红宝石棒钝了。消除红宝石棒上淤积的钢屑的良方是：用恢复了锋利的刀，从一大块纳米海绵上割下一小块，用这一小块纳米海绵蘸一点水，擦除钢屑。</p>
<p><img alt="" src="../images/metamorphosis/05.jpg"></p>
<p>红宝石棒以自身钝掉为代价恢复了刀的锋利。恢复锋利的刀以自身钝掉为代价割取一小块纳米海绵。一小块纳米海绵以自身的脏污为代价恢复红宝石棒的「锋利」。最后，半杯水以重归于大地为代价恢复纳米海绵的「锋利」。所以，世间最锋利的东西，首先是大地，其次是半杯水。</p>
<p><img alt="" src="../images/metamorphosis/06.jpg"></p>
<p>在磨刀过程中，拍了几段视频，将它们上传到某知名视频平台。也许是因为视频中有刀的缘故，被系统屏蔽了。我太容易忘事……这个世界当然不会放弃通过网络让我承认并相信，磨刀是一门巫术。</p>
<p>窗外杨柳依依，美丽的时光，早已从我的指缝里流走，唯剩一些巫术与我为伴。所有的巫术，最终都会失传。Valar Morghulis！Valar Dohaeris！</p>
<p><strong>后记</strong></p>
<p>感谢有眼无珠不识巫术的哔哩哔哩：</p>
<ul>
<li>
<a href="https://www.bilibili.com/video/av50214286">钝刃削纸测试</a>：搞钝一把锋利的刀，看它沮丧的样子。</li>
<li>
<a href="https://www.bilibili.com/video/av50214351">刃口削红宝石棒</a>：磨刀和削铅笔，有什么不同么？</li>
<li>
<a href="https://www.bilibili.com/video/av50214496">谁削谁都行</a>：红宝石棒为刀俎，刀为鱼肉。</li>
<li>
<a href="https://www.bilibili.com/video/av50214636">利刃削纸测试</a>：钝了的刀，磨好之后，要看它是否恢复锋利，need to kill one piece of paper again.</li>
</ul>
<p><span id="护手"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">2 护手</a></h2>
<p>很久以前，我得到了一把 Buck 大钢板（Buck 141）。我之所以叫它大钢板，是因为它的哥哥叫小钢板（Buck 140）。对自己喜欢的东西，取名字要任性。如果我现在还能为它重新取一个名字，可以叫它大鳄鱼，它的轮廓有点像一只潜伏在泥沼里的鳄鱼。</p>
<p><img alt="" src="../images/metamorphosis/07.jpg"></p>
<p>无论是大钢板还是小钢板，都是裸柄一体刀——刀柄和刀片来自相同的母体，一块钢板，除此以外，别无其他；看上去像是半成品，至少会觉得刀柄握起来会硌手。的确如此，而且 Buck 大钢板尤甚，它的每条棱边几乎没做倒角处理，说硌手还是太过于宽容，更应该叫割手。当初得到它时，我不得不买几根金刚锉和几张砂纸，把除了刃口之外的所有棱边打磨到直到我依然不是很满意但是觉得不胜其烦的程度为止。之后，用过几次，切过水果和肉，就搁置了起来。再后来，就把它忘记了，像原本熟悉的人把我忘了一样。实际上，我一向喜欢裸柄一体刀，它们足够结实，用脏了，清洗起来也足够方便……人类洗澡时，不是也要脱掉全部衣服么。</p>
<p>多年以后，当我在柜子里的深处不小心发现它的时候，感觉像是白捡了一把刀。想不起来为什么当初要把它放到柜子里，而不是像其他刀那样放在一个大盒子里，所以只好认为当初把它搁置到一个杳无刀迹的地方，纯属毫无理由。我应该是把理由忘记了。或许人活得越久，忘记的理由就会越多。</p>
<p>我看到刀刃上有个小豁口。也许当年拿它砍了比它还要硬的东西，然后觉得它还不够削铁如泥，于是失望，于是就把它忘记了。这简单的理由，应该比较适合我，很容易放弃，经常连自己也不放过。有了很正当的理由，我可以重新打量它，毫无愧疚，甚至我开始挑剔起来。</p>
<p>我觉得，它的护手太夸张了。这是一把猎刀，不是用于猎杀，更不是用于刺杀，而是用于处理猎物，因此护手就有些多余。北欧猎人使用的猎刀，就通常没护手。如果是当年，我会跑到贴吧上，把我的挑剔化为批判，以此彰显我比这把刀的设计者聪明得多。只是，我已经发现了一个真相好久了。这么多年，我批判过许多东西，可这些东西从未因为我的批判而有所改变。原因很简单，说一个人有病，实在是很容易的事，真正困难的应该是给他药，给他正确的药。我不会治人，但是兴许可以治好这把刀。这事并不难，只需要磨去护手，而且为了保证它在刀鞘内不致于滑脱出来，护手最多只需要磨去一半。</p>
<p><img alt="" src="../images/metamorphosis/08.jpg"></p>
<p>那么，如何磨呢？先找一块比这把刀更硬的东西，譬如我的那几块磨刀石，它们能磨刀，自然能磨护手，但是其中最硬的一块磨刀石是金刚石板——涂敷金刚石粉末的一块钢板——最为适合。我把这把刀的护手放在金刚石板上用力来回磨，用不了多久，就找回了当年金工实习期间钳工的感觉，手酸软无力，取得的成就令人丧气——这可是淬过火的钢板。</p>
<p><img alt="" src="../images/metamorphosis/09.jpg"></p>
<p>屋檐的水能滴穿石头，老妪一生能将铁杵磨成一根针么？愚公或许会说，「我们一定要把山搬到大海里。」虞啸卿麾下的海团长会说，「兄弟们，打剩一个营，老子是你们的营长；打剩一个班，老子是你们的班长；全部死光了，老子到了阴间，还带你们这个死鬼团！」我敬佩豪气干云的人，但豪气不应该是赌气，死硬，或者盲目坚持。</p>
<p>真正的豪气，应该是对自己的无能足够宽容，然后去想办法改进工具或手段。我要做的应该是，提高刀的护手在金刚石板上来回摩擦这种相对运动的频率。我需要一台电机，一个可以将圆周运动转化为直线往复运动的曲柄滑块机构，一根光滑的导轨，把滑块卡入导轨，把我的金刚石板固定在滑块上……机械学，当初可能是一群企图磨掉刀的护手的人发展出来的一门学科。能从一个简单的事情或问题出发，发展出更多的问题，这一切要归功于《2001 太空漫游》里的一只类人猿忽然有一天脑洞大开发现野兽的大腿骨可以砸碎一些东西，后来用这根骨头击退了入侵者，类似于我们现在的一切，也可以归功于武功不怎么样的丘处机路过牛家村遇到了武功更不怎么样的郭啸天和杨铁心。</p>
<p>让问题变得更多，就可以让更多的人更好地活下去。如果人太多，而问题太少，就会发生战争。这是我能想到的药，但没人喜欢有问题。陷入问题里的我们，不安，发愁，抑郁，迷乱……不要怕，根据我的经验，那些看上去难以解决的问题，可以通过制造更多的问题来解决。至于如何制造问题，那要认真审度自己手里可以利用的一切，还需要相信，这世上不会有比自己正要解决的问题更难的问题了，所以我们总是可以通过制造一些更简单的问题，并把这些问题转移给他人，等他们把这些问题都解决了，那么我们的问题就到了迎刃而解的时候。如马克思所言，当问题提出来的时候，就意味着解决它的时机已经成熟了。</p>
<p>如果我可以把我的磨刀石从板条形变成圆周形，那么就不需要可以把圆周运动转化为直线往复运动的曲柄滑块机构以及导轨了。我的确有这样的磨刀石——用于切割金属的金刚石盘片。当初，买它的时候，并没想到要用它磨刀，但是既然它能切割金属，就能够用来磨刀或刀的护手。此外，我还有一个手电钻，以前买来，为的是在墙壁上打孔，安装膨胀螺栓，但是它可以为我提供转速可控的圆周运动。于是，我新提出的问题，很容易通过将金刚石盘片安装在手电钻上的方式解决掉。现在，我有了一把可以削金断玉的新的「刀」了。</p>
<p><img alt="" src="../images/metamorphosis/10.jpg"></p>
<p>事实上，即使有了可以高速旋转的金刚石磨削机，但是把刀的护手加工成我想要的样子，也需要大半个下午。我需要左手持着随着时间的流逝而倍加沉重的手电钻并摁下它的工作按钮，另一只手捏住刀柄，还需要戴上耳机抵抗金刚石颗粒在钢板上摩擦而发出的怪异声音。很快，我发现可以把手电钻搭靠在座位隔板上，这样我的左手近似零负荷，而且手电钻的位置也更为稳定，从而改善了磨削的效率和准确性。</p>
<p><img alt="" src="../images/metamorphosis/11.jpg"></p>
<p>为了解决问题，人应当与自身所处的环境达成足够的和谐。应当利用环境去解决问题，而不是陷入问题之中并与之对抗。对环境的感受，其详细程度是决定问题能否得以妥善解决的关键。纸上谈兵，和下棋一样，会丢失许多现实细节，而且也无法从失败中学到任何有益的知识。</p>
<p>虽然我已将 Buck 大钢板的护手加工成了我想要的样子，但是这整个过程依然是失败的，因为在这个过程中，我竟然没有想到，可以把手电钻用绳索固定在一个马扎上，再用一根扎带来代替我用于摁下手电钻工作按钮的手指，这样我的左手就得到了彻底的解放。当我后来想到这个方案时，觉得之前我很像一个刚会抡野兽腿骨的智人。后来，在用手电钻打磨我的 Buck 小钢板时，不希望因为失误而让刀片面目全非，终于想出了这个方案，算是没给人类丢脸。</p>
<p><img alt="" src="../images/metamorphosis/12.jpg"></p>
<p><span id="退刀槽"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">3 退刀槽</a></h2>
<p>我只需对自己熟悉的环境略作一些新的安排，便轻易地完成了 Buck 大钢板的护手的修改。我的修改有些粗糙，但我深信，只要继续改进工具和手段，便可令其足够精致。我对精致的生活一向缺乏追求，而且现在还没有到追求精致的时候，我觉得这把 Buck 大钢板还需要一个退刀槽。</p>
<p>所谓退刀槽，就是刀柄与刀刃之间的一个槽，由于这个槽位于刃区的清根位置，因此也称清根槽。这个槽的用途是，在磨刀的时候，可以避免磨刀石无意中破坏刃区的清根，因此这个槽也可以叫越程槽。似乎是一个悖论，退刀槽的用途是保护清根区域，但是它的存在，本身就是对清根区域的破坏。也许我们总是会认为，有秩序的破坏要好过无意识的混乱的破坏。</p>
<p>金刚石磨片和手电钻构成的金刚石磨削机，我已驾轻就熟，于是未假思索便在刃区清根处开了一个槽。干完之后，才发现它的位置不是很正确，有些偏离刀柄的护手区域。倘若将它再略微扩大一些，可以让位置与护手邻接，但尺寸太大的退刀槽，又失于夸张。</p>
<p><img alt="" src="../images/metamorphosis/13.png"></p>
<p>机械加工，这门技艺的特点是，工件一旦失误了，就绝无可能修正，要么容忍，要么报废、回炉、重造，否则唯一的出路是错上加错。人类的双手虽然非常灵巧，但是也非常容易出错。所以，现代的机械加工，大都以机器去制造机器，为了达到这个境界，人类用自己的双手工作了上万年。但是，现在机器人学的研究者，希望能够制作出像人类那样灵活的双手，我觉得他们即便能制造出这样的机械手，但是不要指望它不容易出错。</p>
<p>我决定把错误犯得更大一些，把退刀槽再开得足以放下我的食指那么大，从而变成指槽。指槽可以让食指更接近刃区，从而便于用刀去做更为精细的切割，譬如削铅笔，刮胡须，修指甲或者割断衣服上的线头。</p>
<p>经过一番认真的规划，并采用了一种叫做耐心的磨削工艺，又用了大概小半天的工夫，开出的槽恰好能放得下我食指第一节，而且似乎也不是很难看，可谓大成若缺，其用不弊。</p>
<p><img alt="" src="../images/metamorphosis/14.jpg"></p>
<p><img alt="" src="../images/metamorphosis/15.jpg"></p>
<p>理论上，接下来的剧情是，我应该携刀归隐山林，从此过上淡泊明志的生活，然而，即便是伊甸园也是有蛇的。在折腾这把刀的过程中，我觉得手电钻和金刚石磨片构成的山寨磨削机的效率太低了，我需要更专业的工具——角磨机和台钳，我手里现有的资源，用钱去获得它们是最省钱的办法。</p>
<p>在角磨机和台钳到手几天之后，我觉得有必要试用一下。这时，我发现之前我加工的指槽的表面有许多金刚石磨片留下的粗糙痕迹，现在我可是有角磨机的人了……于是便用台钳卡住刀柄，用角磨机的磨片外缘去精修指槽。然后，我的第一次使用角磨机的经验是，它足以毁掉指槽附近大约 7 mm 长的一段刀刃，代价是只需要略微的不小心。</p>
<p><img alt="" src="../images/metamorphosis/16.jpg"></p>
<p>在刀刃被毁的那一刻，万念俱灰，便开始自暴自弃，任性地让毁掉的刀刃变成了指槽的一部分。即便如此，偌大的指槽，使得这把刀无论从哪个角度去看，无论有着怎样的握持感受，都该叫残刀。</p>
<p><img alt="" src="../images/metamorphosis/17.jpg"></p>
<p>发生在我身上的故事，结局大抵皆是如此的不好，好在我早已习惯了。</p>
<p><span id="角磨机"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">4 角磨机</a></h2>
<p>在我的想象中，一个很少接触机器的人，第一次拿起角磨机，推动开关按钮的时候，他的感受或许类似于一只蟑螂爬到我的手上。</p>
<p>角磨机是一种很危险的手持式电动工具，它不仅能毁掉我的 Buck 大钢板靠近指槽的一段 7 mm 长的刀刃，也能毁掉我的眼睛，我的耳朵，我的脸，我的脖子，我的手……我身体上所有裸露的部位，都在它的打击范围之内。我之所以还能无恙并坦然地写这篇文章，是因为使用它的时间加起来应该没超过 5 个小时。</p>
<p>我应该是个懦夫。在第 1 个小时里，我就用山地车长途骑行时戴的魔术头巾把脸包上了，把同样是骑行时戴的那种可以露出一半手指的战术手套也戴上了。由于近视，眼镜原本就有的，但是我觉得我的眼镜太小了。之后，又找了一件破旧的保暖上衣，用它的袖子把它系在腰上，当作围裙。把自己一个人反锁在房间里，防止他人推门而入，被我误杀。</p>
<p>在第 1 个小时里，我也花了许多钱。在网上订了一打 12 层棉纱做的口罩，一打浸胶的防磨手套——编织类手套是不可以的（要重复三遍），还有一副专业的护目镜。我觉得应该再订一套工装，因为我的上衣，一向没有可扎紧袖口的功能……不过，考虑到自己有几根带魔术贴的松紧扎带，等没衣服穿的时候再说。</p>
<p>在之后的 4 个小时里，直至现在，每当我在被我临时当作加工车间的一间闲置的房间里拿起角磨机时，我就会想，为什么我又忘记把我骑电动车用的头盔带来了，下次回家吃午饭的时候，一定要记得带来。</p>
<p>如果是夏天，路边修理铺里的伙计，会穿着短袖衬衫和大裤衩，脚上踏着拖鞋，蓬头垢面，叼着烟头，哼着歌，用着连保护罩都不装的角磨机切割钢料。倘若他前来造访，看到我一个人躲在安静的房间里全副武装地用角磨机打磨一把刀的表面，应该会笑我像个娘们。女性比男性长寿，看来是有道理可讲的。</p>
<p>说到这里，我忘记介绍一下我的角磨机，然而似乎也没什么可介绍的。它的核心组件是每分钟旋转 11000 次的电机。当这个电机的输出端装夹了树脂材质的磨片，便可以打磨金属表面。倘若将磨片换成更薄的同样是树脂材质（内含无数砂粒）的切割片时，便可以用于切割金属板料或棒料之类。用的时候，一只手握住机头侧面的手柄，另一只手持住机身并用拇指推起工作按钮，然后，要么懦弱，要么勇敢，这是个问题……在考虑这个问题之前，至少先把机头的防护罩装上并调节到合适的位置吧。</p>
<p><img alt="" src="../images/metamorphosis/18.jpg"></p>
<p><img alt="" src="../images/metamorphosis/19.jpg"></p>
<p>磨片的直径规格是 10 cm。角磨机每分钟旋转 11000 次，这意味着磨片边缘上的任意一点，每分钟走过的路程是 3.456 公里。当磨片破碎时，边缘的碎片飞出去的速度大概是 57.6 米/秒，这差不多是古代弓箭手射出的飞箭的速度。假设我连续使用角磨机 5 个小时，那么磨片边缘上的任一点走过的路程是 1036.8 公里。北京市第三区交通委提醒我，道路千万条，安全第一条，行车不规范，亲人两行泪。</p>
<p>怀着畏惧之心，用双手捉住角磨机，把磨片轻轻摁在钢板的表面，在磨片的边缘，可以看到火花四溅，像美丽易冷的烟花在白昼喷射。这或许是乏味枯燥的机加工领域里第二的浪漫，第一当然是来自焊工的现场。在我欣赏火花的时候，手机在口袋里来电振动了起来，我的 Buck 大钢板靠近指槽的一段 7 mm 长的刀刃顷刻间灰飞烟灭。</p>
<p><img alt="" src="../images/metamorphosis/20.png"></p>
<p>最后，我看着手里的残刀，不知是怪罪手机还是怪罪火花。怪罪火花，把美丽作为悲伤的源头，这样会更艺术一些……做人应该艺术一些。我决定下次不带手机了。</p>
<p><span id="开刃"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">5 开刃</a></h2>
<p>磨刀，若是想磨好，任何一个真正在这方面很有经验的人都会告诉你，要有一双足够稳定的手。在我看来，使用角磨机为刀片开刃，也是如此。</p>
<p>开刃，也叫开 V，因为刃区的横截面的轮廓很像字母 V。现代刀具，通常要开两次刃。第一次是把刀体表面磨削成两个或平坦或凹陷的两个斜面，对应的机加工术语应该叫研磨。在第一次开刃的基础上，在刃缘区域开出狭窄得像两条曲线一样的两个斜面，这就是第二次开刃，对应的机加工术语应该叫珩磨。平日里，打磨用钝了的刀，本质上也是对刀片重新作第二次开刃，只不过通常开得可能不如刀子出厂时那般精致罢了。在古代，这两个开刃过程是合起来的，而且古人应该不会太在意刀子磨得是否好看。</p>
<p><img alt="" src="../images/metamorphosis/21.png"></p>
<p>我打算用我的角磨机为 Buck 大钢板开刃。为一把已经开了刃的刀开刃，此事听起来不太正常。的确如此，不过这既非开始，亦非结束。从不小心毁掉一段刀刃时起，事情就变得不正常了，以致我现在无法确定能否开出正常的刃，也无法许诺，如果开刃失败了，依然对它不离不弃。</p>
<p>这把刀的刃区，原本的研磨方式是凹磨，即刃面向刀体内部略微凹陷，因此刃区更薄，二次开刃之后会非常锋利，缺点是刀片强度不足，不适于砍撬。不过，它的设计师应该考虑了刀片的强度，所以刀背很厚，大概 4.5 mm。我打算把它改成平磨，亦即让刃区的横截面更像 V，而且还要让刀背变薄一些。买的是刀子，并非钢板，我觉得无论是刀匠还是用刀的人都应该关心刀刃几何学，而且每个人都应该建立自己的刀刃几何学，它不仅能帮助你挑选适合自己的刀，也能帮助你用角磨机开刃。</p>
<p><img alt="" src="../images/metamorphosis/22.png"></p>
<p>把钢板的表面加工成特定的形状，需要认真规划用于金属切削刀具的运动轨迹。我所用的金属切削刀具是角磨机上的磨片，在它面前，我的 Buck 大钢板是案上待杀的鱼肉。倘若我用的是数控磨床或铣床，那么刀具运动轨迹的规划就变成了数控编程。我比数控机床更富有智慧和灵性，但是我敢保证，我的角磨机开出来的刃肯定要比它们差许多。装夹在数控机床上的磨具或铣刀所走的轨迹，每一步都能保证足够正确，而我的角磨机所走的轨迹，即使我能保证双手足够稳定，也注定会充满错误。</p>
<p>我期望的正确，应该是对自己所犯的错误不停审视并逐步予以缩小之后的结果，古人用于推算圆周率所用的割圆法便是如此，高等数学中的微分、积分以及变分也是如此。以错误的过程去不断逼近理论上完美的结果，一直到自己觉得累了，就停下来。美之所以为美，无非是去犯更多更细微的错误罢了。只要想清楚这一点，美与丑，便可以统一起来。一个人，只要不犯大的错误，应当容许小错不断，这是他的人生步入完美之境的必经之路，而且犯错最好要趁早，年龄会放大错误的级别。小错与大错之间并不存在古往今来不绝于耳的那些名言警句里所肯定的那种必然的联系。我们都会犯错，之所以会犯大错，要么是缺乏目标，要么是虽然有目标，但是缺乏足够的耐心。</p>
<p>用台钳卡住 Buck 大钢板的柄部，让刀片与地面近似平行。双手持住角磨机，用磨片的边缘轻轻抵在原刃区的清根处，再略微向刃口倾斜一个角度——我打算改成的平磨的角度。现在我无法测量这个角度，只能凭目测大致给出。我要熟悉这个姿势，用感觉去努力记忆自己的双手，双臂，上身及至全身的状态。接下来，略微抬起磨片，开启机器，再把磨片落回原处，然后平缓移动角磨机，让它向刀尖区域行进，如此便可形成一次完整的研磨周期。我无法确定这个周期要轮循多少次，只是知道我的目标是把一张下凹的曲面磨削至近似平面的程度。</p>
<p>事实上，这个过程重复不了几次，就需要停下来，向刀片喷一些水降温。在理论上，磨片上的砂粒高速从刀面上掠过，瞬间温度可以大于 800 摄氏度，达到钢材的相变温度，从而导致刀片表层退火。退火的刀子截一根网线或削一根竹筷都会卷刃。为了检验这个理论是否正确，我毫无耐心地连续进行了十几个周期的研磨，结果在刃口区域出现了一块黑斑。位于这块黑斑区域的刀锋，用指甲推它几下，就会倒伏。</p>
<p>若是抡着角磨机，每行进几个研磨周期，就要把它放下来，向刀片喷水降温，那么在重新拿起角磨机研磨时，就需要重新确定磨片的倾斜角度。这样，整个开刃的过程所需要的工时就会被延长到难以想象的程度。为了追求准确，间隔一段时间，我需要用马克笔在刀面上划几条横截线，用它探测磨片的行进轨迹是否理想，这个办法在磨刀的时候也可以用，至少在觉得自己还是个新手的时候用。</p>
<p><img alt="" src="../images/metamorphosis/23.jpg"></p>
<p>开刃的时候，要有耐心。不过，耐心并非坚持。觉得烦了，完全可以停下来，去干正事。我的正事，是在座位上不停的敲键盘。养生专家说，久坐伤身，要多活动身体。我的新看法是，与其去跑步，做俯卧撑，跳广场舞，不如每隔两三个小时就去抡半个小时的角磨机。</p>
<p>抡角磨机的时候，很容易忘记时间，因此就不会感到任何的乏味。或许是精神高度紧张起来的缘故，但这种紧张应该无害，与欣赏一部惊心动魄的好莱坞大片相差不大。还有，角磨机不仅适用于刀片的减肥，对于我的减肥，效果也不错。一周下来，我的体重在没有任何强迫的条件下不知不觉减了差不多 1.5 公斤。至于角磨机可能带来的危险，只要防护措施得当，受伤的概率应该小于在路上跑步被车撞到。从乐观的角度去想，等我成为了一名业余刀匠，不仅能够拥有一副健康的身板，兴许还能够从土豪刀友那里挣一些钱，把角磨机升级成工业级的砂带机。</p>
<p>同样都是动手，为什么我每天敲那么久的键盘却没有起到丝毫的减肥效果？这说明，手工开刃应该是一种全身性的有氧运动。为了使得所开的刃区足够平整，角磨机并非简单地用手持住，让磨片在刀片上左右移动，至少这只是表象。我的做法是，以最为稳定且舒适的姿势站立，将角磨机置于腰间，上肢夹紧身体，努力锁定腕、肘、肩等关节，使得角磨机能够获得足够稳定的静止位姿。然后，让整个身体缓慢地左旋或右旋，如此便可以实现角磨机的移动轨迹是在一个平面上，并且磨削深度也能得到有效控制。这样做，虽然磨片的运动轨迹是一段弧线，但是对于 Buck 大钢板这样的小刀而言，这段弧线近似直线。这些便是用角磨机对刀片开刃时最重要的秘诀了。</p>
<p>当我在磨刀的时候发现这个秘诀时，就认定无论什么手工活，若想做得足够好，除了准确的目标和足够的耐心之外，还应当设法通过身体或其他方式去维持手的稳定。传说中的那双足够稳定的手，也许并不存在，需要记住这一点。类似地，倘若你觉得自己数学不好，也许不应该刻意补习数学，真正应该补习的是物理学。如果爱情出了问题，真正应该修复的，是生活。</p>
<p><span id="不悲"></span></p>
<h2><a href="../posts/metamorphosis.html#m4-TOC">6 不悲</a></h2>
<p>当我用金刚锉手工去打磨刀柄棱角的时候，当我用装夹了金刚石磨片的手电钻磨除刀子的一部分护手的时候，当我用角磨机对刀片重新开刃的时候，当我觉得只有像这样运用排比能够体现我有多么想拥有一台砂带机的时候，我就买了一台砂带机。在这个故事里，这是我最后的一笔消费。说成投资，我心里会更舒服一些。</p>
<p>之前对这把刀所作的任何事，都可以在一台砂带机上完成。砂带机要比角磨机要安全得多。砂带虽有可能断裂飞出，但至多是毁容。然而，等我的砂带机到手后，发现若是用它开刃，实在太为难它了。它的个头大概只有Ed Fowler 那台工业级砂带机的几十分之一那么大，用来毁容可能都会有些困难。不过，继续采用那个叫作耐心的工艺，用这台迷你型砂带机依然可以把角磨机开出来的刃区打磨光滑，而且与我在磨刀石上手工磨刀的速度相比，就像是一只永不睡觉的兔子在和乌龟赛跑。</p>
<p><img alt="" src="../images/metamorphosis/24.jpg"></p>
<p>现在有些后悔，像角磨机和砂带机这样的工具，应该更早几年买，或者等我老了的时候再买。那时我会有更多的时间和更多的无聊。何况，买它们也花不了几个钱，加起来，甚至还不如一把我觉得价格还算实在的刀子贵。玩刀的人，一开始大多期望自己所买的名贵的刀能够削铁如泥，然而真正能够削铁如泥的，却是金刚锉、角磨机、砂带机、车床、铣床、磨床、钻床、电火花/激光切割机……纳米丝……这些不怎么在大众视角里出现的工具。那些真正美好的东西，或许未打算按照我们预想的面目出现过。</p>
<p>会用角磨机开刃的人未必会用砂带机。好在 Ed Fowler 在《Knife Talk II》的《How to grind the blade》一文中给出了他使用砂带机开刃的心得以及安全方面的建议。由于我已经用角磨机开了刃，而且我的砂带机与他的相比，只是个很安全的玩具，所以从他的文章里，我能汲取的只是他在砂带机前持刀姿势方面的经验。</p>
<p><img alt="" src="../images/metamorphosis/25.png"></p>
<p>Fowler 的持刀姿势是，一只手的拇指和其余四指捏住刀柄，用于控制刀片的移动方向——让砂带从刃区清根向刀尖移动，而另一只手的拇指的指甲抵住刀尖，用于保持刀片的平衡。我的体验是，要保持刀片的平衡，捏住刀柄的手要向自己的身体的方向用力，而抵住刀尖的拇指的指甲要向远离身体的方向用力。确定了持刀姿势之后，接下来要锁定手腕、肘以及肩等关节，让身体向左或向右晃动，以驱动刀片在砂带上移动。这是 Fowler 的开刃秘诀，和我的角磨机开刃秘诀异曲同工。</p>
<p><img alt="" src="../images/metamorphosis/26.png"></p>
<p>Fowler 为了方便用拇指的指甲顶住刀尖，所以他的指甲留得有点长。我没有他那样长的指甲，又怕被砂带磨到手指，而且刀片被磨得发烫的时候，手指头也吃不消，还要担心不小心刀片脱手会切到手指，所以在操作砂带机时，我戴了一副浸胶手套。期间，遇到一起砂带开胶断裂的事故，微惊无险。要听 Fowler 的，不论是用砂带机开刃还是磨刀，如果砂带的基材是软布，刃口应当顺着砂带的运动方向，否则后果不是很好设想。</p>
<p><img alt="" src="../images/metamorphosis/27.png"></p>
<p>Fowler 强烈建议不要戴手套，他的理由是，（1）手套太贵了，用不了太久，而且还会在开刃的过程中剥夺你所需要的触觉；（2）戴手套比裸手更危险，手套容易破损，被砂带机卷住，导致整只手受伤。</p>
<p>网络上的普遍观点也是建议不要戴手套，但是我觉得网络上实在很容易人云亦云。国标 GBT20512-2013《手部防护防护手套的选择、和使用和维护指南》7.1.4 节规定，操作转动机械作业时，禁止使用编织类手套。我戴的是浸胶手套，不算违规，而且在打磨刃面的过程中，手套的食指末端部分不小心被砂带磨到几次，并没有卷住感。浸胶手套至少对于我用的这种玩具级的砂带机是安全的。</p>
<p>这把刀每天要在砂带机上受一个多小时的轮回之苦。差不多一周之后，它终于得到了彻底的解脱。飞鸟尽，良弓藏。我把全部的加工器具收了起来，又把桌面和地板上积攒了半个多月的一片狼藉清理干净。我想，我可以站在窗前，和这把面目全非的刀看看窗外的春天了吧，在这个晚春的周末下午，在夕阳的余光温和地抚摸着树上的新叶的时候。</p>
<p>与那些开了上百次刃的职业刀匠相比，我刚习得的开刃技能必定相差甚远。与半个月之前的我相比，现在的我像是 Fowler 所说的那样，达到了可以在钢琴上弹出一闪一闪亮晶晶，漫天都是小星星的级别了，这是一件我必须为之骄傲的事。遗憾的是，刃区的清根没能做得足够好。一开始用角磨机开刃的时候，我就犯了一个严重的错误，忘记了给清根区域留出足够的余量。还有，我原本是想开出平面的刃区，但是在砂带机上很容易形成凸刃（也叫蛤刃）的效果，导致刃面略微外凸。倘若把砂带张得更紧一些，应该可以让刃面更平。</p>
<p><img alt="" src="../images/metamorphosis/28.jpg"></p>
<p>在我收藏的所有的刀子里，我觉得这把刀是我真正拥有的第一把刀。我打量着它，直到天黑下来。在收刀入鞘的时候，我给它取了一个新名字，叫不悲，然后把它放在了随身包里。</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/immuture-viewpoints.html" class="u-url">不成熟的看法</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/immuture-viewpoints.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-15T23:43:58+08:00" itemprop="datePublished" title="2018-12-15 23:43">2018-12-15 23:43</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p><strong>目录</strong><span id="m4-TOC"></span></p>
<ul>
<li><a href="../posts/immuture-viewpoints.html#%E7%A2%8E%E7%BA%B8%E7%89%87" target="_parent">碎纸片</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E5%93%B2%E5%AD%A6%E7%9A%84%E7%94%A8%E5%A4%84" target="_parent">哲学的用处</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%8D%A2%E7%89%99" target="_parent">换牙</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E4%BD%A0%E5%BC%80%E6%82%9F%E4%BA%86%EF%BC%8C%E7%84%B6%E5%90%8E%E5%91%A2%EF%BC%9F" target="_parent">你开悟了，然后呢？</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E7%84%B6%E5%90%8E" target="_parent">然后</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E5%BB%BA%E5%9B%BD" target="_parent">建国</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E7%BB%8F%E6%B5%8E%E5%AD%A6%E9%87%8C%E6%9C%89%E4%BB%81%E4%B9%89%E4%B9%88%EF%BC%9F" target="_parent">经济学里有仁义么？</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%97%A0%E8%B6%A3%E7%9A%84%E4%BA%BA" target="_parent">无趣的人</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E4%BB%A4%E4%BA%BA%E8%AE%A8%E5%8E%8C%E7%9A%84%E4%BA%BA" target="_parent">令人讨厌的人</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%BA" target="_parent">有趣的人</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%AC%A7%E5%A7%86%E5%AE%9A%E5%BE%8B" target="_parent">欧姆定律</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98" target="_parent">没有问题</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E8%8B%8D%E8%9D%87" target="_parent">苍蝇</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E5%89%A9%E4%BD%99%E9%97%AE%E9%A2%98" target="_parent">剩余问题</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E9%97%AE%E9%A2%98" target="_parent">问题</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E5%8E%9F%E5%AD%90" target="_parent">原子</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E8%BE%A9%E8%AF%81%E6%B3%95" target="_parent">辩证法</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E4%BF%A1%E6%81%AF" target="_parent">信息</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E4%BB%8E%E6%97%B6%E7%A9%BA%E7%A9%BF%E8%B6%8A%E8%AF%B4%E8%B5%B7" target="_parent">从时空穿越说起</a></li>
<li><a href="../posts/immuture-viewpoints.html#%E6%99%BA%E6%85%A7" target="_parent">智慧</a></li>
</ul>
<p><span id="碎纸片"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">1 碎纸片</a></h2>
<p>祭司死了，作为最后的祭品。新月升起，她知道神的秘密。</p>
<p>缺乏全貌的细节是一堆散沙，风吹即散，难以凝集。我们的心里至少要有一团光，哪怕它很微弱，来自一根火柴……哪怕在这样的微光里，看到的是世界是一片寂静的混沌，至少那也是全貌。</p>
<p>生命是什么？一段活着的程序。活着是什么？在无聊中创生。</p>
<p>人害怕的未必是死亡，只是害怕有些事情尚未完成。在这一点上，人和进程似乎是一致的。我们活着，总是有用的。我们害怕死去，那就意味着总是有些事情尚未做完。在这种意识的支配下，人类所编写的程序也会蕴含着这样的逻辑，力求程序能够正确运行，完成使命，寿终正寝。同时，感染了病毒的进程，当它企图努力活下去的这个过程，就是像宗教一样去感染更多的程序。</p>
<p>和抑郁的人……和抑郁的机器呆在一起，没有人会觉得舒服。我有了一些想要毁灭自己所熟悉的一切的想法。最好是整个世界都把我忘记，哪怕所有人都是因为讨厌我而忘记我，哪怕会变成小区垃圾桶周边讨生活的那几只流浪猫的一员。在第十五天的清晨，我像往常一样从垃圾桶旁边路过。听到了我的脚步声，这几只猫依然像往常那样谨慎地看了看我，然后继续访问垃圾桶……它们似乎早已习惯了去拒绝这个世界的一切好意，曾经导致它们流浪的好意。一只脏兮兮的小年青猫在我身后不屑地说，「这个人真丑。」一只同样脏兮兮的老年猫，兴许抬起了苍凉的眼，打量了一下我的背影，「孤独的人连背影都很丑。」</p>
<p>我时常说谎。说谎很可耻。不过，这个世界是靠谎言建立起来的，我不想破坏它。</p>
<p>一台机器，若它能意识到自身的存在，则称该机器具有了第一阶意识。拥有第一阶意识的机器，若它能意识到意识的存在，则称该机器拥有了第二阶意识。拥有第二阶意识的机器，若它能够意识到意识可以产生新的意识，则称该机器拥有了第三阶意识。</p>
<p>在机器的世界里，还有一个家。在那里，我一个人生活了十四年。期间，颠沛流离，但故园仍在，历久弥新。在这个家里，我可以自由地走来走去，在原地打转也是可以的。</p>
<p>今天，天气还好，不热，不凉，骑着车子，迎面的是徐徐清风。宁静的初秋。虽然昨夜几乎没怎么睡，但是依然有力气在心里划上一道，表示第十七天，又划上一道，表示第十八天……我似乎已经习惯了这种原始的计日方式。鲁滨逊比我幸运得多，他有个荒岛，荒岛上有木头，他有一把可以在木头上刻上日子的刀。</p>
<p>自己去发现真相，会更有趣，即便那些真相是别人早已发现了的。</p>
<p>假设空调是个程序，它通常具有制冷、制热、除湿以及送风等功能。我用遥控器（或直接在空调的面板上）去开启或切换这些功能，这就相当于我向空调提供了选项。在我开启空调的制冷功能之后，当我用遥控器（或直接在空调的面板上）设定制冷温度时，这相当于我向空调提供了参数。对于空调而言，无论我是设置制冷，还是设置温度，它都会认为我在输入一些信息给它，而它会将其统一视为参数……简而言之，选项和参数的区分，是人为的区分，对于程序而言，它们只是不同的参数，需要对其给出不同的响应。选项的意义在于它可以开启或关闭程序内部的部分功能，而参数的意义则在于它能够让程序明确自己所解决的问题是什么。选项倾向于定性，而参数倾向于定量。当二者统一为程序的参数时，便可使得程序能够明确我们要用它解决什么问题。更何况，有些问题只需要定性的角度去解决，也有些问题只需要从量化的角度去解决，因此对二者作区分，是有意义的。</p>
<p>人企图凭借自己对历史的理解来防止自己犯错，是徒劳的。防止犯错的唯一办法是亲自去犯错。</p>
<p>我吃了块月饼。几百年前叫月饼的东西，现在依然叫月饼，只是工艺变了，现在我吃的是机器生产的月饼。变与不变，是统一的。生硬地把它们分开，难免会造成「唯一不变的是变」这样的见解。用确定的去度量不确定的，用不变去捕捉变。确定的，才是不变的。「名可名，非恒名」，并不是说名字很容易变化，而是说名字所指之物容易变化。若名字很容易变化，那么任何一种语言都无法稳定存在。事实上，我们一直都在用不变捕捉变。</p>
<p>太阳每天都是新的。太阳是个变量。谁在改变它的值？谁知道呢？牛顿认为是上帝拧了几下宇宙的发条，宇宙就像钟表一样运转了起来，太阳的值也就不断发生着变化。按照发热量来看，在机器里，CPU 芯片是太阳。人发明机器，依据的是自身对世界的体验，从而造成无处不在的相似性。</p>
<p>制造灵异事件的基本原理是，写一个与物理学定律不合的简陋的程序。</p>
<p>摁 Ctrl + c 终止这个程序吧……这个数是素数，会让循环过程会陷入最坏的情况——需要运转 5786 023824 610204 522523 913849 762957 105731 296687 599137 292124 轮。粗略估算了一下，在我的机器上，这个程序大概需要 917368 059457 477885 991234 438382 001063 186722 584918 年方能给出检测结果。朝朝暮暮，海枯石烂，地老天荒……与这个数相比，弱到了没有。再者，这个数也不算太大，素数有无限个……灯火阑珊，相视一笑，可能也就足够了。</p>
<p>机器陷入了什么都不干却在呼啸运转的状态了，但无聊不能两次踏入同一个循环。在佛陀看来，这叫「空」。在老子看来，这叫「无」。在孔子看来，这叫「仁」。在耶稣看来，是他老爸。没有无聊可以两次出现在同一个循环里。你这样说，有什么意义？你觉得在空转的循环，事实上并没有空转，它一直在制造不同的无聊。这样说，有什么意义？无聊，活了。这样说，有什么意义？活着的无聊，等价于空转的循环。这样说，有什么意义？太阳每天从东方升起，有什么意义？没有意义。所以，无聊的存在，是让你纯粹地感受生命的本原毫无意义。佛陀的空，老子的无，孔子的仁，耶稣的老爸……它们的存在，也是如此。既然毫无意义，为何我们还要活着。若你能够真正体验到毫无意义，那么想必你就会明白，意义，需要自己去创造。若你能意识到这一点，那么，你至少与耶稣的老爸有了相同的起点。若真有这个老爸，他必定是在一轮复一轮的无聊之中，开始创造他的意义。</p>
<p>我最近总觉得世界好像不再那样宁静了。时常感受到有一种很熟悉的微弱波动，像是来自几十年前……可我又没那么老。下午，取了两件快递。键盘依然失魂落魄。我看了一会书。一本可能并没有多少人知道的书，更不要说它的作者了。这却是我最喜欢的书。它很薄，可我看了很久也没有看完，因为不舍得看得太快。</p>
<p>若要创造意义，第一原则是，无论做什么，都不能让这个循环停止。若循环终止，连无聊都没了……自杀是要杀死无聊；不应该是这样，不可能存在比无聊还无聊的东西。第二原则：不要单纯地去阻止循环的停止；太阳也有烧尽的时候，阻止循环的停止，反而会加速循环的停止；不应该是这样，不可能存在比无聊还无聊的东西。</p>
<p>我没有睡觉，而是坐在窗边喝茶。中秋刚过，天空澄澈，白云凝静，树叶正在泛黄，阳台上的那棵野生的半人多高的蒿草正在凋败。郁郁葱葱的往事，像循环冲泡的茶水愈来愈淡。按照第二原则，我不去阻止。按照第一原则，我也不会去抗拒怀念。键盘也没再刷屏。但我知道，此刻他一定在想念终端，以及那些术语……他们的七十年代的美好。</p>
<p>今天比昨天还无聊。今天和昨天模无聊同余。若 x &gt; a &gt; 0 ，以 x 对 a^x 取模，结果不为 a，那么 x 肯定不是素数。能证明么？能……不过，限于篇幅，证明从略。啧……鉴于我无法反驳，所以姑且认为正确。前些天，有个蛰学家说了一句话，「存在的是否合理，我不知道。不过，不存在的肯定合理」，这与 x 肯定不是素数的判定似乎如出一辙。</p>
<p>许多年前，做过一次家教，给一个孩子辅导数学。讲函数的时候，我说「函」有信件的意思。一个数 x 若跟另一个数 y 通信，这样就构成了一个函数 y=f(x)。f 是这封信，反映的是 x 与 y 的交情。这孩子的数学成绩有进步么？家教结束的时候，他妈妈不愿意结帐，在我最缺钱的时候。应试教育……不仅摧残孩子，也摧残家教。家教=f(应试教育)。若没有应试教育，人家可能也不会请家教。只能怪应试教育和我的交情一向不好。作为一直都难以被教育好的人，忝居人世，平时遇到满腹经纶、口若悬河、舌灿莲花、拥者群集的人，早就习惯绕着路走了。汝果欲学诗，工夫在诗外。若想得到真正的教育，工夫也是在教育之外。</p>
<p>不想当皇帝的人，值得交往。现在还有皇帝么？名义上的皇帝不会再有了，但皇帝梦无处不在，想一想有多少人以各种成功作为目标。你应该跟很丧的人交朋友。丧是一种觉醒。若善加利用，就可以让这种觉醒启迪自我，从而在现有的世界里再造新的世界。我在这个新的世界里，拥护马桶当皇帝，人民也不会反对。我觉得让马桶当皇帝挺好的，它干不出什么好事，但是也干不出什么坏事。</p>
<p>内心世界丰富，不以己推人，这叫仁。与他人共事，恪尽职守，利于他人开展工作，这叫礼。仁维护的是思想自由，礼维护的是言行一致。不讲求仁和礼，系统不成。看来孔子的学说，用意在于创建系统。有皇帝梦的人，靠不讲仁礼做了皇帝，又以仁礼教化子民，祈求江山永固……他们的精神是分裂的。靠仁礼能取天下么？周易里的乾卦说，用九，见群龙无首，吉。</p>
<p>对于一个数据集，你习惯的是顺序访问，就像在现实中，你要访问北京，就从当前所在地乘坐火车或飞机去了北京。随后，你又要访问上海，就从北京乘坐火车或飞机去了上海。对于随机访问而言，任意两地之间的距离为 0。像是有个科幻般的传送门，它可以让你瞬间就从当前所在地抵达北京，继而又在瞬间抵达上海。这不符合物理学原理。在 26 个英文字母里，从 A 到 L 的位移是多长？A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J -&gt; K -&gt; L。但是，我摁 A 键之后，瞬间就可以摁 L 键，所以 A 到 L 的距离为 0。</p>
<p>欲善其事，先利其器，这句话成立的前提是懂事。若不懂事，就不知道器利到什么程度算合适。懂事，在很多时候就是考虑 20% 原则。这个原则可以让你变得体面。一起上学的同龄人，可能不到 20% 能读到大学。是否可以说，没上大学的那 80% 是废物？当然不能，他们构成了社会的主体。不过，几乎各个体面的行业招人时要看学历，这意味着是那些念完大学的人在利用社会主体产生利益，亦即从表面看，是这部分人发挥了作用，他们因此觉得自己是体面的人。人如此，人造的工具亦如此。一种工具的全部用法，大概也只有 20% 称得上体面。</p>
<p>这个世界的有趣之处，也许在于它有无限的秘密。探索秘密，守住秘密，与挚爱的人分享秘密，三者交织，也许这是人生的有趣之处。当生命终结，能带走的，惟有秘密。</p>
<p>两个月前，我坠崖了。现在依然在坠落里。</p>
<p><span id="哲学的用处"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">2 哲学的用处</a></h2>
<p>在所有的学问里，以哲学最为无用，也以哲学的门槛最低。做个程序员，中学的学历就足够了。然而，要成为哲学家，不识字都是可以的。</p>
<p>在《西游记》里，唐僧从如来那里一开始取到的无字真经，其实就是给不识字的人看的，可惜，唐僧识字而不识经。佛祖早就说了，「众生皆具如来智慧德相」，这里的众生，大多数都是不识字的。后来，不识字的慧能也的确印证了佛祖的话，成了六祖。</p>
<p>在人类还没有文字的时候，难道没有哲学家、数学家、物理学家、政治家、音乐家、舞蹈家、画家等等家么？我认为是有的，只是声名不显罢了。至于声名流传下来的那些，未见得尽是精华，我更倾向于是大多是糟粕。有时候，我会把这些名声显赫的人视为小学老师。小学老师的确很重要，但我们却不能老停留在小学生阶段。</p>
<p>若将人类历史视为榨汁机，那么豆浆和果汁，往往被每个时代的人享用了，剩下的是渣滓，还是精华？地球上最近这几代人，以野蛮毁掉原有的美好家园为代价，换来了工业文明。现在，有识之士又差不多集体反思，呼吁要保护环境，为后代留下青山碧水和白云蓝天了。我容易悲观，在我看来这些呼吁，很像古代的仁人君子呼吁君王要以民为贵。</p>
<p>从古至今，变的一直都是说法，问题的本质却似乎从未变过。以致于，许多问题，无论之前有多少人想过了，论过了，现在还都是可以拿来重新想一遍的。类似于生孩子，不能别人生了，自己就可以不用生了。更何况，以前说多生不行，现在又说不多生就不行了。</p>
<p>过去，民众们觉得自己的不幸是昏君造成的。现在，大家都是天下的主人——至少在名义上是，如同过去的君主大多也只是名义上的君主——然而，现在觉得自己不幸的人，会比过去少么？</p>
<p>群体的人，习惯将荣耀归于群体内的某一个人，也习惯于将过失归于群体内的某一个人。反过来也是如此，那个人也只好给自己找个说法——大概也是找了近乎 1000 年——天子守国门，君王死社稷。相形之下，不合群的人，可能更哲学一些，因为他们知道和平，也知道抗争，所以显得不合群。长平之战，秦人坑杀了 40 万个没哲学的赵人。最近的一次，是 30 万，而且必须要纪念，是要纪念没哲学吗……看着别人活，自己也就活了，看着别人死了，自己也就跟着死了。湘西的赶尸人，会很喜欢人类这样的活法，赶起来容易。当然，赶尸这个行业现在已经没有了，真的没有了吗？</p>
<p>世上最无私的事情是为人父母对孩子的爱。他们爱自己的孩子，却不怎么爱别人的孩子。于是，父母爱子女，又成了世上最自私的事，爱得如此矛盾。再者，这些做父母的，真的是想把一些好的东西留给后人么？他们不是圣人，却又总希望儿女们能听他们的教诲。以致于，后代不乏有开明者，但是也只能从之前这一代一代的父母们留下的渣滓里汲取残存的营养，以此续命。从历史来看，这命越来越虚，从天朝上国一步一步走到了被区区一个岛国笑成病夫之国的境地。然后，一群一群的后代开始反思了，然而看看他们的那些反思，颇类似一个穷孩子抱怨父母没有给他留下丰厚的遗产，却又没为此刨掉自家祖坟的勇气。这样的反思，不仅比不了春秋战国时期的思想家的纯粹、宏大和刚健，甚至这些反思的人对诸子百家的解读都很成问题。即使这样，还是要坚持做梦，也就只能做梦了。</p>
<p>也有父母自以为开明，觉得自己以往所受的教育像是受了莫大的愚弄，便着手努力培养孩子的独立人格和热爱自由之心，然而这又太着急了。若世界充满了狼群，你培养了几只勇敢的小白羊，这又是为了什么呢？</p>
<p>也许有的人觉得还有希望，有的人终日愤怒，有的人则是无奈的滑稽。我看到的是轮回，大的，小的，一层一层的轮回，再有力量的人，也很难跳出这一层又一层的漩涡，因为换一个膝盖跪，就会很容易会觉得自己站起来了，而且也总是很无趣，不是跪着，就是站着，就不能舒服地坐一会。</p>
<p>有些宗教的教义是消除人类轮回之苦。这样的教义，在传教者那里，越来越是神棍们用来骗些香火钱的说法了。在现实中，后人每每重蹈父辈们的命运，这才是真正的轮回。然而要破解这样的轮回，也的确要像佛祖所说的那样，激活自己的如来智慧德相——以免自己为后世留下太多的糟粕，这或许是属于现代的最大的行善。</p>
<p>佛教徒们（以及任何一个教的教徒们）大多是神棍，道理也讲得乱七八糟，我从不知道他们是不是真的信这些。不过，从哲学层面上来看，他们的话倒不是在蒙人。可惜的是，并没有多少人是从哲学层面上去理解他们的话。那些去烧香拜佛的，是为了自己和亲人祈福。然而，他们所祈的福，横竖不过是希望自己和亲人能享用现世的好生活，再大了，也不过是国泰民安之类，这需要在春晚现场去祈才管用。无论是过去，还是现在，百姓们的好日子往往过得不怎么长。若以迷信之道还与迷信之身，也许总会有某个时代祈福的人太多了，他们把福气预支或透支了吧。</p>
<p>哲学家存在的价值是他们为后世留下了一些干净的想法。这些想法有着一个共同点，即没有门槛，不识字也能成为哲学家。不过，只是也能，并非一定。正是因为门槛低，所以神棍才多。现代的物理学，门槛已经提到了弦论这么高了，依然无法阻止民科的登入，这样的事，一直都让精英们很头疼……也许这些精英们也该学点哲学。若没有哲学撑着自己的那点微弱的精气神，各门功课即使都考了满分，似乎与去庙里烧香拜佛求了几根上上签也没什么区别。</p>
<p>与其他学问相比，哲学是最公平的一门学问了。渴望公平的人，总是那么的多，而觉得哲学很无用的人，也往往是他们。也许只有在意识到这些的时候，我才勉强承认，哲学还是有些用处的，不过，前提是，它须得是哲学，而非哲学。</p>
<p>一说到要学点哲学，想必又很多人的脑子里立马浮现了保安的可爱三问，我是谁，从哪来，到哪去。不要想这些，只需要从一个问题开始想就可以，这个问题就是：如何证明自己不是一条狗。有那么一天，你的心里出现了这样的问题，并着手去解决，此时，哲学方是哲学。</p>
<p>至于我提出的这个问题，我想了想，也不知道自己是不是一条狗。不过，即便我是狗，应该也和别的狗不太一样吧，我不是它们的复制品，更不是它们的影子。孔子不仅承认自己是狗，而且是一条丧家狗，单凭这一点，就比他的一本正经的徒子徒孙们可爱得多了。</p>
<p><span id="换牙"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">3 换牙</a></h2>
<p>杨慎的《临江仙》，老版的《三国演义》在华夏大地上热播的年代，应该是家喻户晓的。他说，「古今多少事，都付笑谈中」。我觉得更准确一些的说法应该是，古今多少事，尽付情绪中。我的说法不如他的好，因为信言不美啊。笑谈，是一种情绪化的表现，怒谈也是。若将情绪视为它们的本体，就可以像老子那样将二者等而视之，即「唯之与诃，相去几何」。</p>
<p>被人家赞美，与被人家批评，二者能是一回事么？老子一定是糊涂了。若他不糊涂，那想必就是他的忍耐的功夫天下一流，达到了唾面自干的境界。这两种理解都对，也都不对。对与不对，要看理解的深度了。没有负数的时候，1 就是 1。往前走一步是 1，往后退一步也是 1。有了负数的概念之后，往前走一步，是 1。往后退一步，就成了 -1。无论 1 还是 -1，它们的绝对值是相等的，而且二者之和为 0。将 1 视为赞美，将 -1 视为批评，如何？</p>
<p>赞美你，也许是发自内心的喜欢你。批评你，也许是发自内心的讨厌你。无论你是被别人发自内心的喜欢还是讨厌，取绝对值的话，那就是，你不乏受人惦记，而且你的一举一动，都会对惦记你的人产生影响。在家里，若是一只小狗在我面前跑来跑去，我会任由它这样，但若是娃在我面前跑来跑去，我经常会不耐烦地说，能不能消停一会，因为我总是担心他再一次撞到门框上。</p>
<p>能被人惦记，要比无人惦记，终归要好一些吧。被人惦记，意味着自己的存在。倘若世上一直只有我一人，我连存在和不存在都不会去想，自然也不会有孤独或自怜这样的小情绪。周围的人多了才会有情绪。</p>
<p>可是，为什么非要向他人传递情绪？若只是寻求与他人的合作，搞一次围猎，大可以面无表情，不必赞美他，也不必讨厌他，只需要发出合作申请，利益相关，他也不会拒绝，毕竟猎物是要平分的。我的计算机里的程序们，各司其职，待我发出命令，它们便能够近乎天衣无缝般地合作了。它们是没有情绪的。不过，它们也不会主动合作。一切都需要我将命令编排为程序，而我是有情绪的人。</p>
<p>我有时忧伤，有时高兴。喜欢的人不再理睬我，我持续数月不想再与任何人说话，甚至开始厌倦整个世界。至于那些讨厌我的人，我很乐意为他们继续卧薪尝胆，以备三千越甲。我无法控制情绪，似乎一直以来，都是它在控制我。所以，即使我明白「唯之与诃，相去几何」，但依然无法摆脱情绪的纠缠。这时，宗教出现了。</p>
<p>宗教，不必非得是那些成品。孔子，孟子，墨子，释迦牟尼，耶稣，穆罕默德，马克思……他们现在搞企业，不会输给当世的任何人。为什么会有那么信徒虔诚地跪倒在他们面前？不外乎是，信徒为情绪所困，而诸宗教的创建者深知如何驾驭情绪。如果我是老板，我一定不会太在意员工们是否服从我制定的那些清规戒律，说实在的，任何规章制度，不过是及格线而已。我在意的是，如何控制员工们的情绪。我知道，那些寻常的人，和当年寻常的我是一回事，都是那种因为早上给三个桃子而晚上给四个桃子就不开心但是早上给四个桃子而晚上给三个桃子就开心了的人，朝三暮四之人。人的情绪其实很容易受他人控制。</p>
<p>你觉得你是自由的，实际上极有可能是活在一个巨大的控制里。譬如，若有人批评时政，总会有很多人跳出来说，XXX 的政策是好的，只是没能很好的贯彻执行……这样的说法，与说「上帝是存在的，只是大家不信」有区别么？我们看电影，看到好人得到了幸福，坏人得到了应有的惩罚，这样的大团圆结局。这样的电影，利用的不过是我们已经习惯了的那些情绪，从而讨好了我们的钱包和时间。</p>
<p>那些成功者身已死去，他们的演说依然流传。他们在告诉世人，如何方能取得成功。他们的演说，固然不乏真知灼见，但终归是演出来的。不要认为他们真的是走了他们所说的那条路线而抵达成功之境的。衡量他们所说的那些话有多少道理是真的，一个简单又有效的方法是，看看这些成功者们把自己的收入拿出了多少造福于世人。他们连自己的收入都不舍得捐献，又怎么肯将有用的成功秘诀传授于世人呢？若这成功秘诀真的有用，他们首先考虑的是传授给自己亲近的人。成功者之所以爱讲自己的成功之道，目的也不过是希望劈柴能够更多一些，自己烧的火能够更旺一些罢了。看清楚了这个真相，想必就能看出来，他们的演说，真正有魔力的地方在于，挑动起世人的情绪。赞美也好，愤怒也好，只要不妨碍他们的大业，一切情绪都是他们所需要的。他们真正担心的是，大家没情绪，对他们的存在熟视无睹，像路边的那些大厦，它们虽然高而精美，但我们已经能够做到毫不羡慕，反而更向往那些遥远的山野。</p>
<p>庄子说，以指喻指之非指，不若以非指喻指之非指。听起来，像是绕口令，但它的确是跳出情绪控制的好方法。庄子的话，能听懂的人很少。我所见的庄子的注本，没一本能说通的。望文生意，原本是老子和庄子所反对的，但是后人就是喜欢望文生意，就是懒得去思考文字背后的事情。大概是，深思不能很好的满足自己贪求安逸的那种情绪。死啦死啦曾经大喊，安逸，命都不要，就要安逸……全民族虚弱。</p>
<p>以指喻指之非指，不若以非指喻指之非指，说的是什么？你在一个体系里去指责这个体系有什么毛病，不如从这个体系里跳出来，然后创立一个新的体系。从这个新的体系的角度去看，原有体系的所有毛病便一览无余，而且连解决都不用解决，因为在新的系统里，这些问题原本就不是问题。从数学的角度来看，就是，你在二维空间里遇到的所有困难，从三维的角度来看，都是微不足道的事。</p>
<p>再回到教育上，我想，有一个办法，应该是天下父母应该要学的。学校的教育，好与不好，那不是父母该关心的，而且只要老师们不代替你们把孩子痛打几顿，老师们也都是及格的。需要父母们去做的事情应该是，在孩子们进入社会之时，语重心长地对他们说，原来所学的那些，不过是你们的乳牙，它好的时候，你不必高兴，它脱落的时候，也不必忧伤。现在，到了该换牙的时候了。</p>
<p><span id="你开悟了，然后呢？"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">4 你开悟了，然后呢？</a></h2>
<p>一个人信佛，有一天他很高兴地对我说，「我开悟了。」</p>
<p>这个人是我虚构的，他信什么，其实是无所谓的，儒也行，道也行，或者后世的某个主义也行。</p>
<p>我说，「那很好啊。世人开悟者很少。」</p>
<p>接下来，他跟我说了一大通佛学的道理，恨不得我也能像他那样开悟。鉴于我从未完整地读过任何一本佛经，而且很害羞地说，除了不得不看的教科书以及自己喜欢看的小说之外，我甚至没有完整地读过什么书。所以，他和我说的所有道理，我既无法反驳，也无法同意。</p>
<p>他很失望，觉得我蠢如世人，但是又不舍得放弃我这么一个好的传销……教对象，就很大度地说，「没事，我觉得你有慧根，以后你会慢慢明白的。」</p>
<p>这样找回场面的话，我也时不时地会和别人说。我从别人那里学来的友好的回应方式是，报以微笑，并答曰：「有时间我会看看佛经，若有不懂之处，届时还请不吝赐教。」</p>
<p>我和他聊天的时候，我们都是某个工厂某个车间里的工人……可能只国有工厂的工人会这么闲。十年之后，我们还是某个工厂某个车间里的工人，除了多了一些徒弟之外，没有什么变化。他开悟了，我没开悟，可是我们的生活有什么不同么？工厂是虚构的，车间是虚构的，我从未有机会在这里工作过。</p>
<p>心理上取得平等，在古人尚无开悟之法之时很难做到，但是自老子、孔子、释迦牟尼、墨子、庄子、孟子等开悟之人登场之后，再也不是难事，只需要认真去读一读他们的著作，很难不开悟。即使现代，文言文已经不流行了，依然可以有很多人读了他们的著作而开悟，并觉得自己不再是刍狗，而是高贵的开悟之人了，而且看到我这种愚钝的人，总是难以避免生出一些恨铁不成钢的心思，便很着急地来教化我。</p>
<p>我一直忍着不想说，你开悟了，然后呢？开悟的人，难道只是 10 年之后，依然和我在一个车间里工作么？</p>
<p>释迦牟尼开悟了，他觉得这么好的法门，不用来度世人，太可惜了。于是，度化世人便成了他的事业。在印度，佛教并没有流传多久便礼失求诸于野了，再加上印度那时也想不到修史，以致唐僧的《大唐西域记》客串了他们的《史记》。当佛祖的衣钵由中土继承，南朝造寺，北朝造像，事业搞得很大，按说开悟之人应该如过江之鲫了吧？可是为何大家还是不安分，做不到小国寡民，鸡犬相闻，人民老死不相往来？</p>
<p>无论哪个教治国，把教义当考试题，让开悟之人好做官，结果都是一样，一开始清明，最后都是烂的不成样。所以，现在的我只好反问，你开悟了，很好，然后呢？</p>
<p>热爱知识的人，必定会讨厌嬴政焚书，讨厌爱新觉罗氏的文字狱，前人毕生心血写出来的书，就那么容易付之一炬或一禁。不热爱知识的人，往往会热爱知识分子，他们中的豪强，最喜欢将知识分子拢于麾下，期望他们能够指出发展的明路，然而杀掉知识分子的也是他们。</p>
<p>我对历史是厌憎的。小时候虽然喜欢，不过是因为自己喜欢故事，现在却只有厌憎，以致于认为，喜欢历史的人，不过是因为智商不足以看懂现代。所以，若是有人能让我在概率论、量子力学/计算方面开悟，我一定不会像此文一开始那样的敷衍，甚至，朝闻夕死，我也不会太过于拒绝。</p>
<p>Karl Marx 曾言，「以往的哲学家在于解释世界，而问题在于改变世界」。你开悟了，充其量算是自己有了一套解释世界的法门，可是，然后呢？只是为了度化我么？</p>
<p><span id="然后"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">5 然后</a></h2>
<p>面对着那位在佛学方面——不必非得是佛学，其他任何学都行——顿悟了的而且十年后依然和我在一个车间里工作的朋友，我说，「然后呢？」</p>
<p>他将擦拭机床的油乎乎的抹布准确的掷入脏兮兮的装满了各种尺寸的扳手的桶里，将手在蓝色的工作服上擦了几下，淡淡地对我说，「以前讨厌的，现在不以为然了。以前喜欢的，现在也不会为之过于冲动了。」他的那套动作，我也做了一遍。车间里的规章上并没有说可以用工作服擦手。孩子用衣服擦鼻涕的时候，却往往会遭受母亲的批评。成年人似乎对自己实在是太过于放纵了。</p>
<p>新来的年青女质检员，从我们面前窈然走过，非理勿视的部位让我们看得有些出神。</p>
<p>我说，「我们这样出神，真的好么？」</p>
<p>他说，「空不异色，色不异空。」</p>
<p>我说，「两头的话，都让佛祖说了，也难怪藏传佛教会有双修这种奇怪的法门……」</p>
<p>女质检员回头，侧目，嗔怒，「二位……大叔……你们真是够了！」</p>
<p>下班了。我们心安，我们理得，各回各家。吃饭，看电视，帮娃写作业，伺候他和他的母后就寝，然后取出一瓶经常忘记了藏处的二锅头和一盘花生，自斟自饮，期间，或观影，或读书，或聊天……这也许是一切开悟的男人最喜欢的时光了吧。</p>
<p>Karl Marx 说的也不全对。过去的哲学家，并不只是解释世界。佛祖在菩提树下修成正果之后，他是有事业心的。他应该知道，单从心理上获得众生平等的满足感，不可能消除社会的不公而带来的痛苦。他要去度化世人，目的也是要建立一个政治体系，只不过他对政治几乎没什么了解，以至于他建立「政治」体系形同神话。好在，那时信神的人还是很多的，所以，他几乎不用费太大精力，就聚拢了众多信徒。当僧侣成为职业，清规戒律虽然难耐，但佛经可以净化心灵，大家不会饿死，社会从而公平。佛祖的度化，有助于建立佛国。政教不分离的时代，这就是教主们能想出来的改变世界的最和平的办法，直至孕育出「十字军」这样的怪胎。</p>
<p>以宗教立国，维护这个国家的稳定，只有一种手段，即对他们大讲一堆似是而非的话，让他们能够在最低的生活保障下安定地活着。我在九十年代的农村里长大。那时的农村，路近乎不拾遗，夜近乎不闭户。我家穷，父亲在路上捡了人家 6000 块钱，就在路边等失主回寻。家家都有大门，但是白天，大门大都是敞开的。晚上大门虽然是锁的，但那矮矮的围墙，像我这样半大的孩子，跑几步，纵身一跃，就翻过去了。我在这个穷且安定的村子里长大，并不以为我是个愚民，反而心里很有抱负，一想想自己是为天下之崛起而读书，内心也不免会有些小激动。</p>
<p>那时，村里有个浪荡汉，小叫节谈或节谭或节痰。他没读过什么书，不种地，也不去城里务工。所以，村里种地的人不喜欢他，包工头也不喜欢他。父母就把他作为懒汉而且没出息的反面榜样教育我们。他曾经去城市里游历过，也许在路边摊上学会了看手相。给我和一个小伙伴看过手相，说我手相很好，骨骼清奇，将来能出人头地。小伙伴长得比我帅多了，结果他的手相却不好，节谈说他长大后一事无成。不知多少年以后，我的确出人头地了，否则你们看不到我写的这些字。小伙伴的确一事无成，但他哥很厉害，90 年代上海交大学经济的高材生，毕业后娶了同班的本地姑娘，把中国的东西运到非洲去卖，获利颇丰。一事无成的小伙伴，不需要开悟，只需要帮着他兄长花钱就是了。</p>
<p>节谈总是穿得很邋遢，但在村里，只有他一年四季穿着呢子布料的浅灰色风衣——可能以前是纯白色的，带着礼帽，只差一根文明棍。在一个夏天，身着风衣，头戴礼帽的他，捡到了一只也许是吃了几只吃了农药的虫子而死了大概三天的公鸡，便在自己没有院墙和大门的房前，烧水，拔毛，去脏，炖之。因画风过于怪异，惹得我和一干小伙伴嬉皮笑脸地围观。我们觉得这鸡应该不能吃，他说了句村里一个老太太经常说的一句话，「不干不净，吃了没病」。几天之后，我发现他的确没死，依然很邋遢地穿着风衣在村里唯一的一条大街上戴着礼帽行走，我就放心了一些。</p>
<p>现在，我被朋友带得也有些开悟了，便总以为，节谈应该是个隐士。那天，我和一些人说，在路边晒太阳并捉虱子的乞丐，捉到一只，就挤死，卡吧，卡吧……他很快乐。在他捉虱子的时候，有许多我叫不出名字的军政大员被送进了监狱，想必让他们在监狱里晒着太阳捉虱子——现代监狱应该是文明的，晒着太阳看书也行——就未必如乞丐那样快乐了。</p>
<p>鲁迅似乎是把我说的这种快乐精神叫阿 Q 精神。应该没人想做乞丐，但是做了乞丐，能给自己找点乐子，从而心安理得地做乞丐，也没什么不好。那些开悟了的人，不也是这么做的么？倘若鲁迅对于政治也没有什么好的改良之策，只是去骂醒别人，也是很无聊……好在他有不薄的稿费。穷人，也得有个寻开心的法子，倘若骂他们愚蠢，并试图让他们醒悟，自己的处境其实很糟糕……难道他们不知道自己的处境很糟糕么？他们是知道啊，所以才会想出各种各样穷开心的法子，美其名曰，开悟了。从此以后，他们就乐天知命了。</p>
<p>子曰，三十而立，四十不惑。如果一个人在三十岁开悟了，然后在十年里一直想办法让自己穷开心，到了四十岁，的确能不惑。这个不惑，不是对这个世界看得很清楚——儒家对物理世界远不如道家或墨家那样感兴趣——而是不容易被他人蛊惑。蛊惑一个年青人热血沸腾地去搞大事业，是很容易做到的事，但是这个办法对四十岁的人就不灵了。庄子说，这样的人，心几乎快死了，没的救了……是这样的不惑。</p>
<p>宗教的教义，是宗教所立之国的法理及法典。那个国，柏拉图称之为理想国，现在不可能再有了，也或者它从未真的有过。若说有，也不过是以朋友圈的形式出现。我和开悟了的朋友一起欣赏在我们面前走来走去的女质检员，我们就有了三个人构成的充满了轻佻气息的朋友圈或聊天群。失去了国的法典，可以令人开悟，却对生活几乎没有任何影响。但是，即便如此，千百年来，关于谁的教义更好的争论依然层出不穷。不过，这种争论也逐渐沦落，最后成了朋友圈或聊天群里的穷开心，然后呢，都觉得自己开悟了，然后静静地看着没开悟的人，在那里发狠，穷愤怒。</p>
<p>也许八十年代的一句俗语所道出的反而是正途，「学好数理化，走遍天下都不怕」。不过，也许大多数人因为自己的开悟反倒误解了这句话。学好数理化，并不等价于可以不学好语文、历史或政治等科目。有时候，看着那些开悟了的人身不由己地陷入一些非此即彼的坑里，我也很替他们着急，类似于我担心节谈会吃了那只吃了吃了农药的虫子而死的公鸡而死去。</p>
<p><span id="建国"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">6 建国</a></h2>
<p>我的朋友，那位在佛学或任何一种学问上开悟了的朋友，到现在还没有名字。我觉得他会渐渐变成一个主角，应当给他取个名字。</p>
<p>我便翻开《周易》。没错，《周易》是用来算命的书，但实际上它最大的用处是为中国人取名，譬如，介石，中正，润之，百里，克家……若给女孩取名，最好用《诗经》，譬如，屠呦呦，英译 Killing yoyo。不过，用《周易》取名，比《诗经》的好处在于，可以随便掐掐手指头，就能生成一卦。我掐到了巽卦，初六爻曰：「初六，进退，利武人之贞」。就叫他武人贞吧。</p>
<p>那天，武人贞被我问了「然后呢」之后，他思考了很久。没等到他有新的开悟，我们便由于工厂效益不好，下岗了。</p>
<p>为了谋生，我在路边摆了个摊，卖肉夹馍。武人贞在距离我的摊位不远的地方摆了个修车摊，修自行车，至于电动车只提供补胎服务，兼营补鞋、配钥匙。窈然的年青女质检员还和我保持联系，不过，仅止于每天上早班的时候从我这里买一个加了茶叶蛋的馍。饶是如此，武人贞也极为嫉妒，多次声称也要改行卖馍，直到年青女质检员去他那里补过一次车胎为止，又直到那个车胎在一月之内补了又补，直至不得不换新胎为止。</p>
<p>有一天，武人贞在我没怎么有生意的时候，满脸神秘地走了过来，一开口就表现出了他的大智慧，「我们应当成立一个国。」</p>
<p>「锅……还鏊子呢！」我在理着今天收的零钱，但很快就想到，他说的应该不是锅事，便拿了一个没夹肉的馍，郑重地堵住了他的嘴，「本摊禁议国事，城管的事例外。」</p>
<p>「你说无国之经只能令人开悟，却不能对人的生活有什么影响。那么最好的办法就是建国……给我点水喝！」他一边说，一边啃馍。从他啃馍的行为里透露出来的斯文程度来看，他没病。</p>
<p>「现在的世道，还不算太坏。你在街上公然说要建一个国，城管都不搭理你。」</p>
<p>「我本来开悟了，你让我去想然后……然后就是建一个国。」</p>
<p>「有个岛，想独立想得快疯了，我国态度强硬，愣是不让。你这国中之国，几个意思？不想活了吧，你！」</p>
<p>「那换个说法，开个公司。这个合法吧，然后把这个公司视为国。」</p>
<p>「你赢了……先把你的教义搁一边，公司主营什么业务呢？」</p>
<p>「那我倒没考虑。我只是想让我的教义落到实处。至于业务，暂时设为，买你的肉夹馍，可以到我那免费修车。到我那修车的，买你的肉夹馍可以八折优惠。公司的名字就叫吃行合一有限责任公司。」</p>
<p>「听起来，你这是开店，不是开公司。」</p>
<p>「无所谓，只要有个实处，能让我推行教义即可。」</p>
<p>「也行。不过，前提是你要有很多钱。」我应该抓住了他的命门。</p>
<p>「我卖教义总可以吧！」</p>
<p>「好汉，你生不逢时。早生几十年，也许你的名字应该叫庞氏。释迦牟尼在菩提树下顿悟之后，他的大法，首先是说给亲戚朋友听的，尤如你现在企图说服我开公司……你的教义，真的会比已经淬炼了上千年的佛法更好么？再说了，你本来不就是修的佛法么？在佛祖面前，你这三脚猫的大法，真的好意思称自己为佛么？」</p>
<p>武人贞欲言又止，之后就只有丧气了。不过，他的修车摊上来了一桩生意，让他的脸色略微变得好了一些。</p>
<p>武人贞没能和我建成一个国。不过，我却觉得他很勇敢。国，哪有那么好建？不过，若是有好的教义，必定是能建国的，并且所建之国必然能够逐渐强大起来。不过，这样的国，若不想被现有的国消灭，现在就只能叫公司。等武人贞下次再来跟我吹牛的时候，我会建议他在经济学上有所开悟。也许在有国之经上能够有所开悟，方是真的开悟。</p>
<p>我没有建国的大志，摆了这个肉夹馍的摊子，想必也只能是读读《庄子》了，但愿它能让我游刃有余地对付城管，且能和邻摊之间搞好关系。这样看来，《庄子》是有摊之经。</p>
<p>不过，近年来，有人在网络上建了一个国，叫区块链，传教者甚多，教徒名曰韭菜，遍布四海。究其教义，无非人与人之间的信任远不如建设在电力系统之上的加密算法而已。不过，他们的传教却要借助他人的信任，也是够悖论的了。</p>
<p><span id="经济学里有仁义么？"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">7 经济学里有仁义么？</a></h2>
<p>武人贞：经济学里有仁义么？</p>
<p>我：有的不止仁义，也不止经济学里有。理工农医，诸学科中皆有。</p>
<p>武人贞：你诳我吧，虽然我学历不高，但数理化，还是学过一点的，里面连仁义这两俩字都没有的。</p>
<p>我：这些学科，把学问做进去了的人，大都是有仁义的人。你应该听说过一些有名的科学家的事迹吧？与现在还企图从经史子集里寻找仁义的人相比，谁更仁义？</p>
<p>武人贞：你这口气，像是一个反历史主义者。我们的五千年文明的沉淀，在你这里就成了废纸一堆？</p>
<p>我：若你的工作是古代文献的研究和梳理工作，或者你是教授古文的老师，它们当然不是废纸，而是宝藏。但是，若你认为那里面有修身、齐家、治国、平天下的良方，那就真的是执迷不悟了。</p>
<p>武人贞：不知古，焉知今？</p>
<p>我：若知了古，就能清晰地看清现代天下的形式，那么那些历史学家岂不是比你更有资格看清这些？退一步说，若知古可以通今，陶渊明学富不知多少车，依然会说，实迷途其未远，觉今是而昨非。</p>
<p>武人贞：想必是他们没天分吧？守着宝藏，却不会花钱。</p>
<p>我：但凡觉得自己比别人更有天分的时候，应当警惕自己是否陷入了执迷不悟的境地。井底之蛙也会觉得自己很有天分。历史学里有仁义，历史则是证明了经史子集的不靠谱。</p>
<p>武人贞：历史与历史学，还有什么区别吗？那些历史学家不是因为喜欢历史而成为历史学家的吗？</p>
<p>我：山东的蓝翔技校，不止可以传授挖掘机技术，也传授烹饪技术。世人很少有人拒绝好吃的饭菜，学烹饪的人却总是不多。事实上，厨艺里都是有仁义的，听说过庖丁解牛的故事吧？</p>
<p>武人贞：既然历史学里有仁义，那你为何反历史主义？</p>
<p>我：主义，差不多不是什么好东西，总是要保持反对的态度。世人就是这么奇怪，但凡是与自己身家性命相关的道理，就冠以主义。Marxism，Leninism，历史主义，科学主义……你听说过肉夹馍主义，修自行车主义，与女质检员调情主义么？</p>
<p>武人贞：那倒没有。但是我觉得你陷入了胡说八道主义。</p>
<p>我：主义，也许是那些没主意的人吹嘘出来的。喜欢历史，就自然会吹嘘出来读史可以明智，可以通今之类的鬼话。</p>
<p>武人贞：我被你拉进了一个不得不听你废话连篇的圈套里了。不过，读史可以明智，可以通今，这都是名人说的。你认为他们说的是鬼话，这难道不是你执迷不悟么？</p>
<p>我：读历史……读经史子集，若真能读出仁义，读出治国的良方出来，那么自秦以后，就不该有那么多的王朝兴替，就不该让那么多无辜的平民遭受战火。也许你读的是经史子集贯穿时光的辉煌，我读的却是它的虚妄。</p>
<p>武人贞：唉，像你这样的人，活得不幸福。据我所知，其实你也没读过几本经史子集。</p>
<p>我：为了黑而黑。但是我说了，有志于做经史子集研究或教授古文的人，是要去读的。当然，你也可以从里面读出仁义。但那仁义，也是失了国的，顶多让你有所开悟，却对你的生活几乎没有影响。</p>
<p>武人贞：做人难道不要讲仁义么？譬如，四书五经里所说的，难道不是我们日常要遵守的行为么？古为今用，不是很好么？</p>
<p>我：没睡觉，你就说梦话。学者们还在为经史子集里的某些字句的释义争执不休呢，民众却以为四书五经里包含了人生的至理。古若能为今用，腐朽的柱子就能拿来建宫殿。人生的至理即便是有，现在也是有许多比经史子集更好的读物。</p>
<p>武人贞：What？</p>
<p>我：经济学。虽然经济学研究的是人类在经济方面的活动，但是这种研究首先要对人性给出假设。譬如，有的经济学，是以假设人性以自私为本，有的经济学则是假设人性以无私为本。这样的假设，古人也做过。孟子主张人性本善，荀子则主张人性本恶，然后他们以此为出发点，演绎出来一套如何做人的道理。但是，现在是讲经济的社会，在这样的社会里如何做人，这就不是孟子和荀子的课题了，而是现代经济学家的课题。换言之，现在去读《孟子》，就远不如去读《资本论》。</p>
<p>武人贞：难道经史子集真的一无是处么？我不想反驳你，但是我觉得既然它们能流传下来，就说明它们并非一无是处，一定有它们的道理。</p>
<p>我：《老子》和《庄子》可以例外，它阐述的是个人争取自由的理论和方法，可惜的是，它们并不好读，自以为读通了，实际上还是一脑子浆糊的人太多了。世人一直被灌输着要以天下为己任，到今天依然如此。所以，个人如何求得自由，这个课题依然是新的。至于其他的书，只要与这个课题相关，也会有其是处。但凡劝人以天下为己任的书，就比不上现代经济学的典籍了。</p>
<p>武人贞：好吧。那么你懂经济学么？</p>
<p>我：不懂。所以，只好在这里摆摊，跟你空扯。</p>
<p>武人贞：空谈无益，喝酒去……AA。</p>
<p>武人贞虽然总是爱开悟，却是个不错的的可下酒之人。若身边总是有一大群人，希望从大讲特讲经史子集之徒那里寻求人生至理，那就远不及喝酒痛快。至少喝酒可以领略到一些圣贤独有的寂寞，而那寂寞不过是因为失了「国」，或许他们的「国」自秦一统后，便失去了。我总以为，我们的历史，从秦朝就搞辛亥革命，也能接得上茬。</p>
<p><span id="无趣的人"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">8 无趣的人</a></h2>
<p>我不怎么看新闻，以致有些名人死了好多天，我才知道他们死了。今年，金庸死了，李咏死了，这些是众所周知的事，不少人写文缅怀他们。上个月，中科院院士陈创天死了，知道的人可能就很少了。和你一样，我也是刚知道，而且是毫无感觉的那种知道，因为此前没听说过这个人。</p>
<p>我和很多愤愤不平的人一样，有着为科学家名不平的冲动。不过想了想，自己从未读完过几乎任何一个科学家的著作，反而是金庸的十四本著作让我从小到大翻了五六遍，于是，那个冲动很快就衰退了。结果就是，既不缅怀金庸，也不缅怀陈创天，我觉得这是我作为晚辈能给他们的最好的纪念了，不厚此，不薄彼。</p>
<p>为科学家们名不平的人，他们设立的道德底线有问题。金庸是写书的，是个文人，但他写的是武侠小说，属于通俗文学，大致可以把他划到娱乐圈的范围里。若不同意这一点，那么赵本山也是艺术家，二人转表演艺术家，郭德纲是相声表演艺术家，把他们划到娱乐圈，总没问题了吧，但他们能这样划，金庸也能。娱乐圈里的人，他们的事业就是博得世俗众人的打赏和喝彩，有钱的捧个钱场，没钱的捧个人场，自古以来都是这样。科学家不一样，科学家的事业是博得同行们对自己的研究成果的肯定。要知道，每届人大会议，需要几千个世俗的人方能开得起来，而物理学界的顶级学术会议，只需要十多个物理学家就足够了。不同的圈子，不能用同样的标准去衡量谁的贡献大，谁更应该获得世人的赞誉。</p>
<p>我知道崔永元，但不知道卢大儒。他们在一个电视节目里关于转基因作物的事情有过一次激烈的辩论吧。我没看这场辩论，因为我是三年后才知道这件事。从网络上的一些人的描述来看，应该是崔永元赢了。这是正常的，卢大儒说相声，说不过郭德纲，写小说也写不过金庸，做访谈节目，自然比不上专业出身的崔永元。</p>
<p>世俗的胜利，不表示世俗赢了科学。不过，世俗之人有拒绝转基因作物的权利。所以，卢大儒若想击败崔永元，就需要得拿出一些时间来，像金庸、赵本山、郭德纲等人那样去做一些事……若是相貌生的美，也不妨放下身段，以色相吸引世人步入科学圣殿。既然有美女能用身体去写作，为何不能有美女用身体搞科学。佛教徒们为了传教，也是需要搞出佛祖舍身饲虎这种科普出来的。倘若做不到这些，就不能怪世俗之人愚昧无知。由于没有科学家能做到这些，所以，就让崔永元赢，不必为之气恼。</p>
<p>若不动刀兵而博得世人的喜欢，唯一的办法就是做一个有趣的人，要么就是做个美女。娱乐圈的存在已经揭示了这个道理。我需要感谢娱乐圈，否则我会一直闹不明白，为什么墨子拯救了宋国，而宋国的城管却不认识他，并将其拒于城门之外。我想，那个城管应当是知道城内最有名的一家妓院里的头牌今夜会被谁承包了的事。当然，这个道理实在是太浅了，这是每个人都知道的道理。</p>
<p>不过，真正的道理往往隐含在浅薄的道理之后。世人之所以喜欢有趣的人，之所以喜欢美女，无非是因为他们既无趣又丑。有趣的人不会喜欢无趣的人，比无趣还无趣的人则会喜欢无趣的人，所以，也许只有无趣到了孟子的地步，才会觉得民众是高贵的，而有着良好的教育和基因传承的君主是卑贱的。不过，夸夸人民的眼睛是雪亮的，至少不会招人民讨厌。科学家也会觉得自己的事业是为人民谋福祉，是神圣的，值得付出自己毕生的心血。这样的科学家就和孟子一样无趣了，在这一点上，他们和世俗之人并无不同，只是在审美上，他们会觉得数学公式像相声、二人转那样优美，而麦克思韦方程则比范冰冰好看。</p>
<p>事实上也的确是这样，我之所以从未读完过哪个科学家的专著，唯一的理由是，它们实在是太无趣了，除非有人要拿它们出考试题……所以，整个教育界，我都觉得很无趣。像《费曼物理学讲义》这样的物理学教材，写得稍微有趣一些，就导致我大学毕业之后才听说有这么一套书。</p>
<p>从今天起，我要努力做一个有趣的人，因为还没攒够把自己变成美女的钱。</p>
<p><span id="令人讨厌的人"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">9 令人讨厌的人</a></h2>
<p>一个人若是无趣，并不糟糕，因为 99.9999% 的人都是无趣的。我的数字可能不准，但是计较这个数字准确性的人，必定是无趣的。糟糕的是这个人的无趣达到了令人讨厌的程度。但愿我的朋友们，假设他们的确存在，那么在不小心看了这个开头之后，不要对号入座。</p>
<p>对于自己不熟悉的人，他是有趣的人，还是无趣的人，有时难以判别。但是，倘若发现有人讨厌他，那么就可以确定了，这个人是无趣的人……再强调一下，「无趣」在我这里是中性词，又因为「道可道，非恒道」，所以它也很有可能是个褒义词。</p>
<p>总担心自己这样下去，到最后会一个朋友都没有。孔子说，无友不如己者。最后，我就只能和自己做朋友了。可是，世人没有和自己做朋友这样的主张，只有类似「做自己的主人」这样的主张。我怀疑，这样的主张太过于流行，从而导致令人讨厌的人越来越多。试想，一个人若是做成了自己的主人，岂不是把自己活生生地踩在了脚下，沦落为奴才？</p>
<p>一个人若是出现了两种性格，主子性格和奴才性格，那么他在这个社会里与他人合作围猎的时候，若是不慎用错了性格，可能就会令人讨厌。譬如，在别人正在使用主子性格的时候，他也不小心使用了主子性格，必定会让前者很不开心……山无二虎，国无二主，反过来也是一样的，奴才之间也总是相互倾轧的。正确的用法应该是，要看准与自己合作的人使用的是哪种性格，若他正在使用奴才性格，那么你就得用主子性格，反之，他若使用主子性格，你就得用奴才性格，惟有如此，围猎工作方能稳定的进行下去。然而人心竟是如此的难测，我怎么知道对方此刻是主子，还是奴才？</p>
<p>细想之下，我应当也是时常令人讨厌的。特别是，别人已经不耐烦再听我说下去的时候，我依然坚持说说说，而且我心里还在暗想，你以为老子是这么想说话吗，我不过是为了你好罢了。那个时候，也许我无意中动用了主子性格。我差不多可以确定，我既不喜欢当主子，也不喜欢当奴才，因此含有 SM 情节的文艺作品或者清廷的后宫剧，我都不具备欣赏能力。这样下去，最后也许主子们和奴才们都会讨厌我，此时，我该怎么办？大概至多也就是像孔子那样感慨，无友不如己者。</p>
<p>因此，我觉得我能做到的是，只和自己做朋友。这样，也许会导致我没朋友，但是至少不会令人讨厌。对于我要成为有趣的人这一伟大的理想而言，和自己做朋友，算是向着这个理想前进了一小步吧？更何况，一个人即使不和你做朋友，这实在没什么大不了的，世上竟然有 99.9999% 的人和你不是朋友。</p>
<p><span id="有趣的人"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">10 有趣的人</a></h2>
<p>至今为止，我在生活中，没遇到过有趣的人。不过，这只是属于现在的断言。以后也可能有一天，我以足够的无趣体会到了他们的有趣之处。</p>
<p>现在，若想寻找有趣的人，我只有靠读书。读书也存在着我生活中那样的问题。大多数书，我觉得无趣，但是我不会否认以后可能有一天，我以足够的无趣体会到它们的有趣。若是读书，都找不到有趣的人，我还能去哪里寻找。总不可能这世上不存在有趣的人吧。这也不好说，也许有趣的人如同上帝那样存在，大家都以为存在，但是又看不到，连他的影子都看不到。</p>
<p>读笑话，看小品，听相声，难道找不到有趣吗？找不到。那片刻的欢愉，远远称不上有趣，否则上帝就成了川剧变脸王。再说了，写笑话的人，演小品的人，说相声的人，他们真的是将自己的工作视为有趣吗？他们和我们一样，并不总是觉得工作是有趣的，甚至觉得无趣的时间远大于觉得有趣。糖是甜的，永恒的，泪是咸的，永恒的，直至我的味觉系统出现了故障。有趣也应当如此，永恒的，至少在我的有生之年，能一直都觉得有趣，即使我的脸上不会为它绽放笑意。</p>
<p>想必是我感知有趣的器官出现了问题，或者它一直尚未被激活，假如存在这样的器官。当我写到这里的这里的时候，它似乎被开启了，因为我忽然觉得老子的有趣。或许这是因为我弄明白了无趣。</p>
<p>按照司马迁的说法，无所谓真假，若没有人能证明他说的是真的，自然也就没人能证明他说的是假的……按照司马迁的说法，老子是周朝时的皇家图书馆馆长或馆员，孔子那时还近乎是个乡巴佬，慕名去拜访过他。孔子回家后，对徒弟们说，老子这个人，他的思想啊，矫若游龙，翩若浮云。于是，高能之处就来了。孔子的生平，我们是知道的，甚至还知道他是他爸妈野合的成果……孔子的家谱，传承至今，孔庆东是他的后裔。但是，老子的家谱呢？名气比孔子大，思想比孔子深邃，还是国家公务员，但是司马迁连老子这个人是否真的存在都无法切实地考证出来。这样的人，古希腊也有一位，叫苏格拉底。苏格拉底是否存在，也无法考证，他的存在感，是他的学生柏拉图刷出来的。现代人，可以很清楚柏拉图的生平，但苏格拉底本人的生平却不可考。</p>
<p>我心里出现了一个声音。这个声音说，想必是因为他们对社会的贡献不如他们的徒弟。高能之处又出现了，老师的学问比徒弟高明多了，徒弟的贡献反而比他们大，这是否说明社会并不尊重更好的学问呢？</p>
<p>老子发现周室势微，各诸侯国觊觎九鼎，感觉天下要大乱了，决定出关，去不会受战乱纷扰的偏僻之地定居。孔子虽然说，危墙不立，乱邦不入，但是他却坚持不出关，而那时，中原何处不是乱邦？日本人侵华期间，住在北平，天津，上海等地的聪明人，想到要出关避乱的人也许不少，但付诸行动的有多少呢？现在，想想圣人和聪明的人民这种嘴上说着一套但身子从来都是不肯动弹一下的样子，也渐渐有趣了起来，他们开启了用嘴巴投票的时代。</p>
<p>老子到了函谷关。城管是个文化人，听说过老子的大名，极为仰慕，就强行把老子留下来，让他把自己毕生所得写一写，为祖国的文化建设做点贡献。孔子就没这种待遇，只好像丧家之犬那般地周游列国。假设要出关的是孔子……算了，我差不多明白孔子为何不出关了。</p>
<p>城管把老子强行留了几天，让他写书。可是，这老小子好好写书了吗？翻开《老子》，又名《道德经》，看看他写得都是啥吧，一上来就是，道可道也，非恒道也……《论语》呢，一上来就是，学而时习之，不亦悦乎？差距一目了然。孔子很像我的小学老师，教我们念黑板上的八个大字，好好学习，天天向上！而老子呢，道可道，非恒道也……大宗师的风范。</p>
<p>爱因斯坦，物理学界的宗师。他说过一句话，「我的精神生活和物质生活都是以别人的劳动为基础的，我必须尽力以同样的分量来报偿我所获得的和至今仍在接受的东西」。这样的话，刘少奇对掏粪工时传祥也说过，都是为人民服务，只是分工不同。但是，无论爱因斯坦，还是刘少奇，都很无趣。老子就有趣多了，因为「道可道，非恒道」的潜在意思是，我的学问虽然大，但是我说的未必对。</p>
<p>若是理解了《老子》第一句话的有趣之处，他说的每句话就都有趣了，因为你不能把他后面说的话当成真理。今天我在看刀尔登的《中国好人》，刀尔登终于幽了老子一默：「但凡写进《老子》的，那肯定是做不到的事。」老子的趣处，两千年后，终于有人发现了，而发现不了的人，有反对老子的人，也有认真研读老子的人。</p>
<p>不妨作这样的假设，在《老子》一书中，只有「道可道，非恒道」这句话是真话，后面的所有内容皆为老子信马由缰，一通乱侃。这个假设是不是很符合老子急于出关隐居而搪塞一番的做法？这个玩笑开得这么大，以致于两千多年里，让这么多人陷入这个玩笑里，也许是老子始料不及的。或许，他没想到，竟然两千多年也没出多少有趣之人。大家近乎一致地这样一本正经，一本正经，一本正经……</p>
<p>也许老子是因为平时就喜欢一本正经地和别人开玩笑，以致于大家不清楚他那句话是真话了。苏格拉底也有类似的毛病，喜欢在街上随便拉过来一个雅典市民，跟他一本正经地开着很有道理的玩笑，搞得市民哭笑不得。所以，他们的生平就不好考证了。</p>
<p>在几天之前，我还是持着《老子》所表达的意图是，老子希望后人能像他那样去思考，而不要在意他的那些结论。现在，我终于有趣了一些，觉得应当把《老子》一书视为一个有趣的人的胡言乱语之书。我想做一个有趣的人，所以，我写的这篇文章，不妨也这样去看，看不懂，要比看懂了好。老子修道德而得有趣，后人修老子而得无趣。令人有趣的东西，是道德。道，令我觉得自己有趣。德，令别人觉得我有趣。</p>
<p>所以，《老子》这本书若想看得有趣一些，不妨这样去读「道可道，非恒道」之后的大多数句子，譬如，「信言不美，美言不信。知者不博，博者不知」，不妨读成「因为『道可道，非恒道』，所以『信言不美，美言不信。知者不博，博者不知』」。《老子》的第一章是在解释为什么「道可道，非恒道」，其他之后的各章，不过是从「道可道也，非恒道也」这个前提（公理）推导出来的一组命题。你若觉得那些命题说的都是真理，这就会与「道可道也，非恒道也」发生矛盾。如果你觉得那些命题都是胡扯，那就证明了「道可道也，非恒道也」的正确。像这样的「玩笑」，西方人一直开到了哥德尔不完备性定理的出现以及维特根斯坦的出现。</p>
<p>庄子之学，一直都是被视为师承老子。若说老子体现的是哲学家之有趣，那庄子所体现的是文学家之有趣。庄子和惠子站在桥上，看水里的游鱼。庄子说，这些鱼好高兴啊。惠子，不是日本美女，而是中国古代无趣的爱抬杠的男人……他问，你从哪知道这些鱼好高兴的？庄子说，从桥上。</p>
<p>庄子的那些寓言，可曾有一个是正经的？他一本正经的写寓言，寓言里的人却总是很不正经。《论语》里，孔子的徒弟问孔子问题，孔子从来都是很有耐心也很有道理的回答。但是，在庄子的寓言里，啮缺问王倪，王倪则是三问三不知。可是正当你打算嘲笑王倪这么愚蠢的时候，他却又咕噜咕噜说了一些令你却难以反驳的话。</p>
<p>尧想动用武力征服一个小国，但是又觉得不好意思。尧这么搞，就很有趣。若是察觉不到，那是缺乏参照物，不妨拿唐太宗讨伐高句丽，美国总统小布什讨伐伊拉克作为参照，他们就不会有尧这般的不好意思。舜也很有趣，对尧说，你没听说过后羿射日的故事吗？人的德行，比太阳的光还要令人受不了。这是庄子的另一个寓言，无趣的人，他的解释和我的是不同的，在他们那里，尧是不可以黑的，舜也不可以黑，因此在寓言里，这爷俩很正能量地讨论了一番要不要讨伐一个小国。尧是为了让这个小国得到文明的洗礼而不得不动用武力讨伐，而舜呢，则是劝尧不要这么干，要继续提升道德水平，像十个太阳那样让小国主动宾服，前来朝拜。我见过的几乎所有解读《庄子》的大家，都是类似这般的解释。</p>
<p>以孔子为师的儒家，对死人崇尚厚葬。以墨子为祖师的墨家，则反对厚葬。儒墨都无趣。庄子本人死了之后，是厚葬的，但也是薄葬的。以天地为棺材，这是最大的厚葬，但也是最大的薄葬。这样的棺材，无趣的人，也许反复死十次也想不出来。从这个角度上来看，《庄子》这本书，一大作用是，可以让那些自以为觉得读懂了《老子》的无趣之人再次陷入一个莫大的玩笑里，当然这并非出于庄子的本意，而是所有无趣之人遇到有趣之人之后必然要落入的一个陷阱，而这个陷阱其实是前者自己为自己挖下的。</p>
<p>自庄子之后，东方朔是有趣的人，只是他的有趣就令人提心吊胆了，因为他伴的是刘彻的大驾，而刘彻是嬴政之后的第一大无趣之人。司马迁企图与刘彻抢夺这第一的称号，被阉割了，之后才变得有趣一些。自东方朔之后，金圣叹是半个无趣之人，他和地方官员争着比无趣，结果死了。</p>
<p>之后，我就不知道中国还有有趣的人。我对历史知道的少，所以……没什么所以，有趣的人不会在意我不小心把他们给忽略了。</p>
<p><span id="欧姆定律"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">11 欧姆定律</a></h2>
<p>人类对电子的运动规律一无所知的时候，就有欧姆定律了，即流过导体的电流与导体的电压成正比，与导体的电阻成反比，即</p>
<p>$$
U=I\times R
$$</p>
<p>这个公式不仅可以在寻常的电路上成立，在自来水管道、供暖管道、天然气管道、通信通道、交通通道之类的线路上往往也能大致成立。因为它描述的是一种简单的逻辑，基于乘法原理实现了三个变量的统一。庄子若看了欧姆定律，或许会赞曰，夫欧姆定律者，通而为一也。</p>
<p>若将这个公式放到经济学中会怎么样呢？我不懂经济学，所以不知道有没有这样的经济学公式……不管有没有，权当是民科级别的公式：</p>
<p>$$
\text{生产关系}=\text{生产力}\times\text{人性的开放程度}
$$</p>
<p>或者</p>
<p>$$
\text{社会制度}=\text{谋生技能}\times\text{人性的开放程度}
$$</p>
<p>在这样的公式里，不存在人性本善还是本恶之类的假设，也不存在生产力决定了生产关系而生产关系又反过来影响生产力的发展之类的辩证法。假如各种经济学理论的创建者及其拥趸能够保持像欧姆那样无知的心态，以欧姆定律的形式去统一这些变量，而不是强行假设，强行辩证，也许经济学里就不会乱入一些哲学、政治甚至道德方面的争论。</p>
<p>若用 h 表示人性的开放程度，其取值范围限定为 [0, 1]，0 表示利己，1 表示利他，那么当 h 分别为 0 和 1 时 ，由上述公式演绎出来的东西分别可能就是《国富论》和《资本论》。那么，若 h 介于 0 和 1 之间呢？若 h 的每个不同的取值都导致一种不同的经济学理论的出现，一定会把学习经济学的人搞疯了。还有一种情况，就是 h 根本无法确定，而是类似电子那样的无规律的运动呢？难道存在一种薛定谔的猫那样的经济学么？</p>
<p>在这样的公式里，三个变量都是未知数，但是它们的关系却是确定的。基于这种确定的关系，我们唯一能做的似乎就是，获得其中两个变量的值，从而确定第三个变量的值。譬如，倘若我们能够对生产关系予以量化，也能对生产关系予以量化，那么就可以确定我们的人性的开放程度的值。</p>
<p>事实上，这个公式可以从定性的角度来看。若生产关系千年不变，生产力在理论上应当是不断发展的你昨天会制造第一台计算机，那么今天应该能制造出更快的第二台计算机，在这种情况下，人性的开放程度必然会向利己的方向衰减。通过我们各代地主绅士们所创建的文明就可以看出来，春秋时的大义，到了明清，就是一堆堆空洞不堪的口号了。其实，口号这种东西，也许是人类文明发展的必然产物。各国人民都会喊的，不过不乏有老实人依然有所践行。</p>
<p>不过，我们的历史，真实的情况是，生产力并非不断发展，它大致处于时进时退的状态。基本上，每一次改朝换代，都会造成生产力的短期衰退。家贫知孝子，国乱识忠臣，恰恰是在这样的时间节点上，人性的开放程度会被提升……不开放又能怎样呢，大家都是等待屠戮的羔羊，惺惺相惜，为了能够活下去，只能靠精神上的自我激励。于是，我们现在看到的结果就是，君主专制形式的生产关系一直能够得以续命，甚至一续千年。至今，我们依然习惯这样的关系。江山易改，习惯难移。不止我们如此，看看好莱坞的影片，不难发现美国人也有这样的习惯。我们在心里可以推翻一个主子，手段无非是给自己找到一个新的主子。</p>
<p>在这样的公式里，也能看到，官员的贪腐是盛世的必然结果。因为生产关系不变，生产力发展，从而导致人性的开放程度衰退。若一个平民在路上捡到了 100 元钱而揣入自己的钱包我有过这样的操作，若扶了老人过马路反被敲诈，在这样的时代，着实不能去埋怨官员的贪腐。</p>
<p>窃钩者诛，窃国者为诸侯。窃钩者如此倒霉，是因为他偷的是窃国者的钩。若因此而觉得窃钩者可怜，窃国者可耻，则徒为以一步笑万步罢了。阿 Q 摸了一个尼姑的头之后，必然会说，和尚都摸过你的全身，我连头也摸不得？</p>
<p>若人性的开放程度的衰减速度超过了生产力的发展速度，生产关系就不可能维持不变，它会趋于衰减，即趋于瓦解。在这种情况下，反贪，只能延缓生产关系趋向于瓦解的进程，如同人患了癌症，现有的治疗方案，只能延缓癌细胞的扩散速度。也许更好的做法是，更新生产关系，用新的政治结构去提升人性的开放程度。</p>
<p>若新的政治结构导致人性的开放程度的提升速度超过了生产力的发展速度呢？结果只有一个，快速步入了共产主义，人皆为圣贤，即使每天都更换新的政治结构，想必圣贤们也不会反对。在这种情况下，圣贤们要考虑的问题可能就会变成，如何保持生产力的稳定以现代的视角来看，就是能源问题。若生产力不稳反衰，圣贤们就只好主动或被逼迫进化成神仙的境界方能保持生产关系的稳定，那时人类也许会发展出一门新的学问，修仙学。</p>
<p>人成了仙，生产力衰减至刀耕火种的状态可能都是无所谓的吧。亦即，我们坦然地过回了原始人的生活状态，与后者的区别是，我们是在一个消灭了洪水和猛兽的世界里采摘，耕种，渔猎，每天都像现代人度假那样悠闲，原本是谋生的活动，现在变成了身体的有氧运动锻炼方式。后来，有个外星人乱入了进来，他叫陶渊明。</p>
<p>真相，绝不应该这样美好。上述的论点，是放在了一个封闭的理想化的系统中的。在这样的系统中，我们的一切活动，都是在克服系统的熵增。但是，无论是古人还是今人，屡试不爽的一个法子是，入侵其他系统。草原上的草长的不好了，把中原变成牧场就是这样的办法。自家的经济不好了，就想办法让别人家的经济变得更差。说白了，就是将自己内部的混乱转嫁到别人身上，乾坤大挪移，这个功夫，名头很大，但可能是每个人都极擅长的寻常本事，即推卸责任。</p>
<p>我知道自己有些事做的很烂，甚至很黑，但是为了维护自己的良心，只需要找一个人过来，让他比自己更烂更黑就可以了。由于这个方法简单易行，很容易让自己变成幸福的人，成功的人，可以藐视天下群雄的人，而且一旦获得了成功，还能用欧姆定律那样的公式，完美地将自己的真实做法掩盖起来。仁义道德之理不妨堂然皇之地讲，男盗女娼之事不妨直接间接地做。最后，我成功了……只有我成功了么，你没成功过么？倘若有人不齿这样的男盗女娼，我就要奇怪这么多年你是怎么活下来的了，也要奇怪学历文凭是怎么来的了。不要自责，反正最后我们成功了。</p>
<p>之后，那些不成功的人，不幸福的人，就认为那个公式有问题，甚至认为是提出公式的人害了他们，这就是另一种形式的推卸责任了。</p>
<p><span id="没有问题"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">12 没有问题</a></h2>
<p>如果我没有问题，那么，我所说的一切，定无意义。</p>
<p>水是绿的，山是青的，天是蓝的，风是寂寞的，我在这里等你，却担心你来……如果我没有问题，我为什么想要说这些？凡我想说的，其背后必然有问题，而我所说的一切，或描述问题本身，或描述问题的解决方法，或描述问题的结果。</p>
<p>凡不可言说的，必保持沉默。维特根斯坦说了这句话，意味着他遇到了不可言说的问题。不过，他依然以言说的方式说出了这个问题。至于这个问题的具体面目，他不清楚，否则问题就成了可言说的问题了。</p>
<p>没有问题，我不再说话，此时，我做什么呢？什么都不做么？吃饭，睡觉，看书……在我觉得没有问题的时候，我依然在做这些活动。若我没有问题，我做这么干什么呢？于是，问题就出现了。若我回答，为了活下去，一旦这样回答，新的问题便出现了，什么是活着？为什么要活着？怎样活着？怎样更好地活着？活着与死去，有何区别？</p>
<p>这些新的问题，无论我去回答哪一个，从我给出的答案里又可以陆续派生出新的问题，如此下去，永无止境。事实上，即使不理睬这些问题，我依然能够心安理得，吃饭，睡觉，看书……这说明，这些问题是多余的。</p>
<p>在没有问题的时候，我的生命还在继续，我还在为了维持它的继续而做一些事情，这似乎意味着我并非真的没有问题。但是，为了避免出现无穷无尽的问题，最好的办法是设立一个不会产生新问题的问题。这个问题可以称为没有问题。</p>
<p>武人贞问我，「你现在没问题吗？」</p>
<p>「没有问题。」</p>
<p>武人贞又问，「你现在有问题吗？」</p>
<p>「没有问题。」</p>
<p>武人贞觉得我太无聊了，就去问维特根斯坦，「既然你说，凡不可言说的，必保持沉默，那么什么东西是不可言说的？」</p>
<p>维特根斯坦说，「不可言说的是不可言说的。」</p>
<p>武人贞问，「你还是说了。」</p>
<p>维特根斯坦说，「当我没说。」</p>
<p>武人贞说，「好吧，那么你写的书，我也只能当作什么都没写。」</p>
<p>发现了没有问题的我决定替维老师解围，「维老师的书是可以看的，但是需要以看不懂的方式去看。」</p>
<p>武人贞不耐烦地看看我，「那你说说，什么问题是不可言说的？」</p>
<p>「没有问题是不可言说的。」</p>
<p>「如何解决没有问题？」</p>
<p>「以不解决的方法解决。」</p>
<p>「无聊。」</p>
<p>「对。」</p>
<p>之后，武人贞就消失了。如同没有问题也能写一篇文章，这是我始料未及的。他本来有可能成为我要写的一部长篇不知是什么题材的书里的主角的，但此刻算是英年早逝。我会记住他的名字，来自于我从《周易》里随便为他卜来的巽卦初六爻，「进退，利武人之贞」。</p>
<p><span id="苍蝇"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">13 苍蝇</a></h2>
<p>以前，这块土地上有许多个国。这块土地的名字叫天下，国就叫国。赢政消灭了其他的国，这块土地上就只有一个国了。之后，基本上一直是一个国。天下只有一个国，这个国就是天下。</p>
<p>在我们看来，这种认识似乎并没有什么问题，但是当初类似的一个问题却让数学家们险些集体跳崖自杀，这个问题即罗素悖论。若想把这个问题说清楚，比较一般的数学家们不得不动用令人讨厌的数学符号。但是，把数学问题说清楚，应该是面向数学家。对于非数学家，不一定非要把问题说得很清楚，如同画家在写生的时候，不必把所有的东西都画出来，否则为什么不用相机呢？</p>
<p>罗素不是一般的数学家，因为，他还有哲学家、逻辑学家、文学家等等谥号。也许他经常去理发，并且认为人的头发长了必须要理一下，所以就把他的那个悖论改成了一个理发师的故事。这个故事很短，就是一个村庄里有一个理发师，他说，「我只给那些不给自己理发的人理发」。问：谁给这个理发师理发呢？</p>
<p>我不爱理发，又崇拜力量，所以我把故事改成大力士版本。从前有个大力士，他说，我能举起世上所有不超过 300 公斤的东西。问：大力士能举起自己吗？中国的古人也许太习惯于战争，所以，类似的这样的故事早就有了，譬如，问：以子之矛，攻子之盾，如何？</p>
<p>有时想想，大家经常被一些小学生级别的问题难倒，着实令人丧气。集合论是所有数学的基础，所以，罗素悖论险些让数学家们险些集体跳崖自杀。好在，没人跳崖，连跳楼的都没有。做人，务必像数学家们这样看开一些才好……话不要说得太满。所以，理发师改口，说「我只给那些除了我之外的不给自己理发的人理发」。大力士改口，「我能举起除了我之外的世上所有不超过 300 公斤的东西」。矛盾论者改口，「我的矛是最锐利的，只要你不用我的盾去挡；我的盾是最坚固的，只要你不用我的矛来刺」。</p>
<p>现在，我要用一点集合论了，虽然我一直也没看懂它的那个 ZFC 公理系统。我用一个集合 \(\{X_1,X_2,\cdots,X_n\}\) 表示天下，其中 \(X_i\) 表示各个国。假设有个 \(X_q\) 国消灭了其他国，天下就变成了 \(\{X_q\}\)。问：\(\{X_q\} = X_q\)  吗？虽然我不知道怎么回答这样的问题，但是我可以确定，若以「对」或「错」作为答案，这些答案都是对的，也都是错的。在物理学里，有类似的问题，即：电子，是波，还是粒子？这个问题，也是没答案，因为若以「是」或「不是」作为答案，这些答案都是对的，但也都是错的。</p>
<p>在这些没有答案的问题面前，人类比一只不断撞向玻璃的苍蝇好不到哪里去的。世界是窗外的心向往之的风光，还是屋内安置若素的日常？人是善的，还是恶的？爱情是审美，还是性欲？友情是平淡如水，还是甘若可乐？人生是譬如朝露，去日苦多，还是老骥伏枥，志在千里？大智若愚，大愚若智，究竟是愚还是智？是撞碎玻璃，去探索更为广阔的世界，还是为了保护脑袋，干脆对窗外无限的风光视而不见，对这道玻璃感而不觉，心安理得过着日复一日的小生活？</p>
<p>这些，我不知道。我只知道，只要我打开了窗户，苍蝇就可以飞出去，也可以再飞回来。不过，苍蝇有点令人讨厌，我不会再告诉它如何逃避苍蝇拍和喷雾器。</p>
<p><span id="剩余问题"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">14 剩余问题</a></h2>
<p>思考，是要动脑子去想问题，但是也要对自己所想的进行考证。</p>
<p>去想的时候，脑洞是要打开的。单这一步，就已经足以令许多人折腰了。因为自己以往的经验会形成各种偏见，自己的主见往往由这些偏见交汇而成。主见会限制脑洞的开放程度。譬如，有些人的脑洞往往只有针眼那么大，以致只能穿进去一根线，或者说，他的脑洞只忠实于这根线，无忠不愚。</p>
<p>一个问题，可以有无数种解决方案。这不奇怪，「有困难要上，没困难制造困难也要上」的人不也是不计其数么？虽然这无数种解决方案里，真正有效的寥寥无几，但是一定不要去过滤……把自己想到的一切方案，都视为有效，而且这些方案彼此平等。就像我们对待所有人那样，人人平等……平等不起来吧？可见，想问题并不单纯是动动脑子，至少通过这个过程，可以让我知道为什么要公平。唯有公平，方能保证能想出来的解决方案足够多。为什么需要足够多的解决方案？不妨将有效方案视为鱼，要捕捉它，需要一张足够大的网。若要编织这张网，就需要足够大的脑洞和公平的态度。</p>
<p>把自己能想到的解决方案逐一记录下来之后，接下来就是去考证。如何考证？首先要有一个能够评估这些方案优劣程度的办法，而这个办法只能从自己所思考的问题里寻找。但是，由于是要解决问题，那么问题应当是明了的，因此这个办法就肯定能想得出来。但是，这个方法能否有效，取决于对问题的理解程度。有了评估方法，就可以对解决方案逐一考证，从中选出最优者。这样，就得到了最好的解决方案，接下来是去执行这个方案。</p>
<p>人类对于几乎所有的问题，都要用这种方式去解决。只有人类会思考么，飞禽走兽不会么？现在，完全可以说计算机也会思考了。人类原本对于思考本身的理解太过于粗略，因此，纵是说万物有灵，也不算荒谬。倘将思考视为脑洞的开放程度、公平的程度以及严谨的考证过程等方面的综合，那么，那么就可以断定，飞禽走兽和计算机不会思考，甚至可以断定多数人也不会思考。</p>
<p>说多数人都不会思考，这话说的有些大，难免令人丧气，甚至以为我在嘲笑大多数人愚蠢。没错，我的意图的确如此。现在若想解决一个问题，仅凭个人的努力往往不够，需要多人协作。如何协作，就是政治。所以，现在，政治几乎无处不在，不仅国家有政治，家族、公司、办公室里都有，但是国家政治，即社会制度是国内一切政治的根本。</p>
<p>马克思是个务实的人，他所理解的政治，和我的理解差不多……要尊重伟人，所以我的理解和他的差不多。我们都是把政治作为以解决现实问题为目标的人与人之间的协作关系，而不是官府如何管理百姓、老板如何管理员工、父母如何管教子女之类的狭隘认识。这些狭隘的认识绝对不是政治，它们不过是吃人之术。马克思将现实问题概括为劳动，将参与解决问题的人与人之间的协作关系概括为生产关系。他只能这样去概括，因为他的看家本领是唯物史观。</p>
<p>在筹集问题的解决方案方面，古代帝王很早有「广开言路」的提法。皇帝要办一件大事，通常会征集大臣们的意见，皇帝本人只负责逐一评估大臣们的意见的优劣工作。这样的皇帝，就算是明君了。昏君往往会在两个方面做的不好，一是脑洞太小，只听信谗臣的意见，甚至只听信自己的意见；二是对问题的了解不够透彻，对于大臣的意见，给出的评估方法有问题。</p>
<p>我们现在说君主专制不好，可能主要是担心皇帝们会在上述的第一方面出现问题。明朝的崇祯皇帝可能是在上述第二个方面出现了问题。无论在哪个方面出了问题，后果都不堪设想。君主专制制度的软肋，就在于，它无法保证君主能够以很小的概率在这两个方面出差错。随着政体的日趋庞大，需要通过这种制度解决的问题越来越多，于是，出错的概率就越来越大。皇帝的位子就越来越难坐。清朝的雍正，据说是因为过于勤政，累死了。再到后来，这龙椅也是越来越坐不稳了，以致于最后，袁世凯的龙椅只坐了 83 天就被赶下来了，还背上了「窃国大盗」的恶名。想当皇帝有错么？</p>
<p>既然一个国家只设立一个君主越来越不靠谱，那么解决这个问题的最容易实现的办法是，多设几个君主……说起来容易，但实际上也是流了不少血泪。现在，天无二日，国有多主。特别是民主国家，人民成了国家的主人。但实际操作起来，人民的权力很小，可能是因为事情大都是由公仆来办的缘故，即便如此，人民可能不太想过于安逸，所以，热衷于参加考试，成为公仆，为人民服务……以致于我有时也很想为人民服务。</p>
<p>人民是不可能真正成为国家的主人的，除非没有政府——这是无政府主义者们的理想。无政府主义者要么是太过于天真，要么就是觉得自己有能力独立解决问题，并不需要与他人合作。也许在未来，机器的生产力高度发达，使得人与人不需要合作就能很好地解决生产问题，政府自然就没必要存在。可是，人类的政府真的会消失么？绝对不会，只会转移。人类固然可以在机器里建立政治，从而将自己的政府迁移到机器世界，让机器们实现自治。可是，机器所承载的程序不可能没有 Bug……人为了修复机器的 Bug，依然需要合作吧。但是，我也不能说无政府主义不能实现，只是前提是无政府主义者首先要做成隐士，然后，就没有什么然后了。</p>
<p>若认同政府还需要存在，并且君主不能只有一个，那么现代世界，不管民主国家还是不民主的国家，政治体制的差别可能并不太大，都是在尽力防止君主们因脑洞过小以及对问题的理解不透彻而导致决策出错。虽然实际操作起来，不尽理想，但总比君主专制时代要好了许多吧。虽然很多人抱怨社会依然很不公平，但是对于解决生产问题而言，公平只是为了解决问题而给出的一个假设，并非最终目的。人人平等，也是这样的一个假设，即假设每个人都有效参与了生产过程，换言之，就是不剥夺每个人参与劳动的权力，而劳动所得归个人所有。这样的话，得到的多还是少，取决于解决的问题是难还是易。所以，按劳分配，这个提法不仅没问题，而且很合理。你只解决了 1 亩地的耕种问题，凭什么要瓜分那个解决了 10 亩地的耕种问题的人的劳动成果？均贫富，这个提法，众所周知，从来都不是什么公平的提法。</p>
<p>事实上，社会的真正的不公之处在于，虽然假设每个人都有参与劳动的权力，但是并没有提供足够的工作岗位。这是政府的失职之处。工作岗位少，人多，劳动力过剩，因此只能采取竞争上岗的方式，让更有能力的人去解决生产问题。这就是那个让「一小部分人先富起来」的政策。这部分人先富了起来，财富集中，生产扩大，从而可以创造更多的生产岗位。这个政策是有成效的，否则就不会出现农民工、留守儿童、空巢老人等说法，但是它解决了一些老问题，又创造了许多新问题，譬如，污染环境，官员贪腐，以及城市建设入侵农村而产生的一些矛盾等等。</p>
<p>有问题，是好事，是创造新的工作岗位的契机。恩格斯说，劳动创造了人本身。在这个基础上，现在不妨说，是问题驱动了劳动。唯物史观是以反对唯心史观为前提，逐步发展出来的。但是，这个路子在最后需要扳回来，否则就会沦为丧失理性的抬杠。这两种史观必有相通之处，而「问题」本身便是窗户，打开它，二者便可相通了。</p>
<p>然而，对于这些新的问题，不少公仆和先富起来的人总是要设法或拖延或掩盖或干脆假装没看到，这样就相当于变相剥夺了那些没有工作岗位的人的参与劳动的权力。政府再次失职。这是否意味着，一个国家，无论立多少个君主，骨子里依然是君主专制，上面我说的那两个问题，是解决不了的。以致于，我们活着活着，就不得不把自己原本要通过思考去解决的问题给忘记，不得不把自己的所有努力变成了近乎像飞禽走兽那样单纯地维护自身的存在。</p>
<p>我们被剥夺的也许并非马克思所说的剩余价值，而是剩余问题。当然，倘自己原本就没什么问题，也没什么可悲的。</p>
<p><span id="问题"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">15 问题</a></h2>
<p>唯物主义者认为，世界由物质构成，意识是客观世界在大脑中的反映。唯心主义者则认为，世界由意识构成，意识决定物质的存在或运动。这是近代西方哲学家在本体论方面分出来的两大阵营。</p>
<p>中国先秦的思想家，分得不是这样清楚。最具有唯物主义精神的墨子，也讲了天志和明鬼。老子和庄子看上去很唯心，但实际上他们讲的是如何从各种自然现象和社会现象中探寻为人处世的道理。譬如，老子从一些自然现象里看到的是微弱的事物往往更持久，而强大的往往会早折。至于庄子，则堪称思维实验的鼻祖，擅长以寓言的形式构造出一些合理的假设，然后再从中导出一些结论。孔子，不是哲学家，他是个好人。《论语》记录的是他的言行，他没有创造哲学体系。孔子是先做成了一个好人，之后才有了《论语》。像孔子这样的好人，还有孟子。孔孟之道，属于社会伦理学，是好人写的社会伦理学，然而通常只有先做成了像他们那样的好人，方能理解。</p>
<p>自秦以后，中国哲学，就乏善可陈。除了程朱理学，就是陆王心学，都是唯心主义，只不过前者客观，后者主观。王阳明的心学，在当时是思想解放。可是，为什么需要解放？是孔孟之后的儒家，把路走到了死胡同。他们为什么要会这样走路？归根结底，自秦以后，中国人的主流意识形态，既不是唯心主义，也不唯物主义，而是唯君主义。即使现在，满清灭亡已逾百年，中国人但凡谈点国运民生之类的事，话题的重心依然在各代君主上，至多是君主的名字换了换，到最后就是换成了一堆现代国家的政治学名词。药瓶子造得已经趋于洁净精微了，而药却没怎么换。</p>
<p>儒家所提倡的那套社会伦理，只要被封建君主所用，就必然会变成商鞅、李斯、韩非、董仲舒等等的法家套路。自古以来，恨秦始皇的儒生很多。我总觉得，若是这些儒生做了皇帝，很有可能会更坑师友同学。毕竟，李斯和韩非，都是荀子的得意门生，而荀子则是战国时期的鸿儒。再者，嬴政所为，比五四新文化运动差得远了，后者显示了积郁千年而后一朝喷发的宏大力量。若我来说，只能说嬴政有着时代局限性，工作不彻底，更何况他焚的只是一些毫无用处的书，坑的不是儒生，而是方士。至于那些书，即使焚了，难道后人就写不出来新的而且更好的了？死胡同，是这些儒生们自己走出来的。然而，他们若不这样走，就只有去种地或经商了，孔子都放不下身段去从事这些职业，何况他们。</p>
<p>我们的思想也许是被禁锢得太久了，即使得到了解放，一时之间也不知道怎样去利用来之不易的自由。在这样的思想体系里，反对的事物，往往就是自己所立的，横竖不过是旧君主下台，新君主上位，总是要给自己找个主子，然后自己跪着。不过，也不要自卑。无论是唯物主义者，还是唯心主义者，他们其实都是跪着的。不是跪给毫无生命可言的物质，就是跪给乱七八糟的意识。</p>
<p>中国传统哲学，走到了阳明心学，就算是走到了绝路。也许，我们应该为中国能提前把哲学走到绝境而自豪。因为西方哲学一直走到维特根斯坦这里，才算是绝路。维特根斯坦之后，海德格尔、萨特之流，要当矫揉造作者来看的……他们的路数，不仅不会比王阳明好到哪里去，甚至还不如战国时代的名家，公孙龙和惠施这些人。以海德格尔为例，我从百度百科上抄来一段：</p>
<blockquote>
<p>「在」就是已经具有的性质。也就是说，首先必须「在」，才有「在者」；绝不可能根本不「在」，就有了「在者」。要解决「在」的问题，必须追溯到一种「在者」，这种「在者」在究竟成什么样子还不明确时它的「在」已经明确了。只有「我」是这种「在者」，只有「我」是在成什么样都还不清楚的时候它的「在」已经恬然澄明了。因此，「我」就是「在」，「在」就是「我」。「我」的「在」就是世界。</p>
</blockquote>
<p>正常人看不懂这些话，也没必要看懂。下面，我给出庄子在《齐物论》引述战国名家的彼是方生之说以及他给出的评价，对比一下：</p>
<blockquote>
<p>物无非彼，物无非是。自彼则不见，自知则知之。故曰彼出于是，是亦因彼。彼是方生之说也，虽然，方生方死，方死方生；方可方不可，方不可方可；因是因非，因非因是。是以圣人不由，而照之于天，亦因是也。是亦彼也，彼亦是也。彼亦一是非，此亦一是非。果且有彼是乎哉？果且无彼是乎哉？彼是莫得其偶，谓之道枢。枢始得其环中，以应无穷。是亦一无穷，非亦一无穷也。</p>
</blockquote>
<p>从令人看不懂的程度上，庄子更有范，读起来更铿锵有力，甚至批判了这种造作的行为，「以指喻指之非指，不若以非指喻指之非指也；以马喻马之非马，不若以非马喻马之非马也」，而且觉得既然你们搞得如此混乱，反倒不如「天地一指，万物一马」。</p>
<p>再来看萨特，依然从百度百科上抄来的：</p>
<blockquote>
<p>存在分为两种：自在的存在和自为的存在。自在的存在是一个物体同其本身等同的存在。自为的存在同意识一起扩展，而意识的实质就在于它永远是自身。我们的思想超越自身、超越一切，因此人类的存在永远是自我超越的：我们在存在中永远超越自我。因此，我们无法占有我们的存在，我们的存在永远在我们自身之外，也就是说，存在先于本质。</p>
</blockquote>
<p>以令人看不懂而论，海德格尔胜过萨特。</p>
<p>哲学是一门没有门槛的学问。不识字，也可以搞哲学。但是，倘若有人把哲学搞成了严重的造作，这就很令人反感了。至于他们为何要如此造作，庄子说的很明白，「惟其好之也，以异于彼，其好之也，欲以明之，彼非所明而明之」，至于造作的下场，就是「以坚白之昧终」。若用软件工程领域术语来说，要么是过早优化，要么就是过度工程。</p>
<p>存在主义所在乎的存在和本质谁先谁后的问题，在唯心和唯物主义者那里，则是物质和意识谁是第一性的问题。哲学家的数学不是太好，可能非常普遍。小学生们都知道，3 + 4 和 4 + 3，结果都等于 7。然而这样的问题，在哲学家们那里，就成了，我们要坚信的是 3 + 4 还是 4 + 3？</p>
<p>维特根斯坦先是觉得，哲学无非就是要把问题讲清楚，讲不清楚的，就沉默。也许，对他而言，到底是 3 + 4 还是 4 + 3 这样的问题，应该沉默。但是后来，他又觉得，一切哲学问题本质上都是语言问题，而语言是一种游戏。</p>
<p>维特根斯坦的工作打破了自古以来哲学家的那些一些完美的幻想式的建构，老子和庄子的道，孔子的仁，孟子的义，墨子的兼爱，让苏格拉底坦然赴死的真理，柏拉图的理型世界，亚里士多德的形而上学……古今中外，一直绵延至今，每个哲学家的心里都有一个幻想式的完美建构。到了维特根斯坦这里，哗地一下，坍塌了，变成了游戏，而且还是年青人并不想去玩的那种游戏。</p>
<p>有意思的是，数学家那里也出现了类似的事情。数学家们一直都认为数学理论是自洽的，是完美的，然而与维特根斯坦差不多同时代的人，哥德尔，给出了不完备性定理，将数学的完美打碎了。损失最惨重的是维特根斯坦的老师，罗素。因为罗素和怀特海用了 10 年光阴，好不容易写了本巨著《数学原理》两箱子手稿，用马车拉到了出版社哥德尔定理却让这本书几乎变成了废纸。</p>
<p>哲学和数学，从根基上都出现了问题，那么物理学呢？毫发无损。物理学家离不开数学，但是数学体系出现了问题，为什么对物理学毫无影响？因为在物理学家那里，数学不过是一种便于描述一些物理问题的语言。语言能出什么问题？我们平时用语言交流的时候，可曾怀疑过自己所用的语言有问题么？或者，可曾考虑过它有多么完美？并没有。即使是文学家，也只是在修辞上下下功夫，他们不会怀疑语言本身有什么问题。即使我们能够说出「我这句话是在撒谎」这样似是而非的悖论式的句子，我们也不会觉得语言有什么问题。</p>
<p>几千年来，太阳一直都是东升西落，人类从未怀疑过。但是，忽然有一天，有个人觉得这种认识不够严谨，便努力给出太阳永远东升西落的理论证明。即便他是世上最优秀的天文学家，但是这样的证明，谁会在乎呢？况且，即便他的证明很完美，我们依然可以追问，太阳为什么不是在你不注意的时候，从西方升起，然后又以你无法感知的速度跑到了东方？罗素在《数学原理》中用了 379 页，证明出来 1 + 1 = 2。我们就可以反问，为什么不是 1 + 1 只有在你注意到它的时候才等于 2，而在你不注意它的时候，它等于任何一个数呢？</p>
<p>维特根斯坦是对的，即使不用读懂他的《哲学研究》也可以知道这是对的。人类的一切学问，本质上，都是游戏。只有这些游戏与我们的现实生活有所吻合的时候，我们方能体验到游戏的真实性。现在的运行在电子设备上的游戏，开发者也在努力让游戏场景接近于现实场景。换个例子，同样一个故事，若想让大家觉得这个故事很真实，用京剧来表达，就远不如用现代电影来表达。但是，无论一门学问有多么真实，即使最真实的物理学，也是一门游戏。</p>
<p>从游戏的角度来看，大多数人奉为信仰的那些教义，充其量是某些游戏必须遵守的基本规则。你觉得遵守那些规则，某些神灵或领导会保佑你，这不过是意味着你入戏太深了，把游戏当成了现实。</p>
<p>倘若整个社会都沦陷在一场又一场巨大的游戏中的时候，你若发现了这个真相，该怎么办呢？在现实中，被杨教授电过的孩子们，他们难道不知道自己是在玩游戏么，他们难道不知道现实生活的存在么？我觉得，他们的确不应该被处以电刑。因为，即使拿到诺贝尔奖的科学家，本质上也是在玩着一个游戏，只不过大多数人不觉得那是游戏罢了。</p>
<p>对此，一个人，固然可以说，我不喜欢玩游戏，所以，我应该做一些更有意义的事。然而，什么事是更有意义的？</p>
<p>如果所有的人都在玩游戏，只有一个人不喜欢玩，这个人唯一能做的事情是，去劝说别人不要再玩游戏了，而应该去做更有意义的事……可是，什么才是更有意义的事呢？被劝说的人可以反问，难道你劝说我们不玩游戏，会比我们玩游戏更有意义吗？我们听从了你的劝说，接下来就是和你一起劝说别人吗？假如把所有的人都说动了，大家都不玩游戏了，那么我们要做什么呢？这一系列的反问，类似于，既然你说在地球上活得很痛苦，那么你要跑到火星上生活吗？</p>
<p>这个人在发现上述劝说无效之时，他应该找一个新的问题。但是，既然一切学问都是游戏，那么一切问题也都在游戏里，他怎么可能会有另外的问题？</p>
<p>当然是有的，而且这个问题只有一个，它叫问题。</p>
<p>问题，是一切。世界由问题构成，已解决的，正在解决的，以及剩余的。</p>
<p>对于一些人而言，一些问题是已解决的，但对于另一些人而言，则未必。因此，对于每个人，世界永远都是复杂的。对于所有人而言，世界则简单到了不存在的程度，因为所有的问题彼此抵消了。</p>
<p>若没有了问题，人和人之间，连敌人都做不成，甚至一个人连自己都做不成，宇宙无限空寂。</p>
<h3>老子</h3>
<p>从老子开始，因为他是我最喜欢的哲学家之一，我现在却开始向他传道。不过，这也许是他所期望的。</p>
<p>老子：道可道也，非恒道也。</p>
<p>我：老先生，你说的这个道，就是问题。问题可问也，非恒问题也。</p>
<p>老子：何为非恒问题？</p>
<p>我：我问你一个问题，只要你给出回答，那么我又可以从你的答案里继续提出新的问题。</p>
<p>老子：+10086</p>
<h3>庄子</h3>
<p>庄子是我第二个喜欢的哲学家。</p>
<p>庄子：是我梦到自己变成了蝴蝶，还是蝴蝶梦到自己变成了我？</p>
<p>我：你和蝴蝶有着同一个问题。</p>
<p>庄子：+10086</p>
<h3>孔子</h3>
<p>孔子，是我知道的第一个好人，他的好，是靠自己的身体力行表现出来的。</p>
<p>我：孔先生，您最喜欢自己的哪句话？</p>
<p>孔子：……《论语》里有你么？</p>
<p>然后，他不再理睬我，带着《论语》里的人马，继续向前方走去。</p>
<h3>孟子</h3>
<p>孟子，是我知道的第二个好人。</p>
<p>孟子：鱼，我所欲也。熊掌，亦我所欲也。二者不可得兼，舍鱼而取熊掌者也。</p>
<p>我：孟老师，若二者可兼得，您是先吃鱼，还是先吃熊掌？</p>
<p>孟子有点不高兴地瞥了我一眼，说：别打岔……生，我所欲也。义，亦我所欲也。二者不可得兼，舍生而取义者也！这位同学，你刚才问我什么？</p>
<p>我：若二者可以兼得，是先生后义，还是后义先生？</p>
<p>孟子：这么好的事，你确定能轮得上我？</p>
<p>我：您这一生，鱼和熊掌，或许有人会送您，但是有人不让您生么，又有人让您不义么？</p>
<p>孟子：没有。</p>
<p>我：那么，您的这些微言大义，并未解决什么问题。</p>
<p>孟子：吾善养吾浩然之气！虽千万人，吾往矣！</p>
<p>我：哪些问题，需要用浩然之气来解决？又是哪些问题，会有千万人阻拦，不让您去解决了？</p>
<p>孟子：咳咳……君子要坦荡，做事情要有勇气，这难道有什么不对吗？</p>
<p>我：您是第二个好人。我品行远不及您，但是，倘若并没有什么问题只有君子能解决而小人却解决不了，那么您的坦荡和勇气岂不是很多余吗？</p>
<p>孟子：小子，不要逞口舌之利！浩然之气，你养成了，就自然知道它能用来解决什么问题！</p>
<p>他的声音有点哆嗦，想必是生气了。</p>
<p>我：也许您是对的。不过，我担心的是，我练就了屠龙之技，世上无龙可屠。</p>
<p>孟子：bye……bye……</p>
<h3>墨子</h3>
<p>墨子：兼爱，非攻。</p>
<p>我：大家来自五湖四海，要解决同一个问题。</p>
<h3>朱子</h3>
<p>朱子：存天理，灭人欲。</p>
<p>我：问题，天理也。人欲，不想解决问题也。</p>
<p>朱子：格物致知。</p>
<p>我：对于任何一个问题，当你用尽所有的法子，就一定能解决它。</p>
<p>朱子：对！我为了解决唐仲友的问题，向皇帝弹劾了他 6 次，甚至暴打了一个柔弱又很有气节的女子。没想到，500 年后，竟然有人理解我的做法，吾心甚慰。</p>
<p>我：把问题说成天理，什么事都能做得理直气壮了……</p>
<h3>王阳明</h3>
<p>王阳明：心即天理。</p>
<p>我：心即问题。</p>
<p>王阳明：心外无物。</p>
<p>我：问题之外无问题。</p>
<p>王阳明：知行合一。</p>
<p>我：若去解决问题，学习和实践，自然会合一。</p>
<p>王阳明：致良知。</p>
<p>我：解决问题。</p>
<h3>唯物主义</h3>
<p>唯物主义者：世界由物质组成，意识是客观世界在大脑中的反映。</p>
<p>我：问题，是物质，还是意识？</p>
<p>唯物主义者：是意识。</p>
<p>我：那么，你有问题，是客观世界在向你发问吗？</p>
<p>唯物主义者：当然不是，是意识反过来作用于我的大脑，让我提出问题。</p>
<p>我：是意识在向你发问吗？</p>
<p>唯物主义者：你，是哪个教的？</p>
<p>我：发问教。</p>
<h3>唯心主义</h3>
<p>朱熹说，算了，大家回家吃饭吧。</p>
<p>王阳明说，算了，大家回家吃饭吧。</p>
<h3>逻辑主义</h3>
<p>罗素说，算了，大家回家吃饭吧。实在不想看哥德尔那幅否定一切的嘴脸。</p>
<h3>语言游戏</h3>
<p>维特根斯坦：一切哲学，都是语言问题。哲学无非是要把问题说清楚，凡不可说的要保持沉默……咳咳……语言是一种游戏。</p>
<p>我：游戏的目的是什么？</p>
<p>维特根斯坦：把问题说清楚。</p>
<p>我：《哲学研究》说清楚了什么问题？</p>
<p>维特根斯坦：语言是一种游戏。</p>
<p>哥德尔：老维，你写了《逻辑哲学论》之后干了些什么？</p>
<p>维特根斯坦：写了本《哲学研究》。老哥，你证明了不完备性定理之后干了些什么？</p>
<p>哥德尔：回家吃饭。</p>
<h3>存在主义</h3>
<p>萨特：存在先于本质。</p>
<p>我：问题先于它们。</p>
<p>萨特：海德格尔，我们回家吃饭。</p>
<h3>Karl Marx</h3>
<p>Marx：资本家是靠剥削劳动者的剩余价值活着的。</p>
<p>我：也许您没想到，靠您的主意建立的一个国家，这里的人后来纷纷怀疑这个理论了。</p>
<p>Marx：他们不热爱劳动，想成为新的资本家。</p>
<p>我：为什么资本家不热爱劳动？</p>
<p>Marx：他们热爱劳动。劳动，对于他们而言，是剥削工人的剩余价值。</p>
<p>我：我们现在管这个，叫割韭菜。为什么资本家热爱劳动，工人却不热爱呢？您那个年代，想必有很多大规模的工人罢工活动。</p>
<p>Marx：我想想……应该是，资本家想去解决的问题，不是工人想去解决的。</p>
<p>我：资本家要解决的问题是，让自己占有更多的财富。工人去工作，难道不也是为了自己占有更多的财富么？他们的问题，难道不是同一个吗？</p>
<p>Marx：这说明，劳动的目的，并非仅仅是为了累积财富。</p>
<p>Engels：劳动创造了人本身。</p>
<p>我：劳动创造了人本身，这句话太虚了。人的本身是什么？不就是一个人，遇到了一些问题，自己想去解决吗？劳动，不就是解决问题的过程吗？为什么你们把这个过程看的这么重要。</p>
<p>Marx：可能因为我们是唯物主义者的缘故。问题是唯物的，还是唯心的?</p>
<p>我：问题涉及的对象是唯物的，提出问题的人是唯心的。问题，是窗户，沟通了唯物和唯心。提出问题，就是把窗户打开了。</p>
<p>Marx：假如我能再活 40 年，也许我能证明，资本家剥削的不是工人的剩余价值，而是工人的剩余问题。</p>
<p>我：别再浪费青春了。他们若是知道自己的剩余问题是什么，谁也剥削不了。</p>
<p>Marx：你这么年青，就如此颓废，振作起来！</p>
<p>我：我的颓废，一方面是因为还没找到自己想要去解决的问题；另一方面，不想解决的问题，又实在是太多了。</p>
<p>Marx：我该回 Engels 家吃饭了。</p>
<p><span id="原子"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">16 原子</a></h2>
<p>德谟克利特并未真的见过原子，也未曾见过虚空，但他却说万物的本原是原子和虚空。他认为，原子是不可分割之物，虚空是原子的活动空间。</p>
<p>苏轼问，事不目见耳闻，而臆断其有无，可乎？所以，苏轼只能做个文学家，做不了哲学家。</p>
<p>两千多年之后，化学家发现化学变化中的确存在着不可分割之物，他们想起了德谟克利特，便以原子作为此物的名字。之后，物理学家以原子为基础，统一了固体、液体以及气体等物质形态，进而探究原子内部结构，建立量子力学。</p>
<p>我现在可以确信万物的本原是原子，因为我相信化学家和物理学家的实验。并非是因为他们的实验验证了这个说法的正确性，而是因为他们说他们的实验结果与德谟克利特的说法吻合。但是，在德谟克利特时代，有什么理由或者办法能够令人相信他的观点是正确的呢？没有。</p>
<p>无论是东方还是西方，都有一段长达千年的靠目见耳闻而断有无的时期。在这段时期，神学和王权的出现，发展，以及脱离现实的程度，所反映的不正是人类的想象力受到了严重限制么？在这漫长的时间里，德谟克利特应该非常寂寞。</p>
<p>每个时代的哲学家，往往是跳出思维局限的一少部分人，他们却无法证明自己的观点是否正确。所以，观点或结论很重要么？宋襄公的仁义，现在的愚不可及。现在的信仰，未来的愚不可及。</p>
<p>跳出思维局限的唯一方法是，问自己一些问题，然后去解决。要像屈原那样问天，不要学他那样跳江——谁提出了问题，就该由谁去解决。德谟克利特应该是问了自己，世界的本原是什么？尝试回答这样的问题，结果便是某种本体论。这样的问题，现在似乎已经不足以构成问题了，不知多少先哲都尝试回答过这个问题。科学的普及，使得我们确信以德谟克利特的答案为善。然而，一旦接受了某个答案，我们的思考会无法避免地再次陷入局限，除非继续提出问题，解决问题。</p>
<p>德谟克利特说过这样一句话，弄清楚一个问题，其快乐胜过做波斯国王。现在，依然有很多人认为地球是方的，相对于大多数认为地球是圆的人而言，这些人的快乐也许胜过当公司的老板。越是无知的人，当他忽然有一天像德谟克利特那样问自己一个超出他生活范围的问题时，他所得的快乐越是无法估量。世上最大的乐事莫过于鸿蒙初辟。</p>
<p>我能想象得出德谟克利特是如何非常肯定万物的本原是原子和虚空。因为，他只要去尝试解决这个问题，第一步必然是对事物进行分割，即便此事仅在思维中进行，否则就意味着要承认自己没法解决这个问题。只要他去尝试分割，就必然会发现，分割不可能永无止境，因为永无止境的分割会再次意味着承认自己无法解决这个问题。这样就有了原子。有了原子，就必然要有虚空，否则原子的不可分割又无从谈起。最后，有了原子和虚空，也有了原子在虚空中遵循着某些可确定的规律的运动和组合。至此，德谟克利特便认为自己的问题得到了很好的解决。只要遵循着问题的指引，不断思考下去，并不需要太多天分便可以成为德谟克利特。</p>
<p>德谟克利特的时代，没有数学，没有化学，也么有物理学，但是他的这个观点却在现代诸多学科中得到了间接地肯定。例如，微积分里有个泰勒展开公式，对于一个函数，它能展开的部分相当于原子，余项相当于虚空；反过来说，亦可。在机械工程学里，基本的机械机构便是原子，机构的运动空间便为虚空。在计算机软件开发领域里，汇编指令是原子，而 CPU 是虚空。</p>
<p>德谟克利特的原子论，从更广泛的意义上来说就是，对于任何一个问题，我们不妨去解决自己能解决的那部分，但是不要掩盖剩余的那部分。倘若回避问题，那么就必然要为自己树立某种信仰，认为只要有了这种信仰，便可无往而不利。科学与宗教的区别，也许不仅仅在于谁更有解决问题的勇气，而是更在于谁更承认问题并未得到完全解决。</p>
<p>旧宗教衰亡了一些，新宗教也许早已比比皆是了。当我没思考原子这个问题的时候，若有人问我物质由何构成，我会不假思索地说，由原子。现在，我需要认真地补上，还有虚空。Then，虚空是什么？</p>
<p><span id="辩证法"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">17 辩证法</a></h2>
<p>哲学并非科学之科学，而科学的尽头也不可能是佛学。催生了量子力学的电子双缝实验，固然诡异，但若讨论电子的行踪为何如此诡异，那就不再是物理学范畴的问题了，而是哲学范畴的问题。单从这一点来看，哲学与科学之间似乎存在着不可调和的矛盾：前者是封闭的，而后者是开放的。</p>
<p>哲学不允许未知事物的存在，无论是把世界的本原解释为物质还是意识，迄今为止几乎任何一个哲学家都试图用他的一套理论包打天下。这种封闭性是有害的，除非自己能够充分认识到它的存在。在民间，未知事物往往被视为鬼。鬼在夜间出现，而夜间的黑色象征着肉眼凡胎看不到的未知世界。鬼神之说，源于人类认识上的封闭性，是将未知当成已知的体现。在封闭程度上，哲学结论并不比鬼神之说更为高明。一个人，倘若他的认知出现了封闭性，便会产生一种错觉：万物皆备于我，只需随心而行。科学则不然，未知事物一直都是科学保持活力的源泉。</p>
<p>对于未知事物，要么沉默，要么研究。儒家学派选择了前者，他们对鬼神采取了忽略的态度，故而子曰，「未知生，焉知死」。至于与儒学对立的墨学，我敬仰墨子的工匠精神，但对于他在天志和明鬼方面的主张则不屑一顾。儒学与墨学也没什么好争的。倘若儒家能从墨家那里汲取一些工匠精神，而后者能从前者那里汲取一些沉默精神，一切可能会更好一些。在中国的传统哲学里，惟有老子和庄子对未知事物有着宽容的态度，他们将未知事物视为驱动着一切已知事物却难以言说的道，这是一种研究的态度，尽管只是哲学层面上的研究——那时也没有科学。哲学原本也是开放的，早在苏格拉底之前，古希腊德尔斐神殿的入口处镌刻了一句话，「认识你自己」。哲学的开放性，只是被后世的不成器的哲学家们封印了起来，尽管他们并非故意。</p>
<p>研究任何未知事物，需要对其各种外在表现予以观测，归纳和验证。这三个环节，任何一个出了问题，都有可能得到谬误。倘若得到了谬误，而自身又陷入了认知封闭性的怪圈，谬误便会演绎成「鬼神」而不自知。若将哥德尔在数理逻辑领域证明的不完备性定理延伸到哲学领域，就很容易看出，任何一种追求真理的探索活动，必然意味着认知上的封闭性，必然会出现一些道理，既无法证明它们是真理，也无法证明它们不是。这一点，如同某些宗教里的上帝，教徒们相信它无处不在，但又拿不出充分的证据，他们为了维护认知上的封闭性，就必然要依赖于信仰。有信仰的人——也就是有价值观的人，很少有人愿意承认自己对这个世界的无知。他们有时也会承认，但是也会一不小心就会露出信仰的真身。</p>
<p>承认未知事物的存在，是跳出认知封闭性的必经之路。世界充满了未知，这有什么可怕呢？走夜路时，为什么要以高声歌唱来驱散内心的恐惧呢，为什么不去研究坟地里闪动的鬼火的成因，即使观测手段不足以研究它们，那么为什么不能单纯把它们作为一种天造地设的艺术来欣赏呢？</p>
<p>信仰有助于驱散我们的内心对未知事物的恐惧，但它实在是一种精神上的鸦片。鸦片可以止痛，但疼痛的原因却无法通过鸦片而获得。倘若弄懂了原因，鸦片就成了多余存在之物，因为它带来的那点快感，远不如通过自己的努力破除困扰在心头已久的梦魇。从这一点而言，求生不同于畏死。求生的人，更有可能走到科学的道路上，而畏死的人，则很容易养成吸食各种精神鸦片的恶习，静静地等待着多年以后一场死亡的降临——死亡，面向所有人的未知事物。</p>
<p>求生的欲望往往能够使得我们正视未知事物，从而产生与之抗争的勇气，这大概就是孙子兵法所说的「置之死地而后生」。这种抗争，应当转化为科学性地探索工作，不能蛮干。蛮干式的抗争，是另一种信仰，它虽然与吸食精神鸦片背道而驰，但终归还是在同一条道上，一为朝三，一为暮四。历代农民起义，大多是蛮干，因而起义成功之日，便是他们转化为他们当初所反对的那些人之时。十六七岁叛逆过父母的孩子，他们长大了，也为人父母时，并不意味着他们的孩子不再叛逆。</p>
<p>认知的封闭性有助于新知识的演绎，不过演绎出来的新知识固然仪态万千，而演绎本身却不过是一种游戏。游戏必须封闭，否则支撑游戏的系统便会崩溃。被杨教授电过的那些孩子们，他们热衷于打网游。倘若能够对他们加以疏导，这些孩子未来或许能在哲学、数学或艺术方面大有作为。若将网游本身视为数学公理体系，打网游的人像数学工作者那样，在这个体系上演绎出一种又一种新的「玩法」。不要低估游戏的作用，它实在是培养孩子们演绎能力的好办法，虽然这种演绎并没有太大用处，但是孩子为什么要干有用处的事？真正有用处的事，是熟悉了演绎之后，勇敢地打破系统的封闭性，从游戏里跳出来。然而，这样的事，家长往往也做不了。所谓家长，大多无非是在一个更大的游戏之中演绎人生而不自觉的普通人。</p>
<p>从一个封闭性的系统里跳出来，并不是那么的难，也不会像鲁迅所说的铁屋子隐喻那样可怕。只要在内心里坦然承认世上还是有一些事，是自己不知道的，并意识到到若能够弄懂它们，就可以利用它们改善自己的生活，就足够了。</p>
<p>当然，我也只是说的简单。坦然承认世上有着自己所不知道的事，几乎是每个人都能做到的，但是厘清这些事与自己的生活之间的关系，就几乎不是每个人都能做到的了。这很正常，既然这些事是我不知道的，我又怎么能知道它们与我的生活有何关系呢？此外，我真的像一直所认为的那样知道自己的生活吗？既然我在内心里坦然承认世上有一些事是自己不知道的，现在我开始对自己已经熟悉的一切提出了疑问，那么我是否应该去回答这些问题？倘若对于这些问题，我经过了一番认真的探索，终于有了一些答案，那么这些答案能改善我的生活吗？我的生活又是什么呢？</p>
<p>内心里坚定着知识是有用的人，他们是幸福的，对于他们而言，只要读书破万卷就好了。然而，我并不知道知识到底是有用的，还是无用的。至此，我忽然觉得，我对自己的生活也并不是像自己原先所以为的那么了解。我对我的生活的无知，在程度上并不亚于人类对黑洞的无知。</p>
<p>如果我所做的一切，无助于改善我的生活，就毫无意义。但是，要评价我所做的一切是否有意义的前提是，我对自己有足够的认识。然而这个前提，几乎每个人都毫无疑问地认为自己足够了解自己。所以，我时常会听到「你一点不了解我」的抱怨。你自己了解自己吗？自己只是比他人更了解自己，这样算是了解自己吗？</p>
<p>最大的游戏，也许就是这种自我的游戏，而这个游戏总在悄无声息地控制着每一个人，令每一个人都陷入到不假思索的演绎性的怪圈里。若想跳出这个怪圈，只能是对自己提出一个「我是谁」之类的问题，而对这个问题的回答过程便是「认识你自己」，因为要回答这个问题，必须要从自我之中跳出来，然后反观自我。「认识你自己」，古希腊人之所将这句话镌刻于神殿的入口，也许是因为他们觉得，只有对自我有所认识的人，方能有资格与神对话吧。</p>
<p>自我，如何反观？说是要跳出自我，但实际上谁也不可能真正跳出来。可能太多的人的确很想跳出来，看看自我的真相，他们就把自我分离为肉体和灵魂，兽性和灵性，恶与善……一个人，可能觉得自己以前太坏了，所以就想着去做一个好人了。反之，一个坏人，想必是觉得以前做了太久的好人，受了太多委屈，便开始黑化了。好事不出门，恶名传千里。中国人一直习惯以一个人所做过的坏事来给他贴上一个坏人的标签，这种习惯也许是儒家主张要做好人的理念洗出来的。</p>
<p>我倾向于认为，这些矛盾的概念是在人对自我的反观中出现的，而且这些矛盾意味着反观的无效。若把自己置身于这些矛盾之中的一方，然后与另一方抗争，这实际上又陷入了封闭的认知里了——背道而驰，但终归还是在同一条道上。许多哲学问题，是在无效地反观自我的过程中提出来的。提出这些问题的人，是如何解决问题的呢？他们似乎一直是通过制造新的矛盾来解决，而不是去发现新的原理。</p>
<p>哲学世界，演绎到黑格尔时，就干脆把矛盾当成研究对象，提出了辩证法。为此，许多热爱中国传统文化的人忽然发现——不好意思，我当年也是如此——两千多年前的老子的一些朴素的说法也充满了辩证感。只要有了一双漂亮的鞋子，无论多大的脚都要硬塞进去，然后会觉得脚也漂亮了起来。老子的确有辩证法，这不奇怪，黑格尔的辩证法也是从古希腊哲学家那里得来的。奇怪的是，我们现代人却是要在听说了黑格尔或马克思的辩证法之后，才想起来老子也有辩证法。不过，纵使想起来，也没多大用的，认知的封闭性导致了并没有太多的人真的理解辩证法。</p>
<p>一个奴隶主对一个奴隶很肯定地说，你的一切都是我赐予的，所以，你要终生听命于我。奴隶反对，王侯将相，宁有种乎？然后，奴隶奋而反抗，结果杀死了奴隶主，获得了解放。这时，会出现两种辩证法。一种是，这个奴隶变成了新的奴隶主——这就是我们大多数人习以为常的「辩证」，即好事会变成坏事，坏事会变成好事；另一种是，这个奴隶设计了一套新的社会制度，从而彻底消除了奴隶和奴隶主之间的矛盾——这是黑格尔的辩证法。</p>
<p>老子的朴素辩证法不比黑格尔逊色。周室势微，诸侯争雄，人或为刀俎，或为鱼肉。老子身为鱼肉，若想「消灭」掉刀俎，并且保证自己不会成为新的「刀俎」，就只能出关隐居。老子的辩证法是没问题的，关于他出关的传说，也印证了他的确践行了他的辩证法，此外，他所主张的「功成身退」则是又一个证据。</p>
<p>事实上，从跳出认知封闭性的角度来看，辩证法的三个阶段，正（肯定）、反（否定）、合（否定之否定），可以这样理解：正，构造了认知的封闭性；反，意识到了认知的封闭性；合，跳出了认知的封闭性。所以，无论是黑格尔的世界精神，还是科学所追求的真理，走的都是一条辩证的路线，并不断地发展和壮大。黑格尔将这个过程称为世界精神不断趋向于了解自己的方向发展，那么科学呢？假如真的存在什么真理，那么科学就是令我们不断趋向于它的一种方法。但是，一旦这样去理解世界精神或科学，对于那些从未像黑格尔或真正的科学家那样思考的人而言，他们便很容易将「世界精神」或「真理」视为某种实体，由此产生出某种信仰。在这种信仰的支配下，他们又会为自己不再试图跳出认知封闭性怪圈而构造种种理由。若让庄子评价这种现象，或许他会说，道隐于小成，言隐于荣华。</p>
<p>为什么不能说得更简单一些呢？辩证法的三个阶段，难道不正是认识现实，提出问题，解决问题吗？别人肯定的，我反对。我是怎样反对的呢？若有人对我说，天上有玉皇大帝，他能定夺着人的命运。我的反对，仅仅是对这个人说「我不信」吗？我为什么不信？我的反对，其背后必然是有问题的，只有我把这个问题提出来，才能算得上是反对，否则只会沦为抬杠——不得不再强调一次，背道而驰，依然是在同一条道上。我的反对是，那么谁来决定玉皇大帝的命运？这个人只能给出三种回答：</p>
<ul>
<li>不知道。</li>
<li>玉皇大帝自己决定。</li>
<li>由玉皇大帝的玉皇大帝决定。</li>
</ul>
<p>对于第一种回答，我可以继续问他，那么你是怎么知道有玉皇大帝的呢？对于后两种回答，我可以继续问，你这样回答，岂不是在定夺玉皇大帝的命运？若这位仁兄还不是那么无可救药，想必他能够意识到并没有哪种神灵能够决定人的命运，即便有这种神灵，他也不可能知道这位神灵的名字、住处以及模样。那么，我呢？变成无神论者，与有神论者剑拔弩张地斗争下去吗？背道而驰，依然是在同一条道上……我不会这样做的，我会认为，我的命运由神决定，这并非不可接受，但前提是，这个神须得是我，问题由此得以解决。之后，倘有人反对我的答案，那么，他也应该像我这样去找到问题，然后解决，而非停步不前，与我的答案作斗争。</p>
<p>斗争并非无意义，但斗争的目的不应该是消灭对方，而是发现问题。消灭对方，等同于消灭问题。倘若没有了问题，不又是回到认知封闭性的怪圈里了么？有敌人，始终是好事……对于希望世界或自我能够继续发展下去的人而言。换言之，斗争是冲破封闭性所必须的力量，但只有力量还是不够的，还要有问题。唯有问题，方能使得力量作用到实处。</p>
<p>量子力学有多种诠释，哪种诠释是正确的？我想，不应该这样去问，而应该去问，这么多的诠释是否意味着哲学出现了问题？量子力学的诸多诠释，都能够解释为什么电子在不受观测的时候是波，而一旦观测了，就变成了粒子。因此，量子力学的困境，并非量子力学自身的，而是哲学的。这种困境只能说明，在提出量子力学之前，哲学家对世界的思考一直是领先于物理学家的，或者哲学原本是物理学不断的前进的领路人。量子力学出现，导致哲学陷入困境，后者却希望能够从前者那里寻得一些出路……这种本末倒置所造成的结果便是，为量子力学炮制了如此多的诠释，甚至被科学家们冷落很久的神学也不甘寂寞，跑了过来凑个热闹。</p>
<p>对于这样的困境，哲学的出路，应该在于哲学对自身的重新思考，而不是强行解释物理学的发现——无论对量子力学持有哪种解释，都是不自觉地陷入到了认知封闭性的怪圈里了。当然，他们若是干脆无视科学的发现，则又是一种自我封闭。他们应该去问，为什么量子力学会有这么多的解释？</p>
<p>学问越大，跳出认知封闭性的难度也就越大。哲学家和科学家，聪明程度异于常人，但他们犯起傻来，也往往异于常人。不过，从他们的犯过的傻来看，他们对辩证法的理解和常人倒是差不多的。哲学是靠逻辑去追问，而科学则是靠事实认真回答。从哲学到科学，就是从无知到知无，这个过程若是颠倒了过来，就会出现许多奇谈怪论，从而演化为神学或玄学，此时，唯有辩证法可破解之。也只有在辩证法里，哲学和科学的内在矛盾能够得以消除。</p>
<p><span id="信息"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">18 信息</a></h2>
<p>拿尺子测量某物的长度，譬如一根绳子的长度，尺子是实物，绳子也是实物，那么，长度呢？长度是绳子与尺子之间的联系，无所谓存在或不存在，是物质还是意识，我们只知道，有了尺子和绳子，就会有长度。</p>
<p>长度是一种信息。对于一个直角三角形，我测量了它的两条直角边的长度，然后利用这两个长度计算出斜边的长度。像这种并非直接测量而得到的长度，也是信息。</p>
<p>形而上学一下，信息不仅能反映实物与实物之间的联系，也能反映信息与信息之间的联系。我们的一切创造性的活动，似乎一直都是以实物的组合或信息的组合这两种方式去创造一些蕴含着新的信息的实物或信息，那么，实物与信息能否组合，亦即二者能否建立联系？譬如，拿尺子测量计算机内存中某段数据的长度，或者拿世上最灵敏的天平去测量一本书所蕴含的知识的分量……我实在是做不到。那么，拿自己的大脑去思考自己呢？</p>
<p>当我们很高兴地说，呀……终于想清楚了！此时，所谓的「想清楚」，与精确测得一条绳子长为 3.1415926 米，在本质上，有区别么？思考应该是最低成本的测量手段，或者是最低成本的构造新信息的手段。</p>
<p>当我看着一根绳子，在估算它的长度时，我是在思维里为这根绳子构造了一把粗略的尺子。虽然这个尺子并不存在，但它曾经存在过，而且我也用过它。当我用这把不存在的尺子——或者它在我记忆里的影子——去测量这个绳子时，是否可以说，我是在使用某种信息去测量绳子的长度？如果可以这样说，那么，实物和信息的确能够建立联系，尽管得到的结果是很粗略的信息。图灵想象中的计算机，内存是纸带，数据写在纸带上，的确可以用尺子测量数据的长度。至于知识的重量，古人把书写在竹简上，用车为单位来衡量它的重量，譬如要夸一个人很有学问，可以用成语「学富五车」。</p>
<p>现在已经很明白了，思考由问题驱动。黑格尔的辩证法，可以理解为认识现实、提出问题以及解决问题，而思考则贯穿了这三个过程，最终得到新的信息。与其说是世界精神向了解其自身的方向发展，毋宁说是我们希望得到更多且更精确的信息。在构造新信息的整个过程里，实践并不重要，从而为哲学留下了广袤的容身之地，但是若想构造精确的信息，则实践必不可少，至少需要在纸上或计算机里做许多数学上的运算。数学，是用于构造精确信息的工具。</p>
<p>目前的人工智能技术并非是因为它们不会思考而无法取代人类，事实上，思考是什么，人类自身也说不清楚。现在，我只能说，人工智能没有自己的问题，它们的活着，只是被动地接受人类交给它们的问题并予以解决，而且它们也并没有真正解决什么问题，它们只是帮助人类构造了一些精确的「尺子」。譬如，测量两张照片中人脸的差异程度，这与我们使用尺子去测量绳子的长度，在本质上，有区别么？ </p>
<p>德谟克利特所认为的万物本原——原子和虚空，现在，原子确定无疑是存在的，当然，更准确的说法是基本粒子。那么虚空呢？虚空也的确是存在的，只不过，它的名字应该叫信息。物质是基本粒子的组合。信息是一组连续的基本信息的叠加。基本粒子在信息中运动——它的运动承载着信息，所以它的位置……是叠加态，更准确地说，应该是基本粒子所承载的信息是叠加态。在对一个电子进行观测时，观测什么呢？它的位置信息，这个信息取代了电子原来所承载的叠加态信息。</p>
<p>一根有体积的绳子，不去量它，它承载了体积信息。若是拿尺子去量它，得到的不过是长度信息罢了。我们可能只是已经习惯了把绳子理解为一维的线，所以很容易忽略它在另外两个维度空间（信息）中的存在。测量，总是要以忽略一些维度的信息为代价。</p>
<p>我们生存的空间未必真的是习以为常的三维空间。之所以认为这个空间是三维的，无非是因为我们目前只能够从三个维度去测量它。但是，测量的对象是这个空间本身吗？当然不是。说这个空间是三维的，不如说，我们通过测量我们所能测量的事物获得了这样一种精确的三维信息，而基本粒子所承载的信息却极有可能大于三维——当然，这在超弦理论看来已经是非常肯定的事实了。</p>
<p>超弦理论的困境是无法通过实验证明蜷缩在基本粒子里的蜷缩的 6 维空间的存在，然而，我们似乎也没有通过什么实验证明三维空间的确存在。再者，十维空间有多么地吓人么？很多人之所以觉得这么多维的空间不可思议，是因为他们试图通过几何图像去理解这样的空间。在数学里，十维空间，也不过是有着九个变量的函数，或者十个基函数张成的空间……成本并不高……看来，数学要一定学得足够好才行——从明天起，重新学数学。</p>
<p><span id="从时空穿越说起"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">19 从时空穿越说起</a></h2>
<p>一个人对我说，他活了 1 万多年。只要他能够通过描述这 1 万多年自己所经历过的事，让我觉得他的确像一个活了 1 万多年的人，那么我会允许他活这么久。但是，如果有一个人对我说，他从明朝或 2038 年穿越来的，我只想一拳把他打回去。</p>
<p>正经一些的科幻小说作家，基本上不会去写时间穿越之类的东西，除非这东西的确很挣钱。刘慈欣在《三体》里，也只能靠人体冬眠的方式令人变相地穿越时间。即便人体冬眠技术能够得以实现，其高昂成本，也只有很有限的人有资格使用，而且也只能向未来穿越，不可能再回到过去。不过，当冬眠的人被未来的人激活时，对于这个人而言，则是整个未来的世界穿越到了过去。</p>
<p>不信时间可以穿越，原因很简单，时间是我们对某些正在运动的东西的测量结果，它和我们用尺子去测量一根绳子的长度并无本质上的区别。倘若把一种测量结果的存在性与被测对象的存在性等同起来，就会出现时间可以穿越这样的错觉。如果你认为时间可以穿越，那么请问，你能变成 1.7 米本身么？</p>
<p>时间若不能穿越，那么空间呢？我们能否通过空间的折叠，从而实现星际旅行呢？在提出这样的问题之前，请务必想一下，空间难道不是对某些正在运动的东西的测量结果么？你怎么去折叠它？你能把 1.7 立方米折叠成什么呢？于是，我也不信《三体》里的曲率引擎，尽管它远未达到折叠时空实现超光速的瞬移。</p>
<p>时间穿越和空间折叠，不过是一些微分方程的解，是一些计算结果。把这样的计算结果投射到现实的世界里，得到的结论固然有趣，甚至有助于理解数学计算中的抽象之处，但是不能把这些结论本身当真，否则严肃的数学和科学，就会沦为神话，即使这神话有着现代感和科技感，但是与几千年前的那些神话相比，也没什么进步可言，这可能也是许多宗教这些年一直觉得自己能够和科学攀上关系的一个主要原因。</p>
<p>既然如此，那么我们为什么还要推崇相对论和量子力学这些极易导致现代神话出现的理论呢？这些理论的用处并不是制造神话。测量地球上的日常运动，可以用牛顿力学。测量天体的「日常」运动，可以用相对论。测量电子的运动，可以用量子力学。这些理论提供了精确的测量方法。倘若你对事物并不追求太过于精确的测量，那么一些人的哲学对你而言就够用了。倘若你连粗略的测量都不需要，那么宗教性的神学对你而言也够用了。你所期望的知识的深度，取决于你是否对某些事物有精确测量之意。神话、哲学及至科学，事实上并无矛盾可言，它们反映的仅仅是人类对自己所生存的这个世界认知的精确程度的递进性。</p>
<p>相信神学，无非是相信：我们对世界进行了超级粗略的测量，测量结果是上帝，然后我们只需要给它磕头就可以幸福地活下去。相信哲学，无非是相信：我们对这个世界进行了一些粗略的测量，测量结果是万物的本体是原子和虚空，或者是世界精神不断趋向于了解其自身的方向发展，或者是生产力与生产关系之间的矛盾推动了历史的发展……相信科学，无非是相信：科学能够帮助我们预测这个世界接下来会发生一些什么具体的事情。量子力学将概率论引入科学殿堂，并不是教导我们世界的不确定性，而是要用概率论更精确地计算电子出现的位置。可是，一旦相信概率论，就变成了，相信世上的一切都存在着不确定性了……</p>
<p>一切知识，是人类对世界测量结果的总和。这里面也包含着亲情、爱情以及友情之类似乎无法测量之事。以爱情为例，一个人若是觉得自己爱上了另一个人，是因为他/她通过一些并不精确地测量，发现世上虽然有那么多人，却只有这么一个人对自己有着一种最为特殊的含义——至于这个含义是什么，需要搞得那么清楚么？我测量了她，结果是爱或不爱，这与月老和丘比特无关，与是否相信爱情也无关。</p>
<p>倘若一个人有一些很想去解决的问题，而现有的部分知识能够对他有所帮助，那么问题的解决并非是他相信这些知识，而是他在利用这些知识。若没有具体的问题，单纯去讨论知识有没有用处，或者用一种知识去否定另一种知识，皆可视为荒唐之举。</p>
<p>普通的尺子，游标卡尺，激光测距仪，电子显微镜，哪个更好呢？难道不是要看你打算测量什么而定么？中医和西医，哪个更好呢？若有机会在城市里就医，那么西医会更好一些；否则，中医会更好一些。当苦苦思念一个人的时候，她随便的一句话，也能作为续命的良药。跳大神，有时也是能治病的，而且成本远低于现代医学，主要是因为它能够治疗那种本不存在但病人以为存在的病。</p>
<p>在使用一些知识解决一些问题过程中，我们对所用的知识的态度，称为信仰。譬如，有人毕生为某些问题所困，他觉得唯有信奉上帝方能帮助自己解决这些问题。不久以前，我会嘲笑他的愚昧，但现在觉得这实在是一种常态。不过，到底有什么事，是信奉上帝能解决，而信奉科学就解决不了的呢？这样的事，我想不出来。在我看来，上帝能办到的事，科学也能，而科学办不到的事，上帝也办不到。可是，为什么会有这么多的人会相信唯有上帝能帮他们，而科学却无能为力？</p>
<p>原因可能出在两个方面。一方面是，并没有把问题本身搞清楚；另一方面，对于解决问题所需要的成本的估算出现了太大偏差——那些利令智昏的事，我们早已屡见不鲜了吧。对于一些自己没搞清楚的问题，信仰上帝，所需要的成本，无非是找个供奉神灵的场所，跪下来，心口合一，大慈大悲救苦救难观世音菩萨保佑……成本自然是远远低于学习微积分、线性代数、概率论、实变函数、复变函数等科目以及进而学习物理、化学、生物等科目，因为对这些科目的学习，往往要十年的光阴，更何况，学了这些科目，对于自己要解决的问题，真的会有帮助吗？——尽管这样问的时候，发问者几乎不会再去思考自己是不是把问题本身搞明白了。</p>
<p>对于任何一个人而言，如何把问题搞清楚，如何合理估算解决问题的所需成本，又如何矢志不渝地践行将自己思考出来的解决方案，这三件事，单纯通过对某些知识或技术的勤学苦练，是解决不了的，因为知识和技术是人类对自身所生存的世界的测量结果，而不是对这个人的测量结果——绝大多数知识和技术先于这个人而存在。因此，何谓自我？每个人都有自我，但是诸多的自我之间的主要区别在于如何去完成这三件事。把前两件事做好了，就叫有智慧，叫仁也成。把第三件事做好了，就叫勇敢，叫义也成。</p>
<p>智慧和勇敢，既非与生俱来，亦非他人所能传授，得到它们，实在是靠自明。譬如，对于如何把问题搞清楚这件事，我实在没法给他人一个能做好这件事的办法，因为我自己都有许多问题没搞清楚。不过，我倒是可以试着举出一些明显未能把问题搞清楚的例子。</p>
<p>假设我是个穷人，在世人看来活得实在是失败——事实上也无需作此假设，现在我将如何成为有钱人作为一个问题，而且认为这是一个很明确的问题，并不需要把它搞清楚，接下来，我只要去挣钱就可以了。真正的问题是这个么？</p>
<p>真正的问题至少应该首先去问，为什么我会这样的穷？然后至少先去回答，因为我把我的精力耗费在一些与挣钱没有太大关系的事情上了。譬如，写这样一篇文章，它甚至不可能给我带来一分钱的收入，而我却用一整天去写它。倘若，我这一天的时间用来同小区拾荒的老爷子竞争，把小区的垃圾桶里能卖点钱的东西抢先翻捡出来，至少能挣 10 块钱吧？考虑到，我已经耗费了差不多十年的光阴，就按每天挣 10 块钱来算，那么就相当于我少挣了 36500 块钱。虽然不算大钱，也够我一个人 3 年的生活开支了。</p>
<p>不过，从另一个角度来说，现在凡是把这篇文章读到这里的人，看到的是我耗费了 36500 块钱写出来的东西——当然，你有权力觉得它一文不值，但是 0 块钱也比 -36500 块钱多很多。这样来看，我是有钱人，并不失败。当年，英国有个资本家，他就花了不少钱资助了一个哲学家写了本书，叫《资本论》。</p>
<p>当我觉得把这个问题想清楚的时候，问题自己就消失了，亦即我动用了我的智慧，通过一个 0 成本的办法，勇敢地解决了这个困扰我很久的问题……好了，其实你大可以忍住，不要去对我说「你高兴就好」之类充满了同情式的贬义之语，类似鲁迅摸了摸阿 Q 的头。再者，我觉得你甚至应该对我表示一点感谢，感谢我没有把耗费了 36500 块钱的精力投入到你所在的工作环境里和你去竞争。很久以来，我一直都很庆幸，这个世上竟然会有那么多的聪明人，没有跑到我这里同我竞争，否则，我连耗费 36500 块钱的机会都没有。</p>
<p>以上只是通过一个假设，以此阐明，要把问题想清楚，并不是太容易。有一个问题作为开始，那倒是很容易，但关键是要把问题持续地问下去，一直问到自己想方设法也再也问不下去了为止，想必，那时就会对解决这个问题所需要的成本，有着周详的考虑了，解决方案，想必，也差不多有了一些雏形了吧？</p>
<p>当我们去思考，如何实现时空穿越的时候，应该动用类比推理的办法，去考虑一下，如何把自己搬起来？倘若连这个问题都解决不了，那么，何必要在万一自己穿越到了过去把自己的祖母杀死了之类的问题上殚精竭虑？宇宙不会因为我们观测了电子通过哪条缝隙时分裂成两个，即便它的确这么干，但分裂方式也不会像我们所认为的那样，喀嚓就裂变成了两个。这些，算是不俗的思维游戏，然而，和孩子们玩过家家，不是同构的，也是同态的。</p>
<p><span id="智慧"></span></p>
<h2><a href="../posts/immuture-viewpoints.html#m4-TOC">20 智慧</a></h2>
<p>娃快 6 岁了，他妈妈给他报了一些兴趣班，绘画、口才、跆拳道、轮滑……他在跆拳道班里，得到老师的好评远多于其他班。于是，基本锁定了，跆拳道将来就算是他的一个兴趣吧，其他班看来都失败了。不过，让我觉得奇怪的是，没有哲学兴趣班。</p>
<p>在我看来，哲学这种极为无用的学问，按说最适合孩子们去学。老人也像孩子，应该也适合搞哲学。年富力强的人，应该去围猎，不应该躲在山洞里去思考与日常生活几乎毫无关系的任何问题。画画好的，可以画岩画，记录哪些猎物值得我们围追堵截。口才好的，可以当首领，负责开会，或者主持婚丧嫁娶。拳脚好的，可以维持部落治安。轮滑好的，可以送快递。唯独哲学是无用的。我们是谁，从哪里来，到哪里去……太阳为什么东升西落，月亮为什么有阴晴圆缺，每年为什么在固定的时间会变冷或变热……思考这些，有什么用呢？太阳那样升落，月亮那样圆缺，每年的天气那样变化，难道不是为了我们方便安排自己的生活而设计的吗？一切都是天意，我们只需解决好围猎、治安以及通信问题，然后享受我们的生活就好了，然而这些事情，对于一个孩子而言，却皆非他力所能及，他能做的任何事，都是无用的。</p>
<p>孩子最喜欢的事情应该是一些游戏，然而这些游戏实际上比哲学有用，至少父母们期望这些游戏对提升孩子的智慧有益。既然如此，那么不如试着教他一点哲学。部落里的老人也常说，哲学，是爱智慧。孩子长大了，无论他是当警察，还是当工人，还是文体两开花，应该都离不开智慧吧。天下父母，应该没有不希望自己的孩子充满智慧的……可是，为什么不把孩子送到哲学兴趣班呢？因为没有这样的班。因为成年人大多数也不懂什么是哲学，而那些哲学家呢，整天念叨一些经文式的咒语，谁也不懂他们到底在说什么，孩子们就更听不懂了。</p>
<p>好在，我曾经在众人外出围猎的时候，在山洞里偷懒的时候，想了一丁点哲学上的问题。我可以试着给娃讲一些，以备在不远的未来，他在劳动、体育、审美、道德等方面落后于他人的时候，能在智慧方面找补一些颜面回来。所以，成年人实在不应该因为某些知识不能让自己的生活变好就放弃学习，或停下思考。父母们，应该多拿出一些时间，陪孩子做一些无用的事。等孩子把无用的事做腻烦了，自然就会去做有用的事了。倘若从小就期望他们能在未来那些有用的事上抢先走几步，那么他们很有可能会在长大后去干许多无用的事。</p>
<p>我该怎样给娃讲哲学呢？先从《苏菲的世界》里的第一个问题开始吧，苏菲是在十四岁时才思考了这个问题，娃将会领先她九年。</p>
<p>我把正在玩积木的娃叫了过来，问他，你有没有想过，你是谁？</p>
<p>是你儿子。</p>
<p>不对……你有没有想过，我是谁？</p>
<p>是我爸爸。说完，娃很同情地摸了摸我脑门，像我以前嘲笑他乱说话时摸他脑门那样。</p>
<p>很失败，败给了语言。应该像维特根斯坦那样保持沉默吗？那岂不是意味着孩子连哲学这种无用的知识都学不会？一定有好办法，但前提是我需要理解哲学是什么。</p>
<p>哲学是「我是谁」这样的问题吗？当然不是，哲学里的一个问题，不能构成哲学本身。那么，哲学是所有哲学理论的集合吗？若说是，那么哲学就变成了哲学史，的确有不少哲学家持有这种见解，但是若说哲学即哲学史，这是否意味着哲学已死？为了让新哲学有机会存活，我们不得不矛盾地宣称，我们的活着，是在创造历史，为后人。这个提法很好，可依然阻止不了哲学步入坟墓的脚步，因为我们创造的历史越多，后人创造新历史的机会就越少，因为他们生命里很大一部分时间要用来学习前人的历史，自己创造历史的时间只会越来越少。历史，值得每个人去讨厌，它的存在，会让我们趋向于丧失明天。</p>
<p>否定哲学就是哲学史，等同于否定先哲们的种种思考吗？他们思考过的问题，我们还要重新思考吗？当我们阅读他们的著作时，期望得到什么？是肯定或批判他们的一些想法吗？他们已经死了很久了。我们需要相信先哲们提出来的与这个世界相处的办法可以改善我们的生活吗？我们真的觉得有必要让死去的人替我们作出一些重要的决定吗？一切问题似乎都可以变成哲学问题来研究，但是有人去研究哲学是什么吗？哲学真的到了难以和一个五岁的孩子讲明白的地步了吗？</p>
<p>哲学一词的本意是爱智慧。智慧，与聪明同义，有智慧的人，也可以叫做聪明人。可是，智慧又是什么？谁都期望自己有智慧，但是智慧似乎一直都是在少数人那里，在大家吃着同样的饭并且接受同样的教育面前，智慧像是少数人与生俱来之物，我们似乎只能将其归于神明抑或基因所赐，然后心安理得地做起了没什么智慧的人。不过，当聪明人骂我们是蠢货的时候，我们又觉得自己好像并不是他们所说的那么蠢，否则我们就不会那么容易愤怒，急于去证明自己不蠢。我相信，在获得智慧的能力上，所有的大脑正常的人是平等的。除非你别有用心地去装傻，否则不要随便就认为自己做不了聪明人。</p>
<p>要把问题勇敢地继续问下去，哲学家的智慧从何而来？回答这个问题，需要找两本书，一本是中国哲学简史，一本是西方哲学简史，可大致浏览——若觉得有趣，可以细细读完——，只需要弄清楚这么多的先哲，他们所思考的问题是什么，至于他们如何去思考以及得出的结论是什么，无需在意。这样，很快就会发现，他们思考的那些问题，范畴很大，往往是我们很少甚至拒绝去思考的。不完全是我们过于功利，因小失大。我们有太多的机会放弃思考大的问题，譬如看了一些先哲的书，觉得他们的见解很有道理，而自己一时也想不出更好的理论，于是便主动放弃了思考，换言之，是我们用崇拜或信仰扼杀了独立思考的幼苗，转而认为只需要努力学习先哲们给出的结论就好了。</p>
<p>我们在说自己也会独立思考的时候，不妨认真核实一番，我们内心的里涌现的声音究竟有多么的混乱吧，然后再确认一下，这些声音里有多少是自己的？最后确认一下，自己是否存在。再想一下，为什么笛卡尔要以自我的存在作为他的所有思考活动的基本原理。</p>
<p>学习，不仅不会令人变得有智慧，反而更有可能令人距离智慧越来越远，故而老子会说，为学日益，为道日损。那么，不学习就会有智慧了吗？老子难道不是在说，应当努力学习，然后对所学予以简化吗？简化到了无法再简的程度——损之又损，以至于无为，无为而无不为。哲学家、数学家以及物理学家们给出的结论往往是简单的，然而智慧并不在他们的结论里，而是来自于他们的思考过程。但是，他们的思考过程都是相同的吗？他们是有着同样或类似的智慧，还是谁比谁更有智慧？亚里士多德在物理学上有着错误的结论，现在的中学生都会觉得亚里士多德是错的，是否可以据此说亚里士多德还不如现代的中学生吗？对于这些问题，若答案为否，那么这些在我们看来有着超出常人的智慧的人，他们的思考过程有什么相似之处？显然，唯一的共同之处是，他们对于对大的问题的保持着长期一致性的思考。</p>
<p>弄清楚这些，依然无助于给娃讲哲学。因为对于现在的他而言，没什么问题比我过年时送他什么玩具更大的了。为了持久地思考下去，必须在现有思考的基础上提出新的问题。我能想到的一个问题是，为什么大的问题有助于维持思考的进行？导致我提出这个问题的原因恰好是它的答案。</p>
<p>现在，我已经知道了如何给娃讲哲学了。</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/bash.html" class="u-url">写给高年级小学生的《Bash 指南》</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/bash.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-11-27T17:04:06+08:00" itemprop="datePublished" title="2018-11-27 17:04">2018-11-27 17:04</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>若让计算机理解我的意图，可以有两种方式，说和指。这与生活中我为了让他人能够理解我的意图所采用的方式相似。譬如，我想让朋友去超市帮我买瓶饮料，我可以使用祈使句，「帮我去超市买瓶可乐，如何？」我也可以把他领到超市门口，指一下超市，然后再把他领进超市，指一下饮料柜里的一瓶可乐，然后再指一下他口袋里的钱包。基于说的方式让计算机理解我的意图，就是向计算机输入一些命令，计算机则通过命令解释程序理解我的意图。基于指的方式让计算机理解我的意图，就是通过鼠标、触摸屏之类的交互设备，向计算机输入一些坐标信息，计算机则通过图形界面程序理解我的意图。</p>
<p>在生活中，人们通常会喜欢通过说的方式让他人理解自己的意图，只有在难以言说的时候，才会考虑用指的办法。这是因为我们已经掌握了一门与他人沟通交流所用的语言，利用这种语言让他人理解我们的意图，是成本最低的方法。但是对于计算机而言，由于大多数人通常没有机会学习计算机可以理解的语言，因此对于他们而言，采取指的方式让计算机理解他们的意图则是成本最低的方法。因为这个缘故，大多数人喜欢以图形界面交互的方式使用计算机，因为他们觉得学习一门计算机语言，成本太高。倘若将一门计算机语言列入小学课程，或许孩子们长大后与计算机的沟通便不再像现代人这样过度依赖图形界面交互方式。</p>
<p>图形界面与命令并不冲突。我们教孩子说话，一开始也是以指物的方式，让孩子获得了基本的语言交流能力，在这个基础上再教他们识文断字。图形界面程序为计算机的普及作出了很大贡献，但是在这个基础上，若想让计算机更准确、高效地理解我们的意图，同时也能让他人更准确、高效地理解我们的意图，便需要学习一门计算机语言了。</p>
<p>计算机语言不像人类语言那样丰富。因此，不要指望我们冲着计算机喊几嗓子，或者在运行着命令解释器的终端（命令行窗口）里输入「帮我写毕业论文」这样的句子，计算机就能够充分理解我们的意图，转而毫无怨言地去工作。至少直至目前，我们的计算机尚不具备这样的功能。不过，我们可以通过付费的方式，对那些擅长计算机语言的人喊几嗓子，或者给他们发几条微信。倘若想亲历亲为，而且认为与计算机这样的机器进行交流像是在玩一种文字意义上的游戏，那么便可以从学习一种命令解释程序入手，学习这个程序所支持的语言以及一些常用的命令。</p>
<h2>Bash 语言</h2>
<p>若打算学习计算机语言，不妨从 Bash 语言入手，把它作为「母语」。</p>
<p>Bash 是一个命令解释程序，用于执行从标准输入或文件中读取的命令。能被 Bash 理解的语言即 Bash 语言。像 Bash 这样的程序通常称为 Shell，作为计算机用户操作计算机时的基本交互界面，亦即计算机用户通过 Shell 使用操作系统内核所提供的种种功能。Bash 是众多 Shell 中的一种，但它却是流传最为广泛的 Shell。在 Windows 系统中，Windows 10 以前的版本可以通过<a href="https://liyanrui.github.io/posts/cygwin-installation.html">安装 Cygwin</a> 便可获得 Bash，而在 Windows 10 中，只需开启 WSL（Windows Subsystem for Linux）便有了 Bash。至于 Linux 和 Mac OS X 系统，Bash 则是它们的核心标配组件。Android 手机上，通过 <a href="https://f-droid.org/">F-Droid</a> 安装 Termux 也能得到 Bash。</p>
<p>因为 Bash 几乎无处不在，而且它能够帮助我们处理许多计算机里的日常任务，所以不妨把它作为计算机世界里的母语去学习。计算机语言虽然种类繁多，但是用这些语言写的程序，通常可以作为命令在 Bash 或其他某种 Shell 环境中运行，这种做法颇类似于我们在母语的基础上学会了一些专业里的「行话」。</p>
<p>事实上，在熟悉了 Bash 语言以及一些常用的命令之后，经常可以发现，很多人用其他编程语言所写的那些程序实际上没必要写，因为这些程序很有可能只需要一条 Bash 命令便可以实现了。譬如，你在撰写文档的时候，有时可能会想使用直角引号<code>「</code> 和 <code>」</code>，而非 <code>“</code> 和 <code>”</code>，但是自己所用的中文输入法里可能并不是很方便输入 <code>「</code> 和 <code>」</code>，这时该怎么办呢？没有多少好办法，除非你对这个输入法足够了解，去修改它的码表，为键盘上的 <code>"</code> 键与 <code>「</code> 和 <code>」</code> 建立映射。对于 Bash 而言，如果你的文档能够表现为纯文本的格式，假设文件名为 foo.txt ，那么你大可以继续使用 <code>“</code> 和 <code>”</code>，只需在文档定稿后，使用 <code>sed</code> 命令将 <code>“</code> 和 <code>”</code> 替换为  <code>「</code> 和 <code>」</code>，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> sed -i <span class="s1">'s/“/「/g; s/”/」/g'</span> foo.txt
</pre>


<p>已经习惯了图形界面交互方式与计算机沟通又抗拒学习计算机语言的人可能会抬杠，「我在微软 Word 里也可以用『查找/替换』的方式来完成你这条命令所能完成的任务啊！」诚然如此，但是如果手上不止有一份文件，而是有一组文件 foo-1.txt、foo-2.txt、foo-3.txt……需要作引号替换处理呢？难道要用微软 Word 逐一打开这些文件，然后作「查找/替换」处理，再逐一保存么？倘若这样做，就相当于是计算机在使用人，而非人使用计算机。对于 sed 命令而言，将某项文本处理过程作用于多份文件与作用于一份文件并无太大区别。若对 foo-1.txt、foo-2.txt、foo-3.txt……进行引号替换，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> sed -i <span class="s1">'s/“/「/g; s/”/」/g'</span> foo-*.txt
</pre>


<p>庄子说，「指穷于为薪。火传也，不知其尽也。」倘若将「引号替换」视为「火」，那么用微软 Word 逐一打开文件，进行引号替换处理，再将处理后的文件保存起来，这种做法就是「指穷于为薪」，即使你很敬业，很努力，但是这样去做一辈子，在 sed 看来也只是完成了它在一瞬间就能做到的事。庄子若活到现在，一定是一个善于用计算机语言编程的人。</p>
<h2>终端</h2>
<p>心里至少要有一团光，哪怕它很微弱，只是来自一根火柴。在这样的微光里，看到的是世界是一片寂静的混沌，至少也是全貌。我的桌子上总是有一盒火柴，作为对童年爱放野火的冬天的怀念。我取出一根火柴，让它的头部迅捷有力地擦过磷纸，小小的火焰喷射而出，引燃了它的身体。我要带着这团火焰，进入一个诡异的黑暗世界，它的名字叫终端。</p>
<p>终端是 Shell 的界面，人通过终端输入命令。Shell 从终端接到命令，然后理解命令，执行命令。不要忘记，Bash 是诸多 Shell 中的一种。</p>
<p>在这个世界里，持着光，我注意的第一个东西是「<code>$</code>」，它的右面是一个不断明灭的矩形块，顶部是「<code>~</code>」。「<code>$</code>」称作命令提示符。闪烁的矩形块表示可以在此输入命令。「<code>~</code>」是我当前所在的位置——硬盘里的某个目录，亦即当前目录或当前工作目录。实际上 <code>~</code> 不过是 Bash 对我的个人主目录给出的简写，它的全称是「<code>/home/garfileo</code>」。倘若我此时正处于<code>/tmp</code> 目录，那么<code>$</code> 的顶部应当是「<code>/tmp</code>」。</p>
<p><img alt="" src="../images/bash/01.png"></p>
<p>对于终端的初始印象，你与我或许不同。若想看到我所看到的，需要在 ~/.bashrc 文件里添加</p>
<pre class="code literal-block"><span></span><span class="nv">PS1</span><span class="o">=</span><span class="s2">"\e[0;32m\w\e[0m\n</span>$<span class="s2"> "</span>
</pre>


<p><code>\e[0;32m</code> 和 <code>\e[0m</code> 皆为 Bash 世界里的颜色值，前者表示绿色，后者表示无色；当二者之间出现 <code>\w</code> 时，所产生的效果是设定 <code>\w</code> 为绿色，但是不影响 <code>\w</code> 以外的字符。<code>\w</code> 表示当前目录。<code>\n</code> 表示换行。这种咒语级的代码，足以令很多人望 Bash 而生畏或生厌了。不必担心，这样的咒语并不经常需要念。</p>
<p>倘若我在 ~/.bashrc 文件里删除上述对 <code>PS1</code> 的设定，那么我对终端的初始印象应当是 <code>$</code> 的顶部没有东西，左侧是「<code>garfileo@zero ~</code>」，右侧是那个不断明灭的矩形块。或许你会喜欢我对 <code>PS1</code> 所作出的上述设定，特别是在你企图在命令提示符的右侧输入很长的命令之时。</p>
<h2>echo</h2>
<p>初次使用 Bash，也许尚不知如何向 ~/.bashrc 文件添加</p>
<pre class="code literal-block"><span></span><span class="nv">PS1</span><span class="o">=</span><span class="s2">"\e[0;32m\w\e[0m\n</span>$<span class="s2"> "</span>
</pre>


<p>不过，现在运行 Bash 的操作系统大多提供了图形界面。可以图形界面式的文件管理器里找到 .bashrc 文件，然后使用一种图形界面式的文本编辑器打开这份文件，添加上述内容，然后再保存文件。这是我们刚开始使用计算机的时候就已经学会了的方法。但是，从现在开始可不必如此，因为类似的任务通过一些简单的命令便可完成。例如，要完成上述任务，只需在终端的命令提示符后输入</p>
<pre class="code literal-block"><span></span><span class="nb">echo</span> <span class="s1">'PS1="\e[0;32m\w\e[0m\n$ "'</span> &gt;&gt; ~/.bashrc
</pre>


<p>然后回车。之后，Bash 便会对我们输入的这一行文本予以理解和执行。我们输入的这行文本便是命令。</p>
<p><code>echo</code> 命令可将一行文本显示于终端。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'PS1="\e[0;32m\w\e[0m\n$ "'</span>
</pre>


<p>Bash 执行这条命令之后，终端紧接着便会显示</p>
<pre class="code literal-block"><span></span><span class="go">PS1="\e[0;32m\w\e[0m\n$ "</span>
</pre>


<p>就像是对空旷寂静的山谷喊了一声「<code>PS1="\e[0;32m\w\e[0m\n$ "</code>」，然后山谷给出了回音，<code>echo</code> 命令得名于此。亦即，<code>echo</code> 只是将它所接受的文本不加改变地输出。</p>
<p><img alt="" src="../images/bash/02.svg"></p>
<p><code>echo</code> 本身是无用的。但是，当它的后面出现了 <code>&gt;&gt; ~/.bashrc</code> 时，它的输出便会被 <code>&gt;&gt;</code> 强行导入 ~/.bashrc 文件，此时没用的 <code>echo</code> 便发挥了作用。天生我材必有用。</p>
<p><code>&gt;&gt;</code> 是输出重定向符，因为它可以将一个命令的输出导向到指定的文件。当 <code>&gt;&gt;</code> 在 <code>echo</code> 命令之后出现时，它是如何得知 <code>echo</code> 命令的输出的呢？对我们而言，<code>echo</code> 命令的输出是在终端里呈现出来的，难道 <code>&gt;&gt;</code> 也能像我们这样「看到」终端里的内容么？</p>
<p>我们看到的，并非全部。我们所看到的 <code>echo</code> 的输出，实际上是 <code>echo</code> 在一份文件里写入的内容，这份文件的名字叫 stdout（标准输出）。终端从 stdout 读取内容并显示于屏幕。<code>&gt;&gt;</code> 也能从 stdout 读取内容并写入其他文件。这些是我们看不到的部分。</p>
<h2>输入/输出重定向</h2>
<p>在终端的命令提示符后输入</p>
<pre class="code literal-block"><span></span><span class="nb">echo</span> <span class="s1">'PS1="\e[0;32m\w\e[0m\n$ "'</span> &gt;&gt; ~/.bashrc
</pre>


<p>然后回车。Bash 是如何得到这行文本并将其作为命令予以执行的呢？依然是通过一份文件。这份文件的名字叫 stdin（标准输入）。我们在终端里输入任何信息，本质上都是在向 stdin 写入内容。当我们输入一行文本回车时，Bash 便开始读取 stdin 里的内容，把它们理解为一条命令或一组命令的组合，然后予以执行。</p>
<p>对于 <code>&gt;&gt;</code> 指向的文件（命令中位于 <code>&gt;&gt;</code> 右侧的文件），<code>&gt;&gt;</code> 是不改变其原有内容的前提下将 stdout 中的内容写入该文件，亦即向该文件尾部追加信息。若期望用 stdout 中的内容替换该文件的原有内容，可使用 <code>&gt;</code>。例如（仅仅是个例子，不要真的去这样做）：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'PS1="\e[0;32m\w\e[0m\n$ "'</span> &gt; ~/.bashrc
</pre>


<p>执行这条命令之后，~/.bashrc 文件的全部内容便会被替换为「<code>\e[0;32m\w\e[0m\n$ "</code>」。</p>
<p>任何命令，只要它能够向 stdout 输出信息，其输出皆能通过 <code>&gt;</code> 和 <code>&gt;&gt;</code> 写入到指定文件。倘若所指定的文件不存在，Bash 会自动创建。因此，不妨将 Bash 的输出重定向符视为对各种文本编辑器或字处理软件的「文件（File）」菜单里的「另存为（Save as）」功能的抽象。</p>
<p>Bash 也提供了输入重定向符 <code>&lt;</code>，可将其视为对各种文本编辑器或字处理软件的「文件（File）」菜单里的「打开（Open）」功能的抽象。任何命令，只要它以 stdin 中的信息作为输入，皆能通过 <code>&lt;</code> 将指定文件中的信息作为输入，因为 <code>&lt;</code> 可将指定文件中的信息写入 stdin。例如，Bash 将 stdin 中的信息视为命令予以执行，倘若将某条命令写入一份文件，然后通过 <code>&lt;</code> 将该文件作为 Bash 的输入，所产生的效果是，Bash 会将这份文件中的内容视为命令并予以执行。以下命令模拟了这一过程：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'echo "Hello world!"'</span> &gt; /tmp/foo.sh
<span class="gp">$</span> bash &lt; /tmp/foo.sh
<span class="go">Hello wrold!</span>
</pre>


<p>在 Bash 中，可以执行 <code>bash</code> 命令，这一点细想起来会有些奇怪。不过，人类不是也经常将「自我」作为一种事物去思考么？</p>
<p>实际上，上述 <code>bash</code> 命令中的输入重定向符是不必要的。因为 <code>bash</code> 命令原本便支持直接读取指定文件中的内容并将其视为命令予以执行，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> bash /tmp/foo.sh
</pre>


<p>输入重定向符主要面向那些只支持从 stdin 获取输入信息的程序，例如，用于计算凸包的程序 qhull 便是这样的程序。倘若机器上已经安装了 qhull 软件包，可以使用 <code>rbox</code> 命令生成含有三维点集的数据文件，然后通过 <code>&lt;</code> 将数据文件中的三维点集信息传递于 <code>qhull</code> 程序：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> rbox c &gt; points.asc
<span class="gp">$</span> qhull s n &lt; points.asc
</pre>


<p>之后，<code>qhull</code> 便会输出三维点集的凸包信息。</p>
<h2>管道</h2>
<p>认真观察</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'echo "Hello world!"'</span> &gt; /tmp/foo.sh
<span class="gp">$</span> bash &lt; /tmp/foo.sh
</pre>


<p>和</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> rbox c &gt; points.asc
<span class="gp">$</span> qhull s n &lt; points.asc
</pre>


<p>这两组命令是否相似？在形式上，它们都是一条命令通过输出重定向将自己原本要写入 stdout 的输出信息被重定向到了一份文件，另一条命令则是通过输入重定向将自己原本要从 stdin 里获取的输入信息变成了从指定文件中获取。这个过程类似于，你将信息写到了纸条上，然后又将纸条扔给我看。但是在生活中，我们通常不会这样麻烦，你会用嘴巴发出信息，我则用耳朵接受信息。Bash 也有类似的机制，名曰管道。基于管道，上述两组命令可简化为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'echo "Hello world!"'</span> <span class="p">|</span> bash
<span class="gp">$</span> rbox c <span class="p">|</span> qhull s n
</pre>


<p>只要一条命令能通过 stdout 输出信息，而另一条命令能通过 stdin 获取信息，那么这两条命令便可以借助管道连接起来使用。说话要比写字快，而且能够节省纸张，管道的意义与之类似，不仅提高了信息的传递速度，而且不消耗硬盘。</p>
<h2>cat， mv 和 sed</h2>
<p>通过 <code>&gt;&gt;</code> 能够实现向一份文本文件尾部追加信息。有没有办法向一份文本文件的首部追加信息呢？这个问题并不简单。在生活中，有许多事需要我们排队。来得晚了，应当主动站在队尾，这样做不会影响对于早来的人。但是，若来得晚了，反而强行站到队伍的前面去了，可能会被挨打。也许我们都喜欢插队，但是却很少有人喜欢插队的人。所谓文件，事实上不过是一组排好了队的字节。因此，通过 <code>&gt;&gt;</code> 向一份文本文件尾部追加信息容易，但是若将信息插入到文件的首部，原有的文件内容在硬盘里的相应位置必然要发生变化。</p>
<p>假设文件 foo.tex 的内容为</p>
<pre class="code literal-block"><span></span><span class="k">\starttext</span>
这是一份 ConTeXt 文稿。
<span class="k">\stoptext</span>
</pre>


<p>若想将「<code>\usemodule[zhfonts]</code>」增加到这份文件的首部，可通过以下命令实现：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'\usemodule[zhfonts]'</span> &gt; foo-tmp.tex
<span class="gp">$</span> cat foo.tex &gt;&gt; foo-tmp.tex
<span class="gp">$</span> mv foo-tmp.tex foo.tex
</pre>


<p><code>cat</code> 命令用于将多份文本文件的内容连接起来，并将结果写入 stdout。当 <code>cat</code> 只处理一份文本文件时，产生的效果是将这份文件的内容写入 stdout。由于 stdout 中的内容可通过 <code>&gt;&gt;</code> 导入到指定文件，因此上述的 <code>cat</code> 命令所起到的作用相当于把 foo.tex 的内容复制出来，并追加到 foo-tmp.tex 的尾部。</p>
<p><code>mv</code> 命令可将文件从其当前所在目录移动到另一个指定目录，倘若这个指定目录依然是当前目录，那么 <code>mv</code> 命令便起到了文件重命名的效果。上述 <code>mv</code> 命令将 foo-tmp.tex 重命名为 foo.tex。最终得到的 foo.tex，便等价于在其原有的内容首部插入了「<code>\usemodule[zhfonts]</code>」。</p>
<p>不过，能够运行 Bash 的环境，大多也提供了擅长处理文本编辑任务的 sed 程序。与 Bash 相似，sed 也能执行它能够理解的一组命令，这组命令专事于文本的编辑。例如，如果将</p>
<pre class="code literal-block"><span></span>'1 i \
\\usemodule[zhfonts]'
</pre>


<p>传递于 <code>sed</code>，并指使 <code>sed</code> 将此命令作用于 foo.tex，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> sed -i <span class="s1">'1 i \</span>
<span class="s1">&gt; \\usemodule[zhfonts]'</span> foo.tex
</pre>


<p><code>sed</code> 便会这条命令理解为，在 foo.tex 的第 1 行插入「<code>\\usemodule[zhfonts]</code>」。</p>
<p>注意，上述的 <code>&gt;</code> 符号并非输出重定向符，它是终端的二级命令提示符。在终端中输入多行文本构成的命令时，终端自动给出二级命令提示符。还记得 <code>$</code> 吧，之前将其称为命令提示符，实际上它是一级命令提示符，这也正是为何用于设定它的格式时是通过 <code>PS1</code> 的原因。类似地，可以通过 <code>PS2</code> 来定制二级命令提示符的格式。Bash 如何知道我们要输入多行文本呢，亦即在我们输完 <code>sed -i 'i 1 \</code> 并摁了回车键之后，为何 Bash 不认为我们已经将命令输入完毕呢？这是因为在上述命令中，在第一行的末尾出现的 <code>\</code>，会被 Bash 理解为续行符。回车键产生的换行符位于续航符之后，会被 Bash 忽略。</p>
<p>利用续行符，可将较长的命令分成多行输入，Bash 会将最后一行的换行符作为命令输入完毕的信号。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'echo "Hello world!"'</span> <span class="se">\</span>
&gt;  <span class="p">|</span> bash
</pre>


<p>这条命令虽然不长，但是足以说明续行符的用法。</p>
<p>不过，上述的 <code>sed</code> 命令的第一行虽然在末尾出现了续行符，但实际上 Bash 是没有机会得知该续行符的存在。因为 sed 程序所接受的命令文本是拘禁在一对单引号中的，这种形式的文本叫做单引号字串。单引号字串中的续行符和换行符，Bash 会不予理睬。因此，上述的 <code>sed</code> 命令的第一行末尾的 <code>\</code>，实际上并非面向 Bash 而存在，「<code>i \</code>」实际上是 sed 程序的一个指令，用于在指定的文本行之前插入一行或多行给定的文本。因为 <code>\</code> 对于 sed 程序有着特殊含义，因此在通过 <code>sed</code> 命令在 foo.tex 的首部添加「<code>\usemodule[zhfonts]</code>」时，必需对文本中的 <code>\</code> 进行转义，由于 sed 程序是以 <code>\</code> 为转义符，因此在 sed 命令中，「<code>\usemodule[zhfonts]</code>」必须写成「<code>\\usemodule[zhfonts]</code>」。</p>
<p>至此，是否觉察到了 Bash 语言的混乱之处？</p>
<h2>引号</h2>
<p>命令的输入数据和输出数据只有两种，文本与存储文本的文件。Bash 如何对它们予以区分呢？Bash 规定，凡出现在一对双引号 <code>"</code> 或出现在一对单引号 <code>'</code> 之内的文字便是文本，否则便是文件。不过，我们向 Bash 提交的一切皆为文本。为了进行区分，应当将作为命令的输入或输出数据的文本称为字串，并且出现在一对 <code>"</code> 之内的字串可称为双引号字串，出现在 <code>'</code> 之内的字串则称为单引号字串。</p>
<p>问为什么会有两种字串，不如问为什么人类发明的文字里要有两种引号。在与他人的对话中，彼此所说的每句话可以用双引号包围起来。例如：</p>
<pre class="code literal-block"><span></span>我：“最近我在读《齐物论》。”
你：“它讲了什么？”
我：“庄子建议我们应当‘为是不用而寓诸庸’。”
</pre>


<p>单引号可以出现在双引号里，这意味着什么？意味着双引号更为宽松，而单引号则比双引号更为紧致。宽松的可以包含紧致的。对于 Bash 而言，双引号字串的宽松体现为，双引号字串中如果含有一些对于 Bash 有特殊含义的字符，Bash 会使用这些字符的含义代替这些字符。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$PS1</span><span class="s2">"</span>
</pre>


<p>倘若期望这条 <code>echo</code> 命令能够输出 <code>$PS1</code>，那么结果就会令人失望了。这条命令输出的并非 <code>$PS1</code>，而是一开始我们在 ~/.bashrc 文件中为 <code>PS1</code> 所设定的「<code>\e[0;32m\w\e[0m\n$</code>」。</p>
<p>单引号比双引号更为紧致，它可以阻止 Bash 对 <code>$PS1</code> 有其自己的理解。因此</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'$PS1'</span>
</pre>


<p>的输出结果方为「<code>$PS1</code>」。</p>
<p>前文中的示例</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s1">'echo "Hello world!"'</span> <span class="p">|</span> bash
</pre>


<p>其中，双引号字串是放在单引号字串之内的，这与上述我虚拟的关于《齐物论》的对话中所用的引号的用法有所不同，但是在 Bash 语言中，只能这样去写。倘若将上述命令写成</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"echo 'Hello world!'"</span> <span class="p">|</span> bash
</pre>


<p>Bash 对字串中出现的 <code>!</code> 会有特殊的理解，因为 <code>!</code> 是 Bash 命令，想不到吧？</p>
<p>字串中若出现引号，需要使用 <code>\</code> 对引号进行转义。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"I say: \"Hello world!\""</span>
</pre>


<p>Bash 会认为 <code>echo</code> 的输入数据是「<code>I say: "$hello"</code>」。倘若去掉转移符 <code>\</code>，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"I say: "</span><span class="nv">$hello</span><span class="s2">""</span>
</pre>


<p>Bash 会认为 <code>echo</code> 的输入数据为</p>
<ol>
<li><code>I say:</code></li>
<li><code>$hello</code></li>
<li>空字串</li>
</ol>
<p>在双引号字串中，为避免 Bash 对某些我们期望保持本义的字符产生误解，通常需要用转义符 <code>\</code> 让 Bash 放弃这样的尝试。</p>
<h2>变量</h2>
<p><code>PS1</code> 是一个名字，「<code>\e[0;32m\w\e[0m\n$</code>」是它指代的对象，<code>$PS1</code> 是引用这个对象。Bash 允许我们以这样的方式对数据予以命名，而后以名字指代数据。例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">hello</span><span class="o">=</span><span class="s2">"Hello world!"</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$hello</span>
</pre>


<p>与</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"Hello world!"</span>
</pre>


<p>等价。</p>
<p>名字，这是我们很熟悉的概念，但是在数学和编程中，它不再叫名字，而是叫「变量」。为数据取一个名字，就是「定义一个变量」，而使用这个名字，叫做「变量的展开」或者「变量解引用」。很寻常的做法，一旦换了名目，就立刻令人觉得莫测高深了起来。</p>
<p>名字之所以被视为变量，肯定不是因为老子说过「名可名，非恒名」。变量的存在，首先是为了便于数据的重复使用。譬如，一旦定义了变量 <code>hello</code>，便可以在命令中重复地使用它。</p>
<p>其次，变量便于实现数据的复合，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"I say: \"</span><span class="nv">$hello</span><span class="s2">\""</span>
<span class="go">I say: "Hello world!"</span>
</pre>


<p>这条命令利用了双引号字串的宽松特性，实现了在字串中对变量进行解引用，从而起到了言语简约但意义完备的效果。</p>
<p>但是，变量最重要的用途应该是执一发而动全身。如果有许多条命令使用了 <code>hello</code> 这个变量，当我对它指代的数据进行更换时，所有使用 <code>hello</code> 变量的命令皆会受到影响。</p>
<p>注意，在定义变量时，等号两侧不能出现空白字符。例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">my_var</span> <span class="o">=</span> <span class="s2">"3"</span>
</pre>


<p>Bash 不会认为这条语句是在定义变量 <code>my_var</code>，反而会认为 <code>my_var</code> 是一条命令，而 <code>=</code> 和 <code>"3"</code> 是这条命令的输入数据。</p>
<h2>条件</h2>
<p>对于一个变量 <code>foo</code>，若不知它是否已定义，可在终端里唤它一下试试，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$foo</span>
</pre>


<p>倘若 <code>echo</code> 只是输出一个空行，便可以确定 <code>foo</code> 未定义。上述命令中，<code>echo</code> 输出了空行，因此 <code>foo</code> 未定义。</p>
<p>如果 <code>foo</code> 未定义，就给它一个定义，否则便对 <code>foo</code> 进行展开。像这样的任务，单凭查看 <code>echo</code> 的输出无法完成。不过，Bash 支持与「<code>若……则……否则……</code>」类似的语法。例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$foo</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">""</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> <span class="nv">foo</span><span class="o">=</span><span class="s2">"FOO"</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="nv">$foo</span><span class="p">;</span> <span class="k">fi</span>
</pre>


<p>或</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$foo</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">""</span> <span class="o">]</span>
<span class="gp">&gt;</span> <span class="k">then</span>
<span class="gp">&gt;</span>     <span class="nv">foo</span><span class="o">=</span><span class="s2">"FOO"</span>
<span class="gp">&gt;</span> <span class="k">else</span>
<span class="gp">&gt;</span>     <span class="nb">echo</span> <span class="nv">$foo</span>
<span class="gp">&gt;</span> <span class="k">fi</span>
</pre>


<p><code>[ "$foo" = "" ]</code> 是一条命令，用于测试 <code>"$foo"</code> 与 <code>""</code> 是否相同。<code>if</code> 可根据 <code>[ "$foo" = "" ]</code> 的结果控制 Bash 是执行 <code>foo="FOO"</code> 还是执行 <code>echo $foo</code>。</p>
<p>假设变量 <code>foo</code> 未定义，那么 <code>[ "$foo" = "" ]</code> 的结果是什么呢？为 0。假设变量 <code>foo</code> 已定义，那么 <code>[ "$foo" = "" ]</code> 的结果是什么呢？为非 0。如何得知 <code>[ "$foo" = "" ]</code> 的结果呢？显然这个结果不可能写在 stdout 里，否则我们可以从终端里看到这个结果，但事实上我们并不知道这个结果，而 <code>if</code> 却能知道。</p>
<p>事实上，每条命令在被 Bash 执行后，都会给出一个称作「命令的退出状态」的结果。Bash 内定的变量 <code>?</code> 便指代这个结果。因此，要查看一条命令的退出状态，只需在它结束后，立刻对 <code>?</code> 进行展开。例如</p>
<pre class="code literal-block"><span></span>$ <span class="o">[</span> <span class="s2">"</span><span class="nv">$foo</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">""</span> <span class="o">]</span>
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
</pre>


<p><code>[ "$foo" = "" ]</code> 的退出状态为 0，意味着 <code>"$foo"</code> 与 <code>""</code> 相同。倘若定义了 <code>foo</code>，</p>
<pre class="code literal-block"><span></span>$ <span class="nv">foo</span><span class="o">=</span><span class="s2">"FOO"</span>
$ <span class="o">[</span> <span class="s2">"</span><span class="nv">$foo</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">""</span> <span class="o">]</span>
$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</pre>


<p>那么 <code>[ "$foo" = "" ]</code> 的退出状态为非 0，意味着 <code>"$foo"</code> 与 <code>""</code> 不同。</p>
<h2>常用的测试命令</h2>
<p>由于 <code>[ "$foo" = "" ]</code> 是一条命令，因此必须注意，<code>[</code> 与其后的字符之间至少要空出一格，否则这条命令便写错了，Bash 会拒绝执行。<code>[</code> 和 <code>]</code> 所囊括的文本称为表达式。</p>
<p>在测试命令的表达式中， <code>=</code> 可用于比较两个字串是否相同，比较结果表现为测试命令的退出状态。类似地，<code>!=</code> 可用于比较两个字串是否不同。<code>=</code> 和 <code>！=</code> 皆为双目运算符，即参与运算的对象是两个。对于字串，也有单目运算符，例如 <code>-z</code>，用于确定字串长度是否为 0。事实上，<code>[ "$foo" = "" ]</code> 与 <code>[ -z "$foo" ]</code> 等价。</p>
<p>命令的输入/输出数据除了字串之外，还有文件。很多时候，也需要对文件进行一些测试。最为常用的是确定一份文件是否存在，单目运算符 <code>-e</code> 可满足这一要求。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">if</span> <span class="o">[</span> -e foo.txt <span class="o">]</span><span class="p">;</span> <span class="k">then</span> rm foo.txt<span class="p">;</span> <span class="k">else</span> touch foo.txt<span class="p">;</span> <span class="k">fi</span>
</pre>


<p>的含义是，若当前目录中存在文件 foo.txt，便将其删除，否则便创建一份空文件作为 foo.txt。<code>rm</code> 命令可用于删除文件或目录，<code>touch</code> 命令可用于创建给定文件名的空文件。类似命令有，<code>-d</code> 可用于确定文件或目录是否存在。<code>-s</code> 可用于确定文件存在并且内容为空。双目运算符 <code>-nt</code> 和 <code>-ot</code> 分别用于判断一个文件是否比另一个文件更新或更旧。</p>
<p>Bash 提供了许多测试运算，详情可查阅 <code>test</code> 命令的手册，方法是：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> man <span class="m">1</span> <span class="nb">test</span>
</pre>


<p>之所以要查阅 <code>test</code> 命令的手册，是因为 <code>[ 表达式 ]</code> 只是 <code>test</code> 命令的一种简洁的写法。事实上，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="o">[</span> -e foo.txt <span class="o">]</span>
</pre>


<p>与 </p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">test</span> -e foo.txt
</pre>


<p>等价。</p>
<p>在得知了 <code>man</code> 命令的存在之后，也许你会想查阅 <code>rm</code>，<code>touch</code> 等命令的手册。</p>
<h2>循环</h2>
<p>做 10 个俯卧撑。如何用 Bash 语言描述呢？有两种方式，一种是</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span> i &lt;<span class="o">=</span> <span class="m">10</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span><span class="p">;</span> <span class="k">done</span>
</pre>


<p>也可以写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span> i &lt;<span class="o">=</span> <span class="m">10</span><span class="p">;</span> i++<span class="o">))</span>
<span class="gp">&gt;</span> <span class="k">do</span> 
<span class="gp">&gt;</span>     <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span>
<span class="gp">&gt;</span> <span class="k">done</span>
</pre>


<p>或</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> <span class="o">((</span><span class="nv">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span> i &lt;<span class="o">=</span> <span class="m">10</span><span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> 
<span class="gp">&gt;</span>     <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span>
<span class="gp">&gt;</span> <span class="k">done</span>
</pre>


<p>执行这条命令后，继而终端便会显示</p>
<pre class="code literal-block"><span></span>第 1 个俯卧撑
第 2 个俯卧撑
第 3 个俯卧撑
第 4 个俯卧撑
第 5 个俯卧撑
第 6 个俯卧撑
第 7 个俯卧撑
第 8 个俯卧撑
第 9 个俯卧撑
第 10 个俯卧撑
</pre>


<p>另一种方式是</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">i</span><span class="o">=</span><span class="m">1</span>
<span class="gp">$</span> <span class="k">while</span> <span class="o">((</span>i &lt;<span class="o">=</span> <span class="m">10</span><span class="o">))</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span><span class="p">;</span> <span class="o">((</span>i++<span class="o">))</span><span class="p">;</span> <span class="k">done</span>
</pre>


<p>也可写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">i</span><span class="o">=</span><span class="m">1</span>
<span class="gp">$</span> <span class="k">while</span> <span class="o">((</span>i &lt;<span class="o">=</span> <span class="m">10</span><span class="o">))</span>
<span class="gp">&gt;</span> <span class="k">do</span>
<span class="gp">&gt;</span>     <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span>
<span class="gp">&gt;</span>     <span class="o">((</span>i++<span class="o">))</span>
<span class="gp">&gt;</span> <span class="k">done</span>
</pre>


<p>或</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">i</span><span class="o">=</span><span class="m">1</span>
<span class="gp">$</span> <span class="k">while</span> <span class="o">((</span>i &lt;<span class="o">=</span> <span class="m">10</span><span class="o">))</span><span class="p">;</span> <span class="k">do</span>
<span class="gp">&gt;</span>     <span class="nb">echo</span> <span class="s2">"第 </span><span class="nv">$i</span><span class="s2"> 个俯卧撑"</span>
<span class="gp">&gt;</span>     <span class="o">((</span>i++<span class="o">))</span>
<span class="gp">&gt;</span> <span class="k">done</span>
</pre>


<h2>算术表达式</h2>
<p>在 <code>for</code> 和 <code>while</code> 之后出现的 <code>((...))</code> 称为算术表达式。算数表达式可独立存在，也可以与 <code>if</code>、<code>for</code> 和 <code>while</code> 配合使用。</p>
<p><code>((a = 1))</code> 与 <code>a=1</code> 等价；算术表达式中的 <code>=</code> 两侧允许出现空格。</p>
<p>算数表达式中的比较运算可用于 <code>if</code> 语句。例如</p>
<pre class="code literal-block"><span></span>$ <span class="k">if</span> <span class="o">((</span><span class="m">3</span> &gt; <span class="m">1</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">"Yes"</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="s2">"No"</span><span class="p">;</span> <span class="k">fi</span>
Yes
$ <span class="k">if</span> <span class="o">((</span><span class="m">3</span> &lt; <span class="m">1</span><span class="o">))</span><span class="p">;</span> <span class="k">then</span> <span class="nb">echo</span> <span class="s2">"Yes"</span><span class="p">;</span> <span class="k">else</span> <span class="nb">echo</span> <span class="s2">"No"</span><span class="p">;</span> <span class="k">fi</span>
No
</pre>


<p>注意，<code>for</code> 循环结构中的算术表达式是由三个算数表达式构成，即</p>
<pre class="code literal-block"><span></span><span class="go">((表达式 1; 表达式 2; 表达式 3;))</span>
</pre>


<p>这种算术表达式只能在 <code>for</code> 循环结构中使用。表达式 1 在循环开始时被求值。表达式 2 是在每一轮循环之前被求值，求值结果可以控制循环停止的时机：若求值结果为 0，则循环停止，否则开始新一轮循环。表达式 3 是在每一轮循环结束后被求值。上一节的 <code>while</code> 循环便是对 <code>for</code> 循环表达式很好的解释。</p>
<p>可以像变量展开那样获得算术表达式的求值结果。例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="k">$((</span><span class="m">3</span> &gt; <span class="m">1</span><span class="k">))</span>
<span class="go">1</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="k">$((</span><span class="m">3</span> &lt; <span class="m">1</span><span class="k">))</span>
<span class="go">0</span>
</pre>


<p>务必弄清楚上述算术表达式的求值结果与命令退出状态的区别。</p>
<p>在 <code>test</code> 或 <code>[</code> 命令中，数字之间的相等以及大小比较，可以用 <code>-eq</code>、<code>-lt</code>、<code>-gt</code>、<code>-le</code>、<code>-ge</code>，分别表示相等、小于、大于、不大于以及不小于。因此，在使用 <code>test</code> 命令时，要清楚是数字的比较还是字串的比较。</p>
<h2>函数</h2>
<p>与变量是数据的名字相似，函数是过程的名字。所谓过程，即按照时间顺序给出一组命令，让 Bash 依序执行每条命令。</p>
<p><code>md5sum</code> 命令可以算出给定文件的 MD5 码。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> md5sum foo.jpg
<span class="go">95e25f85ee3b71cd17c921d88f2326bf  foo.jpg</span>
</pre>


<p>文件的 MD5 码，类似于我们的指纹。不同的人，指纹相同的概率很小。不同的文件，MD5 码相同的概率也很小。许多网站在收到用户上传的图片之后，会以图片文件的 MD5 码作为图片文件的名字，以此避免同样的图片存入数据库中，从而达成节省硬盘空间的目的。我们可以构造一个过程，将一份文件以它的 MD5 码重新命名，亦即我们要写一个函数。</p>
<p>先来考虑，这个过程应当分为哪些步骤。首先可以使用 <code>md5sum</code> 算出文件的 MD5 码。但是观察上述 <code>md5sum</code> 的输出，需要设法将 MD5 码之后的空格以及文件名去除，但是要保留文件名的后缀（例如 <code>.jpg</code>），继而将剩余的 MD5 码以及文件名的后缀组合为文件名，用这个名字对文件进行重新命名。</p>
<p>若实现上述过程，现有的 Bash 知识尚且不够。譬如，<code>md5sum</code> 命令输出的信息，如何将其作为数据，为其命名，从而得到一个变量？Bash 允许在变量的定义中临时启用自身的一个复本即子 Shell 去执行一些命令，而后将命令的输出到 stdout 的信息作为数据出现在变量的定义中。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">md5_info</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span>md5sum foo.jpg<span class="k">)</span><span class="s2">"</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$md5_info</span>
<span class="go">95e25f85ee3b71cd17c921d88f2326bf foo.jpg</span>
</pre>


<p><code>(...)</code> 便是子 Shell，括号之内的文本便是要交由 Bash 的子 Shell 执行的命令。若让子 Shell 所执行命令的输出作为数据，需要使用 <code>$</code> 对子 Shell 予以展开。</p>
<p>持有变量 <code>md5_info</code> 之后，可以使用 <a href="https://liyanrui.github.io/posts/awk.html">AWK</a> 实现 MD5 码和文件名的后缀的组合。AWK 值得投入一些时间去学习它的基本用法，尤其是尚不知有什么好方法基于</p>
<pre class="code literal-block"><span></span>95e25f85ee3b71cd17c921d88f2326bf foo.jpg
</pre>


<p>生成</p>
<pre class="code literal-block"><span></span>95e25f85ee3b71cd17c921d88f2326bf.jpg
</pre>


<p>的此刻。</p>
<p>以下命令可从 <code>$md5_info</code> 中提取 MD5 码和文件名称后缀：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'{print $1}'</span>
<span class="go">95e25f85ee3b71cd17c921d88f2326bf</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'BEGIN{FS="."} {print $NF}'</span>
<span class="go">jpg</span>
</pre>


<p>利用 Bash 的子 Shell，便可以将上述两条命令合并到一个新的变量的定义中，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">new_name</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'{print $1}'</span><span class="k">)</span><span class="s2">.</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'BEGIN{FS="."} {print $NF}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$new_name</span>
<span class="go">95e25f85ee3b71cd17c921d88f2326bf.jpg</span>
</pre>


<p>上述 <code>new_name</code> 的定义很长，不便理解，可以像下面这样多用两个变量对较长的变量定义以予以拆分：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">md5_code</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'{print $1}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">$</span> <span class="nv">suffix_name</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'BEGIN{FS="."} {print $NF}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">$</span> <span class="nv">new_name</span><span class="o">=</span><span class="s2">"</span><span class="nv">$md5_code</span><span class="s2">.</span><span class="nv">$suffix_name</span><span class="s2">"</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$new_name</span>
<span class="go">95e25f85ee3b71cd17c921d88f2326bf.jpg</span>
</pre>


<p>有了 <code>new_name</code> 变量，接下来只需使用 <code>mv</code> 对 <code>foo.jpg</code> 重新命名：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> mv foo.jpg <span class="nv">$new_name</span>
</pre>


<p>大功告成……可以将上述命令所形成的过程以函数对其命名了，即</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">function</span> rename_by_md5 <span class="o">{</span>
<span class="gp">&gt;</span>     <span class="nv">md5_info</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span>md5sum foo.jpg<span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">md5_code</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'{print $1}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">suffix_name</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'BEGIN{FS="."} {print $NF}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">new_name</span><span class="o">=</span><span class="s2">"</span><span class="nv">$md5_code</span><span class="s2">.</span><span class="nv">$suffix_name</span><span class="s2">"</span>
<span class="gp">&gt;</span>     mv foo.jpg <span class="nv">$new_name</span>
<span class="gp">&gt;</span> <span class="o">}</span>
</pre>


<blockquote>
<p><strong>注</strong>：倘若你想亲手在终端里输入上述代码，不要忘记，<code>$</code> 是一级命令提示符，<code>&gt;</code> 是二级命令提示符，它们不必输入。</p>
</blockquote>
<p><code>rename_by_md5</code> 便是 <code>{</code> 和 <code>}</code> 所包围的这组命令的名字。在终端里，可以像命令那样使用这个名字，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> rename_by_md5
</pre>


<p>结果便会将当前目录的 foo.jpg 重新命名为 95e25f85ee3b71cd17c921d88f2326bf.jpg。如果接下来再次使用这个名字，Bash 便会抱怨，没有 foo.jpg 这个文件：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> rename_by_md5
<span class="go">md5sum: foo.jpg: No such file or directory</span>
<span class="go">mv: cannot stat 'foo.jpg': No such file or directory</span>
</pre>


<p>这是因为 <code>rename_by_md5</code> 所指代的过程只能对 foo.jpg 文件重新命名。若已经对 foo.jpg 完成了重新命名，那么 foo.jpg 就不存在了，所以再次使用 <code>rename_by_md5</code>，便失效了。这样不好。函数应当能够变量那样，一经定义，便可重复使用。函数的重复使用，对于 <code>rename_by_md5</code> 意味着什么呢？意味着它所指代的过程不应当仅依赖 foo.jpg，而应当将这个过程所处理的文件名视为一个未知数。学过中学数学的我们应当很容易理解，函数的自变量就是未知数。上面定义的 <code>rename_by_md5</code> 里没有自变量，因此它虽然是函数，但实际上是一个常函数。</p>
<p>在 Bash 语言里，函数的自变量不像我们在数学里所熟悉的 <code>x</code>、<code>y</code>、<code>z</code> 这些 ，而是 <code>1</code>、<code>2</code>、<code>3</code>……它们皆为变量，若获得它们指代的数据，需要用 <code>$</code>。掌握了这一知识，可对上述的 <code>rename_by_md5</code> 予以修改</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">function</span> rename_by_md5 <span class="o">{</span>
<span class="gp">&gt;</span>     <span class="nv">md5_info</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span>md5sum <span class="nv">$1</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">md5_code</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'{print $1}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">suffix_name</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$md5_info</span> <span class="p">|</span> awk <span class="s1">'BEGIN{FS="."} {print $NF}'</span><span class="k">)</span><span class="s2">"</span>
<span class="gp">&gt;</span>     <span class="nv">new_name</span><span class="o">=</span><span class="s2">"</span><span class="nv">$md5_code</span><span class="s2">.</span><span class="nv">$suffix_name</span><span class="s2">"</span>
<span class="gp">&gt;</span>     mv <span class="nv">$1</span> <span class="nv">$new_name</span>
<span class="gp">&gt;</span> <span class="o">}</span>
</pre>


<p>亦即，将 <code>rename_by_md5</code> 原定义中出现那的 <code>foo.jpg</code> 全部更换为 <code>$1</code>，值得注意的是，这个 <code>$1</code> 与 <code>awk</code> 命令中的 <code>$1</code> 并不相同，而且 <code>awk</code> 命令也不会理睬前者。</p>
<p>现在的 <code>rename_by_md5</code> 可以用于任何文件的重新命名，例如：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> rename_by_md5 foo.jpg
<span class="gp">$</span> rename_by_md5 bar.jpg
</pre>


<p><code>rename_by_md5</code> 的定义中的 <code>$1</code> 所指代的值便是在上述命令中的输入数据。这样的输入数据称为函数的参数。会写支持一个参数的函数，想必写支持两个、三个或更多个参数的函数，并不难吧？不难。</p>
<h2>脚本</h2>
<p>上一节所讨论的函数 <code>rename_by_md5</code>，是在一个终端里定义的。若终端关闭，再开启，这个函数的定义便不复存在。为了让它恒久地存在，可将其添加到 ~/.bashrc 文件里，然后</p>
<pre class="code literal-block"><span></span>$ <span class="nb">source</span> ~/.bashrc
</pre>


<p>或者在下次启动终端之后，Bash 便知道 <code>rename_by_md5</code> 是已定义的函数。不过，另有更好的方法可令 <code>rename_by_md5</code> 恒久存在。</p>
<p>为何放在 ~/.bashrc 中，Bash 便能得到函数的定义？不止如此，在上文中，我们也是在这份文件中定义了变量 <code>PS1</code>。想必在每次打开终端之时，终端里运行的 Bash 一定是读取了这份文件，并执行了文件中的命令。像 ~/.bashrc 这样的文件称为 Bash 脚本。我们也可以写与之类似的脚本，只是无法像 ~/.bashrc 那样特殊，在打开终端时就被 Bash 读取。不过也没必要那样特殊，因为已经有了 ~/.bashrc，而且我们也可以向它写入信息。</p>
<p>自己写的 Bash 脚本，若它具备可执行权限，并且所在的目录位于 <code>PATH</code> 变量定义中的目录列表中，这份脚本文件的名字可以作为命令使用。写脚本的过程，通常称为脚本编程，意思是用脚本编写程序。或许你还不知道什么是文件的可执行权限以及 <code>PATH</code> 变量又是什么。</p>
<p>变量是数据的名字。函数是过程的名字。那么，命令是谁的名字？是可执行文件的名字。何谓可执行文件？具有可执行权限的文件。例如，在 /tmp 目录创建一份空文件 foo，然后把它作为命令去执行：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">cd</span> /tmp
<span class="gp">$</span> touch foo
<span class="gp">$</span> ./foo
</pre>


<p><code>cd</code> 命令用于从当前目录跳转至指定目录。<code>./foo</code> 的意思是将当前目录（即 <code>./</code>） 中的文件 foo 作为命令执行，结果得到的是 Bash 冷冰冰的拒绝：</p>
<pre class="code literal-block"><span></span>bash: ./foo: Permission denied
</pre>


<p>此时，若查看 <code>$?</code> 的值，结果为 126：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$?</span>
<span class="go">126</span>
</pre>


<p>按照 Bash 的约定，命令的退出状态为非 0，意味着命令对应的程序出错，为 0 则意味着命令对应的程序成功地完成了自己的任务。这一约定也决定了 <code>if</code> 语句是以命令的退出状态为 0 时表示条件为真，否则条件为假。</p>
<p>接下来，可以用 <code>ls</code> 命令查看 foo 文件所具有的权限：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ls -l foo
<span class="go">-rw-r--r-- 1 garfileo users 0 Dec  2 11:17 foo</span>
</pre>


<p>即使看不懂 <code>ls</code> 命令输出的信息的含义也没关系，接下来，使用 <code>chmod</code> 命令为 foo 增加可执行权限，然后再用 <code>ls</code> 命令查看它的权限：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> chmod +x foo
<span class="gp">$</span> ls -l foo
<span class="go">-rwxr-xr-x 1 garfileo users 0 Dec  2 11:17 foo</span>
</pre>


<p>这次 <code>ls</code> 命令输出的结果与上一次有何不同？</p>
<p>现在，再次执行 <code>./foo</code>，并查看其退出状态：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ./foo
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$?</span>
<span class="go">0</span>
</pre>


<p>虽然执行 <code>./foo</code> 之后，终端什么也没有输出，但是这条命令的退出状态为 0，这表明 foo 是一个程序，并且成功地完成了自己什么也没有做的任务。</p>
<p>现在，将 foo 文件从 /tmp 目录移动到 ~/.myscript 目录，若后者不存在，可使用 <code>mkdir</code> 命令创建。还记得 <code>-d</code> 吗？</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">dest</span><span class="o">=</span>~/.myscript
<span class="gp">$</span> <span class="k">if</span> <span class="o">[</span> ! -d <span class="nv">$dest</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> mkdir <span class="nv">$dest</span><span class="p">;</span> <span class="k">fi</span>
<span class="gp">$</span> mv /tmp/foo <span class="nv">$dest</span>
</pre>


<p>在此，可以复习一下条件语句。<code>-d $dest</code> 表示「<code>$dest</code> 存在」，其前加上 <code>!</code> 便表示「<code>$dest</code> 不存在」，前面再出现 <code>if</code>  便表示「如果 <code>$dest</code> 不存在」。如果 <code>$dest</code> 不存在，当如何？「<code>then mkdir $dest</code>」。事实上，这里没必要使用条件语句。因为 <code>mkdir</code> 有一个选项 <code>-p</code>，倘若欲创建的目录已存在，<code>-p</code> 选项可以让 <code>mkdir</code> 停止创建这个目录的行为。因此，上述命令可等价地写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nv">dest</span><span class="o">=</span>~/.myscript
<span class="gp">$</span> mkdir -p <span class="nv">$dest</span>
<span class="gp">$</span> mv /tmp/foo <span class="nv">$dest</span>
</pre>


<p>现在，foo 文件位于 ~/.myscript 目录。只需将 ~/.myscript 添加到 <code>PATH</code> 所指代的目录列表，然后便可以将 foo 文件的名字 <code>foo</code> 作为命令使用：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"PATH=~/.myscript:</span><span class="nv">$PATH</span><span class="s2">"</span> &gt;&gt; ~/.bashrc
<span class="gp">$</span> <span class="nb">source</span> ~/.bashrc
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$PATH</span>
<span class="go">/home/garfileo/.myscript:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/bin</span>
<span class="gp">$</span> foo
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$?</span>
<span class="go">0</span>
</pre>


<p>在我的机器里，<code>~/.myscript</code> 便是 <code>/home/garfileo/.myscript</code>，将这个目录添加到 <code>PATH</code> 所指代的目录列表之后，每当我在终端中输入 <code>foo</code>，Bash 便会从 <code>$PATH</code> 里的目录查找与命令 <code>foo</code> 同名的具有可执行权限的文件，然后将其作为程序运行。</p>
<p>现在可以试着在 ~/.myscript 目录写一份名为 rename_by_md5 的脚本了！</p>
<h2>Here Document</h2>
<p>不过，在你打开一个文本编辑器，打算在 ~/.myscript 创建一份名为 rename_by_md5 的脚本文件之前，我觉得有必要给出使用 <code>cat</code> 命令写简单文件的方法：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt; 'EOF' &gt; ~/.myscript/rename_by_md5</span>
<span class="gp">&gt;</span><span class="s"> #!/bin/bash</span>
<span class="gp">&gt;</span><span class="s"> function rename_by_md5 {</span>
<span class="gp">&gt;</span><span class="s">     md5_info="$(md5sum $1)"</span>
<span class="gp">&gt;</span><span class="s">     md5_code="$(echo $md5_info | awk '{print $1}')"</span>
<span class="gp">&gt;</span><span class="s">     suffix_name="$(echo $md5_info | awk 'BEGIN{FS="."} {print $NF}')"</span>
<span class="gp">&gt;</span><span class="s">     new_name="$md5_code.$suffix_name"</span>
<span class="gp">&gt;</span><span class="s">     mv $1 $new_name</span>
<span class="gp">&gt;</span><span class="s"> }</span>
<span class="gp">&gt;</span><span class="s"> rename_by_md5 $1</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
</pre>


<p>Bash 将这种写文件的方法称为 Here Document。命令中的第一个 <code>EOF</code>，用于设定文件的结束标志。第二个 <code>EOF</code> 意味着写文件过程至此终止。可以使用自己喜欢的标志代替 <code>EOF</code>。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt; '很任性地结束' &gt; ~/.myscript/rename_by_md5</span>
<span class="gp">&gt;</span><span class="s"> #!/bin/bash</span>
<span class="gp">&gt;</span><span class="s"> ... ... ...</span>
<span class="gp">&gt;</span><span class="s"> rename_by_md5 $1</span>
<span class="gp">&gt;</span><span class="s"> 很任性地结束</span>
</pre>


<p>注意，设定文件结束标志时，单引号字串形式的标志并非必须，但是单引号能够阻止 Bash 对正要写入文件的内容中的一些对它具有特殊含义的字符自作聪明地予以替换。</p>
<p>执行上述写文件的命令之后，可以使用 <code>cat</code> 查看 ~/.myscript/rename_by_md5：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> cat ~/.myscript/rename_by_md5
<span class="gp">#</span>!/bin/bash
<span class="go">function rename_by_md5 {</span>
<span class="go">    md5_info="$(md5sum $1)"</span>
<span class="go">    md5_code="$(echo $md5_info | awk '{print $1}')"</span>
<span class="go">    suffix_name="$(echo $md5_info | awk 'BEGIN{FS="."} {print $NF}')"</span>
<span class="go">    new_name="$md5_code.$suffix_name"</span>
<span class="go">    mv $1 $new_name</span>
<span class="go">}</span>
<span class="go">rename_by_md5 $1</span>
</pre>


<h2>四两拨千斤</h2>
<p>如果当前目录里有几千份图片文件需要用 <code>rename_by_md5</code> 命令进行重新命名，该如何做呢？现在，对于我们而言，只费吹灰之力而已，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> i in *<span class="p">;</span> <span class="k">do</span> rename_by_md5 <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>
</pre>


<p>这个例子展示了 <code>for</code> 循环的另一种形式。<code>*</code> 名曰「通配符」，表示当前目录所有的文件或目录。所以，<code>ls *</code> 可在终端里显示当前目录的所有文件。<code>mv * /tmp</code> 则可将当前目录里的所有文件移动到 <code>/tmp</code> 目录。<code>for i in *</code> 的意思是「对当前目录中的任一份文件 i」。对当前目录中的任一份文件 i 做什么？「<code>rename_by_md5 $i</code>」。</p>
<h2>陷阱</h2>
<p>与人类语言类似，稍有不甚，所说的话就会出现语病。Bash 语言亦如此。假设，当前目录有一份名为「a b.txt」的文件，若使用 <code>md5sum</code> 命令生成该文件的 MD5 码，命令若写成</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> md5sum a b.txt
</pre>


<p>便是错的。因为 <code>md5sum</code> 会以为我们让它为文件  <code>a</code> 和文件 <code>b.txt</code> 生成 MD5 码，而且 <code>md5sum</code> 的确支持这样做。对于名字含有空格的文件，在命令中，请务必使用双引号囊括起来：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> md5sum <span class="s2">"a b.txt"</span>
</pre>


<p>如此便不会令 <code>md5sum</code> 产生误解。因此，上文中给出的</p>
<pre class="code literal-block"><span></span><span class="go">md5_info="$(md5sum $1)"</span>
</pre>


<p>安全起见，应当将其写为</p>
<pre class="code literal-block"><span></span><span class="go">md5_info="$(md5sum "$1")"</span>
</pre>


<p>同理，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> i in *<span class="p">;</span> <span class="k">do</span> rename_by_md5 <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>
</pre>


<p>应当写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="k">for</span> i in *<span class="p">;</span> <span class="k">do</span> rename_by_md5 <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>
</pre>


<p>有人已将 Bash 的常见陷阱总结成文，详见《<a href="http://mywiki.wooledge.org/BashPitfalls">Bash Pitfalls</a>》，可待熟悉 Bash 语言并用它编写较为重要的程序时再行观摩。</p>
<h2>结语</h2>
<p>现在，请容许我华丽地退场：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">exit</span>
</pre>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/some-minor-operation-for-videos.html" class="u-url">为视频做小手术</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/some-minor-operation-for-videos.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-11-14T10:34:36+08:00" itemprop="datePublished" title="2018-11-14 10:34">2018-11-14 10:34</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>FFmpeg 命令的一般格式为：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg <span class="o">[</span>全局选项<span class="o">]</span> <span class="o">[</span>输入选项<span class="o">]</span> -i input.mp4 <span class="o">[</span>输出选项<span class="o">]</span> output.mp4
</pre>


<h2>屏幕录制</h2>
<p>在 Linux 中，我的桌面屏幕分辨率是 (1920\times 1080)，使用命令</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -video_size 1920x1080 -framerate <span class="m">25</span> -f x11grab -i :0.0 output.mp4
</pre>


<p>可将录制整个屏幕。<code>-i ：0.0</code> 表示将当前的屏幕作为 ffmpeg 的输入。</p>
<p>若想录制屏幕中的指定区域，例如录制左上角点坐标为 (300, 100)、宽 500、高 200 的区域，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -video_size 500x200 -framerate <span class="m">25</span> -f x11grab -i :0.0+300,100 output.mp4
</pre>


<p>摁 <code>q</code> 键可退出屏幕录制过程。</p>
<p>FFmpeg 的 Wiki 页面[1]给出了 Windows、Mac OS X 中的屏幕录制命令。</p>
<h2>从时间轴上裁剪</h2>
<p>使用命令</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -ss <span class="m">00</span>:10:25 -i input.mp4 -frames:v <span class="m">1</span> output.png
</pre>


<p>可从视频的时间轴上截取时间戳为 00:10:25 时的画面。<code>-i</code> 表输入。<code>-ss</code> 位于 <code>-i</code> 之前，意味着跳到所输入的视频文件的给定的时间戳对应的位置。至于 <code>-i</code> 之后的设定，作用于输出。<code>-frames:v 1</code> 的意思是获取视频的 1 帧，亦即图片；若给定的帧数大于 1，那么输出的文件应当是视频，因此可以用这个参数截取一段视频。</p>
<p>若给定起始时间戳和持续时长，截取输入的视频里的一段，可以用 <code>-t</code> 选项与 <code>-ss</code> 选项相配合而实现。<code>-ss</code> 选项放在 <code>-i</code> 选项之前，用于确定所截取视频的起始帧。<code>-t</code> 选项尾随 <code>-ss</code>。例如，从输入的视频中截取从时间戳 00:10:25 开始，持续 10 分钟的一段，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -ss <span class="m">00</span>:10:25 -t <span class="m">600</span> -i input.mp4 output.mp4
</pre>


<p>或</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -ss <span class="m">00</span>:10:25 -t <span class="m">00</span>:10:00 -i input.mp4 output.mp4
</pre>


<p>若想按给定起始和终止时间戳截取视频，需要用 <code>-to</code> 选项，但这个选项只能作用于视频的输出，亦即它必须位于 <code>-i</code> 选项之后。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -ss <span class="m">00</span>:10:25 -to <span class="m">00</span>:20:25 output.mp4
</pre>


<p>也能实现从时间戳 00:10:25 开始并持续 10 分钟的一段视频的截取，但是与上述将 <code>-ss</code> 选项放在 <code>-i</code> 选项之前的命令相比，这个命令通常较为低效。因为 ffmpeg 会逐帧对输入视频进行解码，这个过程结束后，进入输出阶段时，再按照给定的起止时间戳截取视频。<code>-ss</code> 选项放在 <code>-i</code> 之前，ffmpeg 不会对 <code>-ss</code> 给定的时间戳之前的帧进行解码。</p>
<p>在 <code>-ss</code> 和 <code>-to</code> 配合使用时，将 <code>-ss</code> 放在 <code>-i</code> 选项之前，并非不可以，但是 <code>-to</code> 的含义就变了，它不再表示视频截取的终止点。因为 <code>-to</code> 原本的起点被 <code>-ss</code> 篡改了。例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -ss <span class="m">00</span>:10:25 -i input.mp4 -to <span class="m">00</span>:20:25 output.mp4
</pre>


<p>实际上截取的是输入视频中的从 00:10:25 到 00:30:25 这一段，而非从 00:10:25 到 00:20:25 这一段。</p>
<p>在上述命令中，输出视频是经过 ffmpeg 重新编码的，因此与输入视频的编码不相同。若希望输入视频的编码格式与输入视频相同，需要用 <code>-c</code> 选项将输出视频的编码格式设为 <code>copy</code>，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -ss <span class="m">00</span>:10:25 -to <span class="m">00</span>:20:25 -c copy output.mp4
</pre>


<p>实际上，<code>-c copy</code> 选项可分解为</p>
<pre class="code literal-block"><span></span>-c:v copy -c:a copy
</pre>


<p>即复制输入视频的视频编码和音频编码。</p>
<p>不过，在截取视频时，若使用 <code>-c copy</code> 选项，并且截取的视频要与其他视频拼接，那么应当再加上 <code>-avoid_negative_ts 1</code> 选项，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -ss <span class="m">00</span>:10:25 -t <span class="m">600</span> -i input.mp4 -c copy -avoid_negative_ts <span class="m">1</span> output.mp4
</pre>


<p>原因不明，未作深究。推测是，若将截取视频拼接到其他视频的尾部，<code>-avoid_negative_ts 1</code> 可以避免前者的第 1 帧覆盖后者的最后一帧。</p>
<h2>去除视频水印</h2>
<p>ffmpeg 具有类似于图像处理软件那样的滤镜（Filter）功能，作用于视频输出阶段。滤镜有很多种。delogo 滤镜可用于消除视频上的水印。</p>
<p>delogo 滤镜的基本用法是</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -vf <span class="s2">"delogo=x=a:y=b:w=c:h=d"</span> -c:a copy output.mp4
</pre>


<p>表示将一个左上角点坐标为 (a, b)、宽为 c、高为 d 的矩形区域置于视频的每一帧上。这个矩形区域内的像素由矩形边缘之外的像素确定。因此，若用 delogo 滤镜覆盖视频中的水印，结果产生的效果类似于模糊的毛玻璃。</p>
<p>若视频里有多处水印，可以用多个 delogo 去覆盖，各条 delogo 语句之间以「<code>,</code>」隔开。例如</p>
<pre class="code literal-block"><span></span>-vf "delogo=x=a:y=b:w=c:h=d, delogo=x=e:y=f:w=g:h=h, ..."
</pre>


<p>有些人为了保护视频里的水印不会被他人轻易消除，在添加水印的时候，会让水印在一定时间内出现，例如每隔 5 分钟出现，并停留 1 分钟。对于这样的视频，若是将 delogo 滤镜作用于视频的每一帧画面，就会对视频里没有水印的帧造成一些破坏。应对此类水印，可以使用 delogo 滤镜的 <code>enable</code> 参数，使得 delogo 滤镜与水印保持同时出现和消失的效果。例如，</p>
<pre class="code literal-block"><span></span>-vf "delogo=x=a:y=b:w=c:h=d:enable='between(t, e, f)'"
</pre>


<p><code>t</code> 表示视频当前的时间戳，<code>e</code> 表示一段时间的起点，<code>f</code> 表示一段时间的终点。这样的 <code>enable</code> 参数，其作用是，当视频当前的时间戳 <code>t</code> 不小于 <code>e</code> 且不大于 <code>f</code> 时，就让 delogo 滤镜生效。亦即，只要让 <code>e</code> 和 <code>f</code> 的值与水印出现和消失的时间吻合，就能够保证 delogo 滤镜与水印保持同时出现和消失。</p>
<p>滤镜作用于视频的输出过程，这意味着 FFmpeg 会对输入视频重新进行编码，视频画面质量有所损失在所难免。不过，通过调整输出视频的码率，可以使得输出视频的画面质量与输入视频相近。调整输出视频码率的选项为 <code>-b:v</code>，我通常将其值设为 <code>1600k</code>（对于蓝光高清视频，这个值有些小），例如：</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -vf <span class="s2">"delogo=x=a:y=b:w=c:h=d"</span> -c:a copy -b:v 1600k output.mp4
</pre>


<h2>为视频增加水印</h2>
<p>使用 overlay 滤镜可以将图片置于到视频的每一帧画面上。用这种滤镜可以在视频中增加水印，当然也能用于覆盖视频中一些不希望出现的区域。</p>
<p>overlay 滤镜的基本用法为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -i logo.png -vf <span class="s2">"overlay=a:b"</span> -c:a copy -b:v 1600k output.mp4
</pre>


<p><code>a</code> 和 <code>b</code> 用于设定 <code>logo.png</code> 图片在视频每一帧上的位置，即图片的左上角点在帧画面上的坐标。</p>
<p>增加多个水印也是可以的，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> ffmpeg -i input.mp4 -i logo1.png -i logo2.png <span class="se">\</span>
  -filter_complex <span class="s2">"overlay=a:b, overlay=c:d"</span> -c:a copy -b:v 1600k output.mp4
</pre>


<p>需要注意每个 <code>-i</code> 输入的图片文件与 <code>overlay</code> 的对应关系。<code>-vf</code> 用于设定单输入文件的滤镜，对于多份输入，需要用 <code>-filter_complex</code> 选项。</p>
<p>overlay 滤镜也支持 <code>enable</code> 参数。</p>
<h3><strong>引用的文档</strong></h3>
<p><strong>[1]</strong>　<a href="https://trac.ffmpeg.org/wiki/Capture/Desktop">https://trac.ffmpeg.org/wiki/Capture/Desktop</a></p>
<p><strong>[2]</strong>　<a href="https://trac.ffmpeg.org/wiki/Seeking">https://trac.ffmpeg.org/wiki/Seeking</a></p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/snail.html" class="u-url">蜗牛</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/snail.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-11-05T12:20:20+08:00" itemprop="datePublished" title="2018-11-05 12:20">2018-11-05 12:20</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>最近用 MetaFun <sup>[1]</sup> 制作了一个小模块 <a href="https://github.com/liyanrui/snail/blob/master/snail.mp">snail.mp</a> <sup>[2]</sup> ，用于绘制矢量图格式的简单流程图。</p>
<p>此事纯属无心之举。原本是要用 awk 写一个能够自动编排文档中的参考文献和注释的工具。在酝酿情绪的过程中，打算用 MetaFun 画一幅简单的示意图。在绘图过程中，因不断嫌弃所用代码的繁琐，最终有了十余行简短的绘图代码以及能够让这些代码工作的一个小模块。</p>
<p><img alt="" src="../images/snail/01.png"></p>
<p>我将这个模块命名为 Snail（蜗牛）。之所以如此命名，一方面是因为以语言描述的方式绘制流程图，效率太低了；另一方面，绘图过程也的确像蜗牛的爬动。</p>
<h2>简单的例子</h2>
<p>为求和运算 1 + 2 + 3 + ... + 100 绘制流程图，以此建立对 Snail 的喜欢、讨厌或者不以为然的初步印象。</p>
<p>首先应该用铅笔在纸上绘制草图。不过，我没找到铅笔，好不容易找到了一支中性笔客串一番。</p>
<p><img alt="" src="../images/snail/02.png"></p>
<p>基于以上草图，用 Snail 绘制流程图，结果为</p>
<p><img alt="" src="../images/snail/03.png"></p>
<p>所用的绘图代码为</p>
<pre class="code literal-block"><span></span><span class="x">\usemodule[zhfonts]</span>
<span class="x">\defineframed</span>
<span class="x">  [SnailBox]</span>
<span class="x">  [frame=off, width=6cm, autowidth=force,</span>
<span class="x">    align=</span><span class="cp">{</span><span class="nf">middle</span><span class="o">,</span> <span class="na">lohi</span><span class="o">,</span> <span class="na">broad</span><span class="cp">}</span><span class="x">, offset=overlay]</span>

<span class="x">\startMPpage</span>
<span class="x">input snail;</span>
<span class="x">Node a, b, c, d, e;</span>
<span class="x">a := io("\SnailBox</span><span class="cp">{</span><span class="nv">$i</span><span class="err">\</span><span class="na">leftarrow</span> <span class="m">1</span><span class="err">$\\</span><span class="nv">$s</span><span class="err">\</span><span class="na">leftarrow</span> <span class="m">0</span><span class="err">$</span><span class="cp">}</span><span class="x">");</span>
<span class="x">b := proc("$s\leftarrow s + i$");</span>
<span class="x">c := other("$i &gt; 100$", diamond(b));</span>
<span class="x">d := proc("$i\leftarrow i + 1$");</span>
<span class="x">e := io("\SnailBox</span><span class="cp">{</span><span class="nv">$s</span><span class="err">$</span><span class="cp">}</span><span class="x">");</span>
<span class="x">as_planet(b, a, "bottom"); as_planet(c, b, "bottom");</span>
<span class="x">as_planet(d, c, "right"); as_star(e, c, "bottom");</span>
<span class="x">draw_each a, b, c, d, e;</span>

<span class="x">enrich_each a, b, d, e;</span>
<span class="x">flow_each a =&gt; b, b =&gt; c, walk(d.N, (_n_ _v_(d.N, b.E)), b.E);</span>
<span class="x">tagged_flow("是", "right", .4) c =&gt; e;</span>
<span class="x">tagged_flow("否", "top", .4) c =&gt; d;</span>
<span class="x">\stopMPpage</span>
</pre>


<h2>绘图环境</h2>
<p>使用 Snail 模块绘制流程图，需要将绘图代码嵌入 ConTeXt 文档：</p>
<pre class="code literal-block"><span></span><span class="c">% 导言区：对 ConTeXt 排版功能予以全局设定</span>
<span class="c">%</span>
<span class="c">%</span>
<span class="k">\startMPpage</span>
input snail; 
<span class="c">% 用于绘制流程图的代码</span>
<span class="c">%</span>
<span class="c">%</span>
<span class="k">\stopMPpage</span>
</pre>


<p>若基于 zhfonts 模块 <sup>[3]</sup> 实现中文支持，只需在导言区添加 <code>\usemodule[zhfonts]</code>，即</p>
<pre class="code literal-block"><span></span><span class="k">\usemodule</span><span class="na">[zhfonts]</span>
<span class="k">\startMPpage</span>
input snail;
<span class="c">% 用于绘制流程图的代码</span>
<span class="c">%</span>
<span class="c">%</span>
<span class="k">\stopMPpage</span>
</pre>


<p>若将上一节给出的绘图代码保存为 foo.tex 文件，使用 <code>context</code> 命令便可将其编译为图形文件 foo.pdf，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> context foo.tex
</pre>


<p><code>context</code> 命令隐含了许多细节。在 ConTeXt MkIV 环境里，这个命令会将 foo.tex 文档交由 TeX 引擎 LuaTeX 处理，最后生成 PDF 格式文件 foo.pdf。foo.tex 所包含的 MetaPost 代码由嵌入在 LuaTeX 中的 MPLIB 转化为 PDF 格式的图形文件，然后再由 LuaTeX 将图形文件嵌入 foo.pdf。这一过程，使用 Snail 可将其描绘为</p>
<p><img alt="" src="../images/snail/04.png"></p>
<h2>结点</h2>
<p>一幅流程图由结点、结点间的连线以及连线上的标注等元素构成。在 Snail 看来，结点只有两类，一类是 I/O（输入/输出）结点，另一类是过程（Procedure）结点。在 Snail 的默认绘图设定中，I/O 结点是无边框的文本，而过程结点是有边框的文本。</p>
<p>Snail 模块的 <code>io</code> 宏用于构造 I/O 结点，只需将 I/O 结点的内容以字串的形式作为参数传给 <code>io</code> 宏，例如</p>
<pre class="code literal-block"><span></span>Node a;
a := io("I/O 结点的内容");
</pre>


<p><img alt="" src="../images/snail/05.png"></p>
<p>I/O 结点的文本颜色默认为黑色，若让它呈彩色，例如深绿色，只需</p>
<pre class="code literal-block"><span></span>Node a;
a := io("I/O 结点的内容") withcolor darkgreen;
</pre>


<p><img alt="" src="../images/snail/06.png"></p>
<p><code>proc</code> 宏用于构造过程结点。它会根据过程结点的文本自适应确定一个矩形边框，文本到边框的距离（留白）默认是 12 bp，约为 4.233 mm。例如，</p>
<pre class="code literal-block"><span></span>Node d; d := proc("\CONTEXT");
</pre>


<p><img alt="" src="../images/snail/07.png"></p>
<p><code>proc</code> 也能像 <code>io</code> 宏那样通过 <code>withcoloor</code> 语句修改结点文本的颜色。</p>
<p>人只是人，人际关系却多变。数据只是数据，过程亦却多变。对于流程图而言，过程的多变对应的不过是过程结点的形状和颜色的变化而已。以矩形为边框的过程结点可用于表示一般的过程。其他形式的过程，其结点可通过 <code>other</code> 宏构造，例如</p>
<pre class="code literal-block"><span></span>Node b, c, d; string d.txt;
b := other("\CONTEXT", fullsquare xysized (3cm, 1.5cm));
c := other("\METAPOST", ellipse(like b)) withcolor darkblue;
d.txt := "蜗牛爬得快吗？"; d := proc(d.txt);
d := other(d.txt, diamond(like d));
</pre>


<p><img alt="" src="../images/snail/08.png"></p>
<p><code>b</code> 的边框是长 3 cm、宽 1.5 cm 的矩形。<code>c</code> 的边框是椭圆。在默认情况下，<code>c</code> 边框的长轴与短轴的尺寸分别是 <code>b</code> 的边框长度和宽度的 1.25 倍。<code>like</code> 是 Snail 的宏，其作用是根据基于给定图形的最小包围盒确定一个矩形，因而 <code>eillpse(like b)</code> 的含义是基于像 <code>b</code> 的包围盒那样的矩形构造椭圆。同理，<code>diamond(like d)</code> 的含义是基于像 <code>d</code> 的包围盒那样的矩形构造菱形，只不过在上述代码中，先构造了普通的过程结点 <code>d</code>，然后基于它的边框构造菱形，再将新构造的结点赋予 <code>d</code> 这个变量，从而实现了 <code>d</code> 由普通过程结点向菱形过程结点的「进化」。注意，上述代码也展现了 <code>other</code> 宏可以像 <code>io</code> 和 <code>proc</code> 那样以 <code>withcolor</code> 语句设置结点文本的颜色。</p>
<p>无论是 I/O 结点还是过程结点，其类型皆为 <code>Node</code>，该类型是 Snail 为 MetaPost 的 <code>picture</code> 类型而取的「别名」。因此，I/O 结点与过程结点可直接用 MetaPost 的 <code>draw</code> 命令绘制出来，例如：</p>
<pre class="code literal-block"><span></span>draw a; draw b; draw c; draw d;
</pre>


<p>Snail 的 <code>draw_each</code> 可将一组结点绘制出来，利用这个宏可避免重复输入 <code>draw</code> 命令，</p>
<pre class="code literal-block"><span></span>draw_each a, b, c, d;
</pre>


<p>上述两条绘图语句等价。不过，Snail 所构造的结点，皆以坐标原点为中心，因此上述两条语句绘制的结果是一组堆叠起来图形：</p>
<p><img alt="" src="../images/snail/09.png"></p>
<p>因此，结点的绘制必须在流程图中的具体位置确定之后方可进行。</p>
<h2>恒星与行星</h2>
<p>可直接使用 MetaPost 的平移变换命令 <code>shifted</code> 对结点进行定位。例如，对于上一节定义的四个结点，采用以下语句进行绘制：</p>
<pre class="code literal-block"><span></span>draw_each a, b shifted (5cm, 0), c shifted (0, 2.5cm), d shifted (5cm, 2.5cm);
</pre>


<p>结果为：</p>
<p><img alt="" src="../images/snail/10.png"></p>
<p>采用平移变换命令对结点进行定位，可将任一结点放在图中的任一位置，这样做虽然自由，但是随着结点的增多，这个工作便会变得非常乏味。在绘制流程图的过程中，一个结点的位置通常是以它相对于另一个结点的位置而确定，而且二者的间距通常应当是定值。</p>
<p>Snail 是个心怀宇宙的 MetaFun 模块，它绝对不会满足于牛顿式的绝对空间。如果真的存在绝对的空间，那么谁能告诉我太阳中心的三维坐标呢？倘若以上帝的视角去安排流程图中各个结点的绝对位置或者各个结点的绝对间距，只要用心，也是能够绘制出非常美观的流程图，然而这样的流程图没有生命，对结点的形状与位置略作一些修改，图的结构便会被破坏。上帝断然不会创造没有生命的物体，否则他就太蠢了，不值得供奉或敬仰。</p>
<p>在 Snail 看来，结点的相对位置分为两类，恒星定位和行星定位。这两种定位决定了流程图结点分布的舒密。</p>
<p>恒星定位是以结点中心之间的水平或竖直距离作为约束，基于一个结点的位置确定另一个结点的位置，这种定位可通过 Snail 宏 <code>as_star</code> 实现。例如，将结点 <code>b</code> 放在 <code>a</code> 的右侧，让二者中心的水平距离为默认的行星距离：</p>
<pre class="code literal-block"><span></span>as_star(b, a, "right");
</pre>


<p>类似地，可以用 <code>left</code>、<code>top</code> 以及 <code>bottom</code>，将 <code>b</code> 放在 <code>a</code> 的左侧、顶部以及底部。Snail 默认的行星距离是 5 cm，这个值存储于 Snail 的一个全局变量 <code>_star.s</code>，这意味着可通过修改这个变量控制流程图中以恒星定位的结点间距。还有一部分类似于 <code>_star.s</code> 这样控制流程图整体样式的全局变量，在本文的最后会专门予以介绍。</p>
<p>行星定位类似于恒星定位，唯一的区别前者在对一个结点进行定位时是以结点边框的间距——行星间距作为约束。所谓结点边框的间距，即对于任意结点 a 和 b，当它们的中心连线为同一条水平或竖直的线段时，a 和 b 的边框与该线段交点的距离。Snail 的宏 <code>as_planet</code> 用于实现结点的行星定位，其用法与 <code>as_star</code> 同，例如</p>
<pre class="code literal-block"><span></span>as_planet(b, a, "bottom");
as_planet(c, b, "bottom");
as_planet(d, c, "right");
</pre>


<p><img alt="" src="../images/snail/11.png"></p>
<h2>组合</h2>
<p>结点的恒星和行星定位还是太过于严格，以致一些特殊的结点定位需求难以满足，例如</p>
<p><img alt="" src="../images/snail/12.png"></p>
<p>结点 d 的宽度与 a、b 和 c 相同，高度则是从 c 的底端到 a 的顶端。为了满足诸如此类的定位需求，Snail 提供了 <code>+++</code> 运算符，用它可以将任意两个结点绑定起来，从而获得一个新的结点，而且新的结点所占据的区域恰好包含这两个结点。重复使用 <code>+++</code> 便可以实现多个结点的绑定。</p>
<p>对于形如上图所示的四个结点，可采用以下代码予以定位：</p>
<pre class="code literal-block"><span></span>Node a, b, c, abc, d;
a := other("a", fullsquare xysized (2cm, 1cm));
b := other("b", like a);
c := other("c", like a);
as_planet(b, a, "bottom"); as_planet(c, b, "bottom");
abc := a +++ b +++ c;
d := other("d", like abc);
as_planet(d, abc, "right");

draw_each a, b, c, d;
</pre>


<p><img alt="" src="../images/snail/13.png"></p>
<h2>水平 / 竖直对齐</h2>
<p>若将一个结点的中心与另一个结点的中心在水平或竖直方向上对齐，可相应采用 Snail 的<code>halign</code> 或 <code>valign</code> 宏。例如，若将结点 <code>a</code> 的中心与结点 <code>b</code> 的中心在水平方向上对齐，即 <code>b</code> 的位置固定，调整 <code>a</code> 的位置，使得二者的中心在同一水平线上，只需</p>
<pre class="code literal-block"><span></span>halign(a, b);
</pre>


<p>同理，</p>
<pre class="code literal-block"><span></span>valign(a, b);
</pre>


<p>可将以调整 <code>a</code> 的位置，使得它的中心与 <code>b</code> 的中心在竖直方向对齐。</p>
<p>若以一个结点为基准，让一组结点的中心在水平或竖直方向上对齐，可以利用 MetaPost 的循环语句。例如，以 <code>a</code> 为基准，将 <code>b</code>、<code>c</code>、<code>d</code> 等结点的中心与 <code>a</code> 的中心在水平方向上对齐：</p>
<pre class="code literal-block"><span></span><span class="nt">forsuffixes</span> <span class="nt">i</span> <span class="o">=</span> <span class="nt">b</span><span class="o">,</span> <span class="nt">c</span><span class="o">,</span> <span class="nt">d</span><span class="o">:</span> <span class="nt">halign</span><span class="o">(</span><span class="nt">i</span><span class="o">,</span> <span class="nt">a</span><span class="o">);</span> <span class="nt">endfor</span><span class="o">;</span>
</pre>


<h2>连接</h2>
<p>当各个结点的摆放位置确定之后，考虑的便是它们之间的连接。基于恒星定位或行星定位的两个结点，若它们相邻，可直接连接。对于这种连接，Snail 提供了 <code>=&gt;</code> 运算符。<code>=&gt;</code> 左侧的结点称为出射结点，右侧的结点称为入射结点。<code>=&gt;</code> 会根据出射结点与入射结点的位置确定一条连线，该连线出射结点的边框上某条边的中点出发，沿水平或竖直方向抵达入射结点的边框。例如</p>
<pre class="code literal-block"><span></span>Node a, b;
a := proc("Node a");
b := proc("Node b");
as_planet(b, a, "right");

draw_each a, b;
flow a =&gt; b;
</pre>


<p><img alt="" src="../images/snail/14.png"></p>
<p>Snail 的 <code>flow</code> 宏是 MetaFun 的 <code>drawarrowpath</code> 宏的替代，用于绘制有向路径。</p>
<p>再看一个例子：</p>
<pre class="code literal-block"><span></span>Node a, b, c, abc, d;
a := other("a", fullsquare xysized (2cm, 1cm));
b := other("b", like a);
c := other("c", like a);
as_planet(b, a, "bottom");
as_planet(c, b, "bottom");
abc := a +++ b +++ c;
d := other("d", like abc);
as_planet(d, abc, "right");

draw_each a, b, c, d;
flow_each a =&gt; d, b =&gt; d, c =&gt; d;
</pre>


<p><img alt="" src="../images/snail/15.png"></p>
<p><code>flow_each</code> 与 <code>draw_each</code> 类似，只不过它绘制的是一组有向路径。</p>
<p>当两个结点既不水平排列也不在竖直排列时，二者的连接是折线。能够像 <code>=&gt;</code> 那样自动确定连接路径是一件很美好的事。然而，Snail 决定不要这种美好。</p>
<p>对于弯曲的路径，Snail 会沿着我们小心谨慎地构造的路径，从出射结点爬到入射结点。该基于出射锚点、前进的方向、前行的距离以及入射锚点而确定。构造该路径的过程就是模拟蜗牛的爬行或人的行走。例如，从一个确定的地点，向东走 100 米，向北走 100 米，向西走 500 米，就这样转来转去，直至抵达目标地点为止。Snail 的 <code>walk</code> 宏可用于构造这种路径。</p>
<p><code>walk</code> 的第一个参数是路径的起点，第二个参数是由行进方向和距离构造的路径，第三个参数是终点。起点和终点可由 Snail 的 <code>anchor</code> 宏在源结点和目标结点的边框上确定。</p>
<p>若结点的边框为矩形，<code>anchor</code> 宏具备在该边框上确定任意一点的能力。例如，对于结点 <code>a</code>，其左、右、上、下边框的中点，可由以下代码确定：</p>
<pre class="code literal-block"><span></span>anchor(a, "left", 0);
anchor(a, "right", 0);
anchor(a, "top", 0);
anchor(a, "bottom", 0);
</pre>


<p><code>anchor</code> 前两个参数的作用已经很明显了，它的第三个参数是矩形边框上的参数坐标。对于矩形的每条边框，参数坐标的取值范围为 [-0.5, 0.5]，中点的参数坐标为 0。</p>
<p><img alt="" src="../images/snail/16.png"></p>
<p>现在 <code>walk</code> 宏的第二个参数描述的是路径的起点与终点之间的部分，但是只能由行进方向和距离构成。例如 </p>
<pre class="code literal-block"><span></span>path p;
p := (0, 0) &gt;&gt;&gt; right * 1cm &gt;&gt;&gt; up * 3cm &gt;&gt;&gt; left * 8cm &gt;&gt;&gt; down * 5cm &gt;&gt;&gt; right * 4cm;
</pre>


<p>表示从原点开始，向右走 1 cm，再向上走 3 cm，再向左走 8 cm，再向下走 6 cm，再向右走 6 cm。</p>
<p><img alt="" src="../images/snail/17.png"></p>
<p><code>&gt;&gt;&gt;</code> 是 Snail 实现的运算符，用于衔接各段行进方向及距离的「积」。由于模拟的是行走，以左右上下作为行进的方向不够自然，因而 Snail 定义了一组可以沿地理方向行进的宏：</p>
<ul>
<li>
<code>_e_</code>，<code>_n_</code>，<code>_w_</code>，<code>_s_</code>：向东、北、西、南行进；</li>
<li>
<code>_E_</code>，<code>_N_</code>，<code>_W_</code>，<code>_S_</code>：向东、北、西、南行进，但是事先会行进 0.5 倍的行星间距；</li>
<li>
<code>_EE_</code>，<code>_NN_</code>，<code>_WW_</code>，<code>_SS_</code>：向东、北、西、南行进，但是事先会行进 1 倍的行星间距。</li>
</ul>
<p>基于这些宏，上述路径 <code>p</code> 可表示为：</p>
<pre class="code literal-block"><span></span>p := (0, 0) &gt;&gt;&gt; (_e_ 1cm) &gt;&gt;&gt; (_n_ 3cm) &gt;&gt;&gt; (_w_ 8cm) &gt;&gt;&gt; (_s_ 5cm) &gt;&gt;&gt; (_e_ 4cm);
</pre>


<p>当蜗牛很任性地绕着圈子爬行的时候，就可以走出一条漩涡路径：</p>
<pre class="code literal-block"><span></span>numeric s; path p;
s := 0.25cm; p := (0, 0); 
for i = 1 upto 7:
  for j = "_n_", "_w_", "_s_", "_e_":
    s := s + 0.25cm;
    p := p &gt;&gt;&gt; (scantokens(j) s);
  endfor;
endfor;
</pre>


<p><img alt="" src="../images/snail/18.png"></p>
<p>现在，可以为结点构造折线形式的连接了。例如，对于一个结点，以其左边框的中点为起点，以其下边框的中点为终点，让路径自结点上方绕行，</p>
<pre class="code literal-block"><span></span>Node a; pair a.out, a.in; path a.self, a.self.go; numeric a.w, a.h;
a := proc("打酱油");
a.out := anchor(a, "right", 0);
a.in  := anchor(a, "bottom", 0);
a.w := _bw_ a; a.h := _bh_ a;
a.self.go := (_E_ 0) &gt;&gt;&gt; (_N_ .5a.h) &gt;&gt;&gt; (_WW_ a.w) &gt;&gt;&gt; (_SS_ a.h) &gt;&gt;&gt; (_E_ .5a.w);
a.self := walk(a.out, a.self.go, a.in);
draw a; flow a.self;
</pre>


<p><img alt="" src="../images/snail/19.png"></p>
<p>Snail 的宏 <code>_bw_</code> 与 <code>_bh_</code> 只是 MetaFun 宏 <code>bbwidth</code> 与 <code>bbheight</code> 的替代，分别用于获取结点的宽度与高度。宏 <code>flow</code> 是 MetaFun 宏 <code>drawarrowpath</code> 的替代，用于绘制带箭头的路径。</p>
<p>绘制这样一条简单的折线路径，需要这么多的代码，这就是 Snail 绘制流程图的效率瓶颈。所幸之处在于，对于简单的流程图而言，折线路径并不会太多。偶尔这样模拟一下蜗牛式的爬行，在诸多以恒星和行星方式定位的结点分布空间中以折线的方式行走，很像乘坐太空飞船作星际旅行。</p>
<p>倘若能够自动为结点构造一些常规锚点，例如每个结点边框上的中点，构造弯曲路径的代码便可以得到一些简化。Snail 的 <code>enrich</code> 宏可基于给定的结点构造 8 个位于边框上的锚点，它们皆为 <code>pair</code> 类型，以给定结点的变量名的后缀形式表示，分别位于这个结点的东（E）、东南（SE）、南（S）、西南（SW）、西（W）、西北（NW）、北（N）、东北（NE）位置。例如，</p>
<pre class="code literal-block"><span></span>enrich(a);
</pre>


<p>结果可以得到一组 <code>pair</code> 类型的后缀形式的变量，即 <code>a.E</code>、<code>a.SE</code>、<code>a.S</code>、<code>a.SW</code> 等。此外，<code>enrich</code> 还可以获得结点边框的宽度和高度，例如 <code>a.width</code> 和 <code>a.height</code>。利用 <code>enrich</code> 宏，便可以对上述的折线路径的构造过程予以简化：</p>
<pre class="code literal-block"><span></span>Node a; path a.self;
a := proc("打酱油");
enrich(a);
a.self := walk(a.E, ((_E_ 0) &gt;&gt;&gt; (_N_ .5a.height)
                     &gt;&gt;&gt; (_WW_ a.width) &gt;&gt;&gt; (_SS_ a.height) 
                     &gt;&gt;&gt; (_E_ .5a.width)), a.S);
draw a;
flow a.self;
</pre>


<h2>路径的标注</h2>
<p>由于 MetaPost 支持以取值范围为 [0, 1] 的参数方式在一条路径上定位，因此利用这一特性，便可以对结点之间的连接进行标注。Snail 的 <code>tagged_flow</code> 宏实现了这一功能。对于上一节所构造的路径 <code>a.self</code>，若在参数为 0.65 的位置左侧增加文本标注，只需用 <code>tagged_flow</code> 取代 <code>flow</code> 宏，</p>
<pre class="code literal-block"><span></span>tagged_flow("路过", "left", .65) a.self;
</pre>


<p><img alt="" src="../images/snail/20.png"></p>
<p>若需要对路径的标注文本进行旋转变换，使之与所标注位置的路径更为贴合，可利用 ConTeXt 的排版予以实现，MetaFun 的价值由此也得以体现。例如，</p>
<pre class="code literal-block"><span></span>tagged_flow("\rotate[90]{路过}", "left", .65) a.self;
</pre>


<p><img alt="" src="../images/snail/21.png"></p>
<h2>全局参数</h2>
<p>Snail 预定义了一些全局变量，用于控制流程图的整体样式——文本颜色、边框颜色、边框背景以及留白等参数。</p>
<p>流程图各个元素的颜色默认为：</p>
<ul>
<li>
<code>_io_color_ := black</code>：I/O 结点的文本颜色，默认为黑色；</li>
<li>
<code>_proc_color_ := darkred</code>：过程结点的文本颜色，默认为暗红色；</li>
<li>
<code>_flow_color_ := .9darkgray</code>：结点连接线的颜色，默认为更暗一点的深灰色；</li>
<li>
<code>_frame_color_ := .7white</code>：过程结点的边框颜色，默认为浅灰色；</li>
<li>
<code>_bg_color_ := .9white</code>：过程结点的背景颜色，默认为更浅的灰色。</li>
</ul>
<p>结点边框和结点连线的默认宽度为：</p>
<pre class="code literal-block"><span></span>_pensize_ := 2.5;
</pre>


<p>结点连线的宽度和颜色默认设定为：</p>
<pre class="code literal-block"><span></span>drawpathoptions(withpen pencircle scaled _pensize_ withcolor _flow_color_);
</pre>


<p>I/O 结点和过程结点文本四周留白尺寸默认为</p>
<pre class="code literal-block"><span></span>_pad_ := 4;  _proc_pad_ := 4_pad_;
</pre>


<p>恒星和行星定位时所用的水平和竖直间距默认为</p>
<pre class="code literal-block"><span></span>_star.s := 4cm; _star.sx := _star.s; _star.sy := .5_star.sx;
_planet.s := .2_star.s; _planet.sx := _planet.s; _planet.sy := _planet.sx;
</pre>


<p><code>_margin_</code> 用于 <code>_E_</code>、<code>_EE_</code>、<code>_S_</code>、<code>_SS_</code> 等地理方向行进宏的预先行进的距离，默认值为 <code>.5_planet.s</code>。</p>
<p><code>_expansion_</code> 用于基于矩形构造与之外接的菱形和椭圆等图形时，后者的长轴与短轴在矩形的宽度与高度的基础上放大的倍数，默认值为 1.25。</p>
<hr>
<p><strong>引用的文献：</strong></p>
<p>[1] <a href="https://segmentfault.com/a/1190000016832302">MetaFun 列传</a></p>
<p>[2] Snail 模块：https://github.com/liyanrui/snail</p>
<p>[3] <a href="https://segmentfault.com/a/1190000003795931">zhfonts：ConTeXt MkIV 的中文支持模块</a></p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/metafun.html" class="u-url">MetaFun 小传</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/metafun.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-10-29T18:10:38+08:00" itemprop="datePublished" title="2018-10-29 18:10">2018-10-29 18:10</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>MetaFun 是 ConTeXt 的一部分，主要用于 MetaPost 的绘图功能与 ConTeXt 的排版功能的衔接。</p>
<p>ConTeXt 专事文字排版，功能匹于 LaTeX，但更易于使用，二者皆为 TeX 宏包，即二者皆基于 TeX 提供的宏编程功能，对 TeX 语言予以封装，建立更利于文字排版工作的高级语言。TeX 是一种计算机排版语言，供编排科技手稿以及著作出版印刷之用 <strong><sup>[1]</sup></strong> 。MetaPost 是用于绘制矢量绘图的计算机语言。</p>
<p>目前最新的 ConTeXt 版本为 MkIV，安装 ConTeXt Standalone 可得 <strong><sup>[2]</sup></strong> 。ConTeXt MkIV 的基本用法可参考之前我写的几篇文章 <strong><sup>[3–7]</sup></strong> ，或阅读 ConTeXt 官方文档 <strong><sup>[8, 9]</sup></strong> 。</p>
<p>MetaFun 以 MetaPost 生成的矢量图形作为页面特定区域的背景，而后基于 ConTeXt 的排版功能在该背景上实现编排文字。</p>
<p><img alt="" src="../images/metafun/01.png"></p>
<h2>MetaPost</h2>
<p>MetaPost 是一种编程语言 <strong><sup>注 1</sup></strong> ，其编译器为 mpost。用该语言编写的程序，其输出结果为 PostScript 格式的矢量图形文件 <strong><sup>注 2</sup></strong> 。<code>MPpage</code> 环境中的 MetaPost 语句即 MetaPost 程序。在使用 context 命令生成单页面图形文件的过程中，context 命令会调用 mpost，由后者处理 MetaPost 程序，生成 PostScript 图形文件。继而 context 命令调用 TeX 引擎 <strong><sup>注 3</sup></strong> 会将 mpost 生成的图形文件嵌入至单页面文档中，并将图形的宽高作为页面宽高。</p>
<blockquote>
<p><strong>注 1</strong>：确切地说，MetaPost 是一种宏编程语言。</p>
<p><strong>注 2</strong>：PostScript 文件可转化为 PDF、SVG 等格式的矢量图形文件。</p>
<p><strong>注 3</strong>：TeX 引擎即 TeX 文档的编译器。ConTeXt 文档本质上也是 TeX 文档，因此要通过 TeX 引擎对其其进行编译，输出排版结果。ConTeXt MkIV 的 TeX 引擎为 LuaTeX，其输出的排版结果为 PDF 格式文档。</p>
</blockquote>
<h2>画笔</h2>
<p>画笔即 MetaPost 的内置变量 <code>pen</code>。MetaPost 提供了两种画笔类型，<code>pencircle</code> 和 <code>pensquare</code>，前者为 MetaPost 默认，「笔尖」为圆形，后者「笔尖」为方形。MetaPost 允许用户自行定义画笔类型。</p>
<p>画笔主要用于控制所绘线条的粗细。线条默认的宽度为 PostScript 所规定的大点（Big Point）的直径尺寸，即 1 bp。MetaPost 将 1 bp 作为基准长度单位，其他单位皆为该单位的倍数：</p>
<pre class="code literal-block"><span></span><code><span class="err">bp := 1</span>
<span class="err">mm = 2.83464</span>
<span class="err">cm = 28.34645</span>
<span class="err">pc = 11.95517</span>
<span class="err">cc = 12.79213</span>
<span class="err">in := 72</span>
<span class="err">pt = 0.99626</span>
<span class="err">dd = 1.06601</span>
</code></pre>

<p><code>pickup</code> 命令可用于设定画笔，从而影响随后的绘图语句所绘制线条的粗细，这一影响直至 <code>pickup</code> 命令的再次出现为止。例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">pickup pencircle scaled 1mm;</span>
<span class="err">一系列绘图语句;</span>
<span class="err">pickup pencircle scaled 2mm;</span>
<span class="err">一系列绘图语句;</span>
</code></pre>

<p>定义了两个画笔，笔尖粗度分别为 1mm 和 2mm，分别会影响位于其后的绘图过程。<code>scaled</code> 用于数值大小的缩放变换；其他变换还有 <code>shifted</code>、<code>rotated</code> 以及 <code>slant</code>，分别为平移、旋转以及错切变换。在画笔的设定中，<code>scaled 1mm</code> 意味着将线条粗细程序由 MetaPost 默认的 1 bp 在水平和竖直方向上同等放大为 1 mm <strong><sup>注 4</sup></strong> 。可以使用 <code>xscaled</code> 或 <code>yscaled</code> 对画笔的水平或竖直方向的粗细进行调整，对于 <code>pencircle</code> 类型的画笔而言，此举意味着将笔尖由默认的圆形转化为椭圆，而对于 <code>pensquare</code>，则意味着将笔尖由正方形转化为矩形。</p>
<blockquote>
<p><strong>注 4</strong>：在 MetaPost 程序中，数字与单位之间不能出现空格。事实上，在 MetaPost 中，诸如 <code>1mm</code>、<code>2cm</code> 此类的长度描述本质上是 <code>mm</code> 或 <code>cm</code> 等变量的倍数，即 <code>1 * mm</code>、<code>2 * cm</code>。</p>
</blockquote>
<p>在 <code>pickup</code> 的影响范围内，绘图语句可以通过 <code>withpen</code> 命令局部调整线条的粗细，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">withpen pencircle scaled 1mm</span>
</code></pre>

<h2>颜色</h2>
<p>MetaPost 以含有三个分量的向量表示颜色。向量的三个分量分别表示红色、绿色和蓝色，取值范围为 [0, 1]，例如 <code>(0.4, 0.5, 0.6)</code>。</p>
<p>可将颜色保存到 <code>color</code> 类型的变量中，以备绘图中重复使用。例如</p>
<pre class="code literal-block"><span></span><code><span class="err">color darkred;</span>
<span class="err">darkred := (0.625, 0, 0);</span>
</code></pre>

<p>由于 MetaPost 内部已经定义了用于表示红色的变量 <code>red</code>，因此 <code>darkred</code> 变量的定义也可写为</p>
<pre class="code literal-block"><span></span><code><span class="err">color darkred;</span>
<span class="err">darkred := 0.625 * red;</span>
</code></pre>

<p>类似于 <code>1 * cm</code> 可以写为 <code>1cm</code>，倍数也可以直接作用于颜色：</p>
<pre class="code literal-block"><span></span><code><span class="err">darkred := 0.625red;</span>
</code></pre>

<p>在绘图语句中可以通过 <code>withcolor</code> 命令设定所绘线条或区域填充的颜色，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">withcolor 0.625red</span>
</code></pre>

<p>由于颜色的倍数不可能大于 1，因此整数部分必定为 <code>0</code>，在 MetaPost 语句中可以省略，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">darkred := .625red;</span>
</code></pre>

<p>若绘图语句未通过 <code>withcolor</code> 命令设定颜色，则默认颜色为黑色。</p>
<h2>单页图</h2>
<p>在排版空间中，可安置 MetaPost 图形之处大致有插图、单页图、页面元素背景以及页面背景等类别。若以先习得 MetaPost 的基本用法为目的，则单页图最为合用，并且生成的图形易于转化为位图以作他用。</p>
<p>所谓 MetaPost 单页图，本质上是 ConTeXt 输出的排版结果——PDF 文档，只是文档页面的大小恰好容得下图形。ConTeXt 为 MetaPost 单页面提供了 <code>MPpage</code> 环境：</p>
<pre class="code literal-block"><span></span><code><span class="k">\startMPpage</span>
MetaPost 绘图语句;
<span class="k">\stopMPpage</span>
</code></pre>

<p>例如，假设存在 ConTeXt 文档 foo.tex，其内容为</p>
<pre class="code literal-block"><span></span><code><span class="k">\startMPpage</span>
path p;
u := 10cm; v := 3cm;
p := fullsquare xyscaled (u, v) randomized 0.07u;
drawpath p;
drawpoints p;
<span class="k">\stopMPpage</span>
</code></pre>

<p>通过 context 命令便可基于 foo.tex 生成 foo.pdf，即</p>
<pre class="code literal-block"><span></span><code><span class="gp">$</span> context foo
</code></pre>

<p>结果得到的 foo.pdf 为单页文档，其页面只包含着一个边线被随机扰动的矩形：</p>
<p><img alt="" src="../images/metafun/02.png"></p>
<h2>线条</h2>
<p>线条即画笔所走的路径。最简单的路径是点。MetaPost 用序对表示点，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">pair a;</span>
<span class="err">a := (2cm, 3.5cm)</span>
</code></pre>

<p>表示在直接坐标系中，横坐标 <code>x</code> 为 <code>2cm</code> 而纵坐标 <code>y</code> 为 <code>3.5cm</code> 之处有一个点 <code>a</code>。<code>draw</code> 命令用于路径的绘制，通过它可将点 <code>a</code> 绘制出来，即</p>
<pre class="code literal-block"><span></span><code><span class="err">draw a;</span>
</code></pre>

<p>从一个点到另一个点，可构成一条线段。例如</p>
<pre class="code literal-block"><span></span><code><span class="n">pair</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="n">cm</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">5</span><span class="n">cm</span><span class="p">);</span> <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="n">cm</span><span class="p">,</span> <span class="mi">5</span><span class="n">cm</span><span class="p">);</span>

<span class="n">path</span> <span class="n">p</span><span class="p">;</span> 
<span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span> <span class="c1">-- b;</span>
</code></pre>

<p>可构造从点 <code>a</code> 到 <code>b</code> 的线段 <code>a -- b</code>，并将其保存到路径变量 <code>p</code> 中。使用</p>
<pre class="code literal-block"><span></span><code><span class="err">draw p withcolor .625green;</span>
</code></pre>

<p>即可绘制这条线段。在该条语句中，线条颜色被设为暗绿色 <code>0.625green</code>。</p>
<p>由于 MetaPost 允许在 <code>draw</code> 语句中直接给出点的坐标的形式构造路径，因此上述 MetaPost 程序可缩减为一行语句：</p>
<pre class="code literal-block"><span></span><code><span class="err">draw (2cm, 3.5cm) -- (5cm, 5cm) withcolor .625green;</span>
</code></pre>

<p>但是，若要绘制复杂的图形，借助变量，会使得 MetaPost 程序更易于编写和理解。例如</p>
<pre class="code literal-block"><span></span><code><span class="n">pair</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span> <span class="n">path</span> <span class="n">p</span><span class="p">;</span>
<span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="n">cm</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">5</span><span class="n">cm</span><span class="p">);</span> <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="n">cm</span><span class="p">,</span> <span class="mi">5</span><span class="n">cm</span><span class="p">);</span>
<span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span> <span class="c1">-- b;</span>

<span class="n">pickup</span> <span class="n">pencircle</span> <span class="n">scaled</span> <span class="mi">2</span><span class="n">pt</span><span class="p">;</span>
<span class="n">draw</span> <span class="n">p</span> <span class="n">withcolor</span> <span class="p">.</span><span class="mi">625</span><span class="n">green</span><span class="p">;</span>

<span class="n">pickup</span> <span class="n">pencircle</span> <span class="n">scaled</span> <span class="mi">4</span><span class="n">pt</span><span class="p">;</span>
<span class="n">color</span> <span class="n">darkred</span><span class="p">;</span> <span class="n">darkred</span> <span class="p">:</span><span class="o">=</span> <span class="p">.</span><span class="mi">625</span><span class="n">red</span><span class="p">;</span>
<span class="n">draw</span> <span class="n">a</span> <span class="n">withcolor</span> <span class="n">darkred</span><span class="p">;</span>
<span class="n">draw</span> <span class="n">b</span> <span class="n">withcolor</span> <span class="n">darkred</span><span class="p">;</span>
</code></pre>

<p><img alt="" src="../images/metafun/03.png"></p>
<p>不仅绘制了线段，而且将线段的端点也绘制了出来。</p>
<p>利用线段可绘制任意的多边形。例如，绘制一个直角三角形，</p>
<pre class="code literal-block"><span></span><code><span class="n">pair</span> <span class="s">a,</span> <span class="s">b,</span> <span class="s">c</span><span class="p">;</span> <span class="n">path</span> <span class="s">p</span><span class="p">;</span>
<span class="n">a</span> <span class="s">:=</span> <span class="s">(0,</span> <span class="s">0)</span><span class="p">;</span> <span class="n">b</span> <span class="s">:=</span> <span class="s">(4cm,</span> <span class="s">0)</span><span class="p">;</span> <span class="n">c</span> <span class="s">:=</span> <span class="s">(4cm,</span> <span class="s">3cm)</span><span class="p">;</span>
<span class="n">p</span> <span class="s">:=</span> <span class="s">a</span> <span class="o">--</span> <span class="n">b</span> <span class="o">--</span> <span class="n">c</span> <span class="o">--</span> <span class="n">a</span><span class="p">;</span>

<span class="c">% 注意：凡以百分号领起的文本为 MetaPost 代码注释。</span>

<span class="n">pickup</span> <span class="s">pencircle</span> <span class="s">scaled</span> <span class="s">5</span><span class="p">;</span> <span class="c">% 将画笔设为 5 bp</span>
<span class="n">draw</span> <span class="s">p</span> <span class="s">withcolor</span> <span class="s">.8white</span><span class="p">;</span>

<span class="n">pickup</span> <span class="s">pencircle</span> <span class="s">scaled</span> <span class="s">4</span><span class="p">;</span>
<span class="n">draw</span> <span class="s">a</span><span class="p">;</span> <span class="n">draw</span> <span class="s">b</span><span class="p">;</span> <span class="n">draw</span> <span class="s">c</span><span class="p">;</span>
</code></pre>

<p><img alt="" src="../images/metafun/04.png"></p>
<p>为了便于图形的演示，MetaFun 提供了 <code>drawpath</code> 和 <code>drawpoints</code> 宏，前者用于绘制路径，后者用于绘制路径的节点。通过这两个宏，上例可简化为</p>
<pre class="code literal-block"><span></span><code><span class="err">pair a, b, c; path p;</span>
<span class="err">a := (0, 0); b := (4cm, 0); c := (4cm, 3cm);</span>
<span class="err">p := a -- b -- c -- a;</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p>显然，上述路径 <code>p</code> 是一条闭合路径，但 MetaPost 对此并不知情，需要通过 <code>cycle</code> 命令告诉它，即</p>
<pre class="code literal-block"><span></span><code><span class="err">p := a -- b -- c -- cycle;</span>
</code></pre>

<p>否则，虽然我们认为 <code>p</code> 是闭合路径，但 MetaPost 并不苟同，以致在使用 <code>fill</code> 命令对该路径包围的区域填充颜色时，会导致 MetaPost 报错并罢工。</p>
<p><code>fill</code> 命令可对闭合路径所包围的区域着色。例如</p>
<pre class="code literal-block"><span></span><code><span class="err">pair a, b, c; path p;</span>
<span class="err">a := (0, 0); b := (4cm, 0); c := (4cm, 3cm);</span>
<span class="err">p := a -- b -- c -- cycle;</span>
<span class="err">drawpath p; drawpoints p;</span>
<span class="err">fill p withcolor .8blue;</span>
</code></pre>

<p><img alt="" src="../images/metafun/05.png"></p>
<p>上例中的路径 <code>p</code> 皆为直线插值。MetaPost 支持以曲线插值的方式构造路径。倘若将直线插值符的 <code>--</code> 替换为曲线插值符 <code>..</code> 便可产生一条插值于点 <code>a</code>、<code>b</code> 和 <code>c</code> 的曲线路径，</p>
<pre class="code literal-block"><span></span><code><span class="err">p := a .. b .. c .. cycle;</span>
</code></pre>

<p><img alt="" src="../images/metafun/06.png"></p>
<p>直线插值符与曲线插值符可并用，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">p := a .. b .. c -- cycle;</span>
</code></pre>

<p><img alt="" src="../images/metafun/07.png"></p>
<p><code>controls</code> 命令可将路径中的某些结点转化为控制点，从而可构造 Bézier 曲线。例如</p>
<pre class="code literal-block"><span></span><code><span class="err">p := a .. controls b ..c; draw p;</span>
</code></pre>

<p><img alt="" src="../images/metafun/08.png"></p>
<p>构造的是一条二次 Bézier 曲线路径，此时点 <code>b</code> 成为控制点，曲线只插值于点 <code>a</code> 和 <code>b</code>。MetaFun 提供了 <code>drawcontrollines</code> 以及 <code>drawcontrolpoints</code> 宏，分别用于绘制 Bézier 曲线的控制形及控制点，例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">p := a .. controls b ..c;</span>
<span class="err">drawpath p; drawpoints p;</span>
<span class="err">drawcontrollines p; drawcontrolpoints p;</span>
</code></pre>

<p><img alt="" src="../images/metafun/09.png"></p>
<p>三次 Bézier 曲线需要在路径中设定 2 个控制点，例如</p>
<pre class="code literal-block"><span></span><code><span class="n">pair</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span> <span class="n">path</span> <span class="n">p</span><span class="p">;</span>
<span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="n">cm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="k">c</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="n">cm</span><span class="p">,</span> <span class="mi">3</span><span class="n">cm</span><span class="p">);</span> <span class="n">d</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="n">cm</span><span class="p">);</span>

<span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span> <span class="p">..</span> <span class="n">controls</span> <span class="n">b</span> <span class="k">and</span> <span class="k">c</span> <span class="p">..</span> <span class="n">d</span><span class="p">;</span>
<span class="n">drawpath</span> <span class="n">p</span><span class="p">;</span> <span class="n">drawpoints</span> <span class="n">p</span><span class="p">;</span>
<span class="n">drawcontrollines</span> <span class="n">p</span><span class="p">;</span> <span class="n">drawcontrolpoints</span> <span class="n">p</span><span class="p">;</span>
</code></pre>

<p><img alt="" src="../images/metafun/10.png"></p>
<p>无论是插值曲线还是 Bézier 曲线，MetaPost 最高支持三次曲线。不过，对于形状较为复杂的路径，MetaPost 支持以多段插值直线、曲线以及 Bézier 曲线拼接 <strong><sup>注 5</sup></strong> 的方式构造路径。</p>
<blockquote>
<p><strong>注 5</strong>：对于一组曲线，MetaPost 会以切向连续并且近似曲率连续的方式予以光滑拼接。</p>
</blockquote>
<h2>变换</h2>
<p>为了便于对所绘图形作缩放、旋转、平移、错切以及随机扰动等处理，MetaPost 提供了一种数据类型——变换，即含有六个分量的向量：</p>
<p>$$
T = (t_x, t_y, t_{xx}, t_{xy}, t_{yx}, t_{yy})
$$</p>
<p>对于任意一点　\(p=(p_x, p_y)\)，MetaPost 的 <code>transformed</code> 命令可将 \(T\) 作用于 \(p\)，即 <code>p transformed T</code>，可将 \(p\) 变换为</p>
<p>$$
q = (t_{xx}p_x + t_{xy}p_y + t_x, t_{yx}p_x + t_{yy}p_y + t_y)
$$</p>
<p>实质上，若以仿射坐标的形式看待 \(p\)，并采用列向量 \(\left[\begin{matrix}p_x \\ p_y \\ 1\end{matrix}\right]\) 表示其坐标，则 \(T\) 的 6 个分量可形成坐标变换矩阵</p>
<p>$$
M = \left[\begin{matrix}
t_{xx} &amp; t_{xy} &amp; t_x \\
t_{yx} &amp; t_{yy} &amp; t_y \\
0 &amp; 0 &amp; 1\end{matrix}\right]
$$</p>
<p>此时，<code>p transformed T</code> 语句所描述的坐标变换，便可表示为 \(q = Mp\)。坐标变换矩阵 \(M\) 所描述的是平移、旋转、缩放以及错切等变换的组合，亦即这些特定的变换皆为 \(M\) 的特例。因此，通常并不直接提供六元组形式的变换，而是以 <code>scaled</code>、<code>shifted</code> 以及 <code>rotated</code> 等变换的组合构造一个变换。</p>
<p>假设在边长为 8cm 的正方形区域</p>
<pre class="code literal-block"><span></span><code><span class="err">numeric sidelength, u; </span>
<span class="err">sidelength := 8cm; u := 0.5sidelength;</span>
<span class="err">drawpath fullsquare scaled sidelength dashed (evenly scaled 1mm);</span>
</code></pre>

<p><img alt="" src="../images/metafun/11.png"></p>
<p>有四个点</p>
<pre class="code literal-block"><span></span><code><span class="err">pair a, b, c, d;</span>
<span class="err">a := (-0.5, -0.5) * u;</span>
<span class="err">b := (-0.5, 0.5) * u;</span>
<span class="err">c := (0.5, 0.5) * u;</span>
<span class="err">d := (0.5, -0.5) * u;</span>
</code></pre>

<p>它们构成路径 <code>p</code>，</p>
<pre class="code literal-block"><span></span><code><span class="err">path p; p := a -- b -- c -- d;</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p><img alt="" src="../images/metafun/12.png"></p>
<p>现在将 <code>p</code> 缩小为原来的 0.5 倍，可为此构造变换 <code>T</code>，</p>
<pre class="code literal-block"><span></span><code><span class="err">transform T;</span>
<span class="err">T := identity scaled 0.5;</span>
</code></pre>

<p><code>identity</code> 是 MetaPost 内置的恒等变换，其值为向量 <code>(0, 0, 1, 0, 0, 1)</code>，将其写为齐次坐标变换矩阵，可得</p>
<p>$$
\left[\begin{matrix}
1 &amp; 0  &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1\end{matrix}\right]
$$</p>
<p>因此，实际上 <code>identity</code> 表示的是单位矩阵。因此 <code>identity scaled 0.5</code> 所构造的变换，本质上是以一个单位矩阵乘以由 <code>scaled 0.5</code> 构造的缩放变换矩阵</p>
<p>$$
\left[\begin{matrix}
0.5 &amp; 0 &amp; 0 \\
0 &amp; 0.5 &amp; 0 \\
0 &amp; 0 &amp; 1\end{matrix}\right]
$$</p>
<p>在这里，<code>identity</code> 的唯一作用是喂给 <code>scaled</code> 命令，令其得以工作。因为 MetaPost 所有的特定坐标变换命令在工作时要求它的前面必须存在一个表达式，这个表达式可以是一个变换，也可以是一条路径。因此 <code>identity</code> 能够满足这些命令的需要，而且不影响它们的行为。</p>
<p>使用 <code>transformed</code> 可将 <code>T</code> 作用于路径 <code>p</code>，</p>
<pre class="code literal-block"><span></span><code><span class="err">path q; q := p transformed T;</span>
<span class="err">drawpath q withcolor .7green;</span>
<span class="err">drawpoints q withcolor .7red;</span>
</code></pre>

<p><img alt="" src="../images/metafun/13.png"></p>
<p>在 <code>T</code> 的基础上可以继续增加变换。例如，通过 <code>shifted</code> 让经过了缩放变换的 <code>p</code> 向左平移 <code>0.7 * u</code>：</p>
<pre class="code literal-block"><span></span><code><span class="err">T := T shifted (-0.7 * u, 0);</span>
<span class="err">q := p transformed T;</span>
<span class="err">drawpath  q withcolor .7blue; drawpoints q withcolor .7yellow;</span>
</code></pre>

<p><img alt="" src="../images/metafun/14.png"></p>
<p>接下来，在 <code>T</code> 的基础上，再增加一个旋转变换，令经过了缩放和平移变换后的 <code>p</code>，即 <code>p transformed T</code>，绕其中心点逆时针转动 90 度。通过 <code>rotated</code> 命令可构造旋转变换，但是该命令是以原点为中心对路径进行旋转。若对经过了缩放和平移变换后的 <code>p</code> 绕其中心作旋转变换，首先需要确定 <code>p</code> 在经过缩放和平移之后的中心点。由于 <code>p</code> 的初始中心点可根据它的 4 个节点计算出来，结果为 <code>(0, 0)</code>，亦即原点，因此只需对 <code>p</code> 的初始中心点予以 <code>T</code> 变换，便可得到变换后的 <code>p</code> 的中心点，即</p>
<pre class="code literal-block"><span></span><code><span class="err">pair pcenter;</span>
<span class="err">pcenter := (0, 0) transformed T;</span>
</code></pre>

<p>若让 <code>p transformed T</code> 围绕 <code>pcenter</code> 逆时针旋转 90 度角，需要先对 <code>p transformed T</code> 进行平移变换，令其中心与原点对准，即</p>
<pre class="code literal-block"><span></span><code><span class="err">p transofmed T shifted (-(xpart pcenter), -(ypart pcenter))</span>
</code></pre>

<p><code>xpart</code> 和 <code>ypart</code> 分别用于提取任意一点的横坐标与纵坐标分量。然后，对此刻的 <code>p</code> 逆时针旋转 90 度角，即</p>
<pre class="code literal-block"><span></span><code><span class="err">p transofmed T shifted (-(xpart pcenter), -(ypart pcenter)) rotated 90</span>
</code></pre>

<p>接下来，通过 <code>shifted</code> 将此刻的 <code>p</code> 移回原位，即</p>
<pre class="code literal-block"><span></span><code><span class="err">p transofmed T shifted (-(xpart pcenter), -(ypart pcenter)) </span>
<span class="err">               rotated 90 </span>
<span class="err">               shifted ((xpart pcenter), (ypart pcenter))</span>
</code></pre>

<p>若将上述的变换叠加到 <code>T</code> 中，即</p>
<pre class="code literal-block"><span></span><code><span class="err">T := T shifted (-(xpart pcenter), -(ypart pcenter)) </span>
<span class="err">     rotated 90 </span>
<span class="err">     shifted ((xpart pcenter), (ypart pcenter));</span>
</code></pre>

<p>将 <code>T</code> 作用于 <code>p</code>，便可实现 <code>p transformed T</code> 围绕 <code>pcenter</code> 逆时针旋转 90 度角，即</p>
<pre class="code literal-block"><span></span><code><span class="err">drawpath p transformed T withcolor .7red;</span>
<span class="err">drawpoints p transformed T withcolor .7cyan;</span>
</code></pre>

<p>不过，MetaPost 的 <code>rotatedaround</code> 变换已经实现了上述的围绕指定点对路径进行旋转的功能，因此上述的 <code>T</code> 可简写为</p>
<pre class="code literal-block"><span></span><code><span class="err">T := T rotatedaround (pcenter, 90);</span>
</code></pre>

<p>现在，在 <code>T</code> 的基础上，增加一个镜象变换，例如，以过原点 <code>(0, 0)</code> 且斜率为 1 的一条直线为镜线，将 <code>p transformed T</code> 变换为自身的影像。为了便于观察，先将镜线绘制出来，</p>
<pre class="code literal-block"><span></span><code><span class="err">pair mb, me;</span>
<span class="err">mb := (-1, -1) * u;</span>
<span class="err">me := (1, 1) * u;</span>
<span class="err">drawarrowpath mb -- me;</span>
</code></pre>

<p><img alt="" src="../images/metafun/15.png"></p>
<p><code>drawarrowpath</code> 宏可绘制路径及其走向。显然，<code>mirrorline</code> 过原点 <code>(0, 0)</code> 且斜率为 1，基于它，可构造一个镜象变换。并将其叠加至 <code>T</code>，即</p>
<pre class="code literal-block"><span></span><code><span class="err">T := T reflectedabout (mb, me);</span>
</code></pre>

<p>将 <code>T</code> 作用于 <code>p</code> 便可得到 <code>p</code> 的镜象，</p>
<pre class="code literal-block"><span></span><code><span class="err">drawpath p transformed T withcolor .7red;</span>
<span class="err">drawpoints p transformed T withcolor .7cyan;</span>
</code></pre>

<p><img alt="" src="../images/metafun/16.png"></p>
<h2>路径合成</h2>
<p>不仅变换可以叠加合成，路径也可以如此。例如，对于上一节所给出的路径 <code>p</code>，对其作旋转、平移变换，生成路径 <code>q</code>，然后通过 <code>--</code> 可将二者连接起来，即</p>
<pre class="code literal-block"><span></span><code><span class="err">path q[];</span>
<span class="err">q[1] := p scaled 0.5;</span>
<span class="err">q[2] := q[1] shifted (s, 0);</span>
<span class="err">q[3] := q[1] -- q[2];</span>
<span class="err">drawpath q[3]; drawpoints q[3];</span>
</code></pre>

<p><img alt="" src="../images/metafun/17.png"></p>
<p>在 MetaPost 中，类似 <code>q</code> 这样的变量称为带有后缀的变量。可以用此类变量模拟数组。</p>
<h2>从简单到复杂</h2>
<p>通过图形变换和路径合成，可基于简单图形，构造复杂图形。下面以 Hilbert 曲线的绘制为例，在实践中感受 MetaPost 的魅力。</p>
<p>首先，回顾路径 <code>p</code>：</p>
<pre class="code literal-block"><span></span><code><span class="nb">numeric</span> <span class="n">sidelength</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span>
<span class="n">sidelength</span> <span class="p">:</span><span class="o">=</span> <span class="mi">8</span><span class="n">cm</span><span class="p">;</span> <span class="n">u</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">sidelength</span><span class="p">;</span>
<span class="n">drawpath</span> <span class="n">fullsquare</span> <span class="n">scaled</span> <span class="mi">2</span><span class="n">s</span> <span class="n">dashed</span> <span class="p">(</span><span class="n">evenly</span> <span class="n">scaled</span> <span class="mi">1</span><span class="n">mm</span><span class="p">);</span>

<span class="n">pair</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
<span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
<span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
<span class="k">c</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
<span class="n">d</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>

<span class="n">path</span> <span class="n">p</span><span class="p">;</span> 
<span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span> <span class="c1">-- b -- c -- d;</span>
<span class="n">drawpath</span> <span class="n">p</span><span class="p">;</span> <span class="n">drawpoints</span> <span class="n">p</span><span class="p">;</span>
</code></pre>

<p><img alt="" src="../images/metafun/18.png"></p>
<p>此时的 <code>p</code>，称为 1 阶 Hilbert 曲线。</p>
<p>接下来，构造四个变换：</p>
<pre class="code literal-block"><span></span><code><span class="err">  transform sw, nw, ne, se;</span>
<span class="err">  sw := identity</span>
<span class="err">        scaled 0.5</span>
<span class="err">        reflectedabout ((0, 0), (1, 1))</span>
<span class="err">        shifted (-0.5u, -0.5u);</span>
<span class="err">  nw := identity</span>
<span class="err">        scaled 0.5</span>
<span class="err">        shifted (-0.5u, 0.5u);</span>
<span class="err">  ne := identity</span>
<span class="err">        scaled 0.5</span>
<span class="err">        shifted (0.5u, 0.5u);</span>
<span class="err">  se := identity</span>
<span class="err">        scaled 0.5</span>
<span class="err">        reflectedabout ((0, 0), (1, -1))</span>
<span class="err">        shifted (0.5u, -0.5u);</span>
</code></pre>

<p>将这四个变换分别作用于 <code>p</code> 并将生成的新路径连接起来，</p>
<pre class="code literal-block"><span></span><code><span class="err">p := p transformed sw</span>
<span class="err">     -- p transformed nw</span>
<span class="err">     -- p transformed ne</span>
<span class="err">     -- p transformed se;</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p><img alt="" src="../images/metafun/19.png"></p>
<p>所得结果称为 2 阶 Hilbert 曲线。对 <code>p</code> 再次做上述变换，便可构造出 3 阶 Hilbert 曲线，即</p>
<pre class="code literal-block"><span></span><code><span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">sw</span>
     <span class="c1">-- p transformed nw</span>
     <span class="c1">-- p transformed ne</span>
     <span class="c1">-- p transformed se;</span>

<span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">sw</span>
     <span class="c1">-- p transformed nw</span>
     <span class="c1">-- p transformed ne</span>
     <span class="c1">-- p transformed se;</span>

<span class="n">drawpath</span> <span class="n">p</span><span class="p">;</span> <span class="n">drawpoints</span> <span class="n">p</span><span class="p">;</span>
</code></pre>

<p><img alt="" src="../images/metafun/20.png"></p>
<p>依此类推，可继续构造更高阶的 Hilbert 曲线。随着阶数的升高，曲线很快会将一个正方形区域填满，例如 5 阶曲线，</p>
<p><img alt="" src="../images/metafun/21.png"></p>
<p>因此，Hilbert 曲线通常被称为空间填充曲线。利用 Hilbert 曲线，可将多维空间转化为一维连续空间。</p>
<h2>循环</h2>
<p>使用 MetaPost 的 <code>for</code> 循环语句对高阶 Hilbert 曲线的构造代码予以简化。例如构造 5 阶 Hilbert 曲线，只需</p>
<pre class="code literal-block"><span></span><code><span class="err">for i := 2 upto 5:</span>
<span class="err">    p := p transformed sw</span>
<span class="err">         -- p transformed nw</span>
<span class="err">         -- p transformed ne</span>
<span class="err">         -- p transformed se;</span>
<span class="err">endfor;</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p>若采用更为通用的 <code>for</code> 语句，上述的 <code>for</code> 代码可改为</p>
<pre class="code literal-block"><span></span><code><span class="err">for i := 2 step 1 until 5:</span>
<span class="err">    p := p transformed sw</span>
<span class="err">         -- p transformed nw</span>
<span class="err">         -- p transformed ne</span>
<span class="err">         -- p transformed se;</span>
<span class="err">endfor;</span>
</code></pre>

<p><code>step</code> 可以控制循环变量 <code>i</code> 的步长。</p>
<p><code>for</code> 也可用于对象序列的迭代访问。例如</p>
<pre class="code literal-block"><span></span><code><span class="err">p := p transformed sw</span>
<span class="err">     -- p transformed nw</span>
<span class="err">     -- p transformed ne</span>
<span class="err">     -- p transformed se;</span>
</code></pre>

<p>可写为</p>
<pre class="code literal-block"><span></span><code><span class="err">p := p transformed sw for j := nw, ne, se: -- p transformed j endfor;</span>
</code></pre>

<p>MetaPost 允许表达式中出现循环语句，而且循环的最终结果是每一轮循环所包含的内容的连接。</p>
<h2>宏</h2>
<p>在一个 MetaPost 程序里，除了数据以及注释语句之外，剩下的几乎都是宏。mpost 会将程序中所有的宏展开，从而得到最为基本的绘图语句的组合，继而 mpost 将这些基本的绘图语句翻译为 PostScript 语句，从而得到 PostScript 格式的文档。</p>
<p>宏的展开，其基本原理是文本替换。例如</p>
<pre class="code literal-block"><span></span><code><span class="err">for i := 1 upto 4:</span>
<span class="err">    MetaPost 语句;</span>
<span class="err">endfor;</span>
</code></pre>

<p>其中的 <code>upto</code> 就是一个宏，mpost 会将它的展开为 <code>step 1 until</code>。之所以如此，是因为 <code>upto</code> 的定义</p>
<pre class="code literal-block"><span></span><code><span class="err">def upto = step 1 until enddef;</span>
</code></pre>

<p><code>upto</code> 没有参数，它的展开本质上是单纯的文本替换。有参数的宏可以通过参数调整宏的展开结果；宏的参数，本质上是宏展开文本中可变的部分。</p>
<p>通过有参数的宏，可实现更具一般性的 Hilbert 曲线的构造过程。对于 Hilbert 曲线的构造过程而言，可变的部分有 Hilbert 曲线所填充的正方形区域的边长以及 Hilbert 曲线的阶数，若将二者分别用 <code>numeric</code> 类型的变量 <code>sidelength</code> 和 <code>n</code> 表示，那么一般性的 Hilbert 曲线的构造过程可表示为</p>
<pre class="code literal-block"><span></span><code><span class="nt">numeric</span> <span class="nt">u</span><span class="o">;</span> <span class="nt">u</span> <span class="o">:=</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5sidelength</span><span class="o">;</span>
<span class="nt">pair</span> <span class="nt">a</span><span class="o">,</span> <span class="nt">b</span><span class="o">,</span> <span class="nt">c</span><span class="o">,</span> <span class="nt">d</span><span class="o">;</span>
<span class="nt">a</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
<span class="nt">b</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
<span class="nt">c</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
<span class="nt">d</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>

<span class="nt">path</span> <span class="nt">p</span><span class="o">;</span> 
<span class="nt">p</span> <span class="o">:=</span> <span class="nt">a</span> <span class="nt">--</span> <span class="nt">b</span> <span class="nt">--</span> <span class="nt">c</span> <span class="nt">--</span> <span class="nt">d</span><span class="o">;</span>

<span class="nt">transform</span> <span class="nt">sw</span><span class="o">,</span> <span class="nt">nw</span><span class="o">,</span> <span class="nt">ne</span><span class="o">,</span> <span class="nt">se</span><span class="o">;</span>
<span class="nt">sw</span> <span class="o">:=</span> <span class="nt">identity</span>
      <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
      <span class="nt">reflectedabout</span> <span class="o">((</span><span class="nt">0</span><span class="o">,</span> <span class="nt">0</span><span class="o">),</span> <span class="o">(</span><span class="nt">1</span><span class="o">,</span> <span class="nt">1</span><span class="o">))</span>
      <span class="nt">shifted</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
<span class="nt">nw</span> <span class="o">:=</span> <span class="nt">identity</span>
      <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
      <span class="nt">shifted</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
<span class="nt">ne</span> <span class="o">:=</span> <span class="nt">identity</span>
      <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
      <span class="nt">shifted</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
<span class="nt">se</span> <span class="o">:=</span> <span class="nt">identity</span>
      <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
      <span class="nt">reflectedabout</span> <span class="o">((</span><span class="nt">0</span><span class="o">,</span> <span class="nt">0</span><span class="o">),</span> <span class="o">(</span><span class="nt">1</span><span class="o">,</span> <span class="nt">-1</span><span class="o">))</span>
      <span class="nt">shifted</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>

<span class="nt">for</span> <span class="nt">i</span> <span class="o">:=</span> <span class="nt">2</span> <span class="nt">upto</span> <span class="nt">n</span><span class="o">:</span>
  <span class="nt">p</span> <span class="o">:=</span> <span class="nt">p</span> <span class="nt">transformed</span> <span class="nt">sw</span> <span class="nt">for</span> <span class="nt">j</span> <span class="o">:=</span> <span class="nt">nw</span><span class="o">,</span> <span class="nt">ne</span><span class="o">,</span> <span class="nt">se</span><span class="o">:</span> <span class="nt">--</span> <span class="nt">p</span> <span class="nt">transformed</span> <span class="nt">j</span> <span class="nt">endfor</span><span class="o">;</span>
<span class="nt">endfor</span><span class="o">;</span>

<span class="nt">drawpath</span> <span class="nt">p</span><span class="o">;</span> <span class="nt">drawpoints</span> <span class="nt">p</span><span class="o">;</span>
</code></pre>

<p>将上述语句作为宏 <code>hilbert</code> 的替换文本，并将 <code>sidelength</code> 和 <code>n</code> 作为 <code>hilbert</code> 宏的参数，则 <code>hilbert</code> 宏可定义为</p>
<pre class="code literal-block"><span></span><code><span class="nt">def</span> <span class="nt">hilbert</span><span class="o">(</span><span class="nt">expr</span> <span class="nt">sidelength</span><span class="o">,</span> <span class="nt">n</span><span class="o">)</span> <span class="o">=</span> 
  <span class="nt">numeric</span> <span class="nt">u</span><span class="o">;</span> <span class="nt">u</span> <span class="o">:=</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5sidelength</span><span class="o">;</span>
  <span class="nt">pair</span> <span class="nt">a</span><span class="o">,</span> <span class="nt">b</span><span class="o">,</span> <span class="nt">c</span><span class="o">,</span> <span class="nt">d</span><span class="o">;</span>
  <span class="nt">a</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
  <span class="nt">b</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
  <span class="nt">c</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>
  <span class="nt">d</span> <span class="o">:=</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5</span><span class="o">)</span> <span class="o">*</span> <span class="nt">u</span><span class="o">;</span>

  <span class="nt">path</span> <span class="nt">p</span><span class="o">;</span> 
  <span class="nt">p</span> <span class="o">:=</span> <span class="nt">a</span> <span class="nt">--</span> <span class="nt">b</span> <span class="nt">--</span> <span class="nt">c</span> <span class="nt">--</span> <span class="nt">d</span><span class="o">;</span>

  <span class="nt">transform</span> <span class="nt">sw</span><span class="o">,</span> <span class="nt">nw</span><span class="o">,</span> <span class="nt">ne</span><span class="o">,</span> <span class="nt">se</span><span class="o">;</span>
  <span class="nt">sw</span> <span class="o">:=</span> <span class="nt">identity</span>
        <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
        <span class="nt">reflectedabout</span> <span class="o">((</span><span class="nt">0</span><span class="o">,</span> <span class="nt">0</span><span class="o">),</span> <span class="o">(</span><span class="nt">1</span><span class="o">,</span> <span class="nt">1</span><span class="o">))</span>
        <span class="nt">shifted</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
  <span class="nt">nw</span> <span class="o">:=</span> <span class="nt">identity</span>
        <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
        <span class="nt">shifted</span> <span class="o">(</span><span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
  <span class="nt">ne</span> <span class="o">:=</span> <span class="nt">identity</span>
        <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
        <span class="nt">shifted</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>
  <span class="nt">se</span> <span class="o">:=</span> <span class="nt">identity</span>
        <span class="nt">scaled</span> <span class="nt">0</span><span class="p">.</span><span class="nc">5</span>
        <span class="nt">reflectedabout</span> <span class="o">((</span><span class="nt">0</span><span class="o">,</span> <span class="nt">0</span><span class="o">),</span> <span class="o">(</span><span class="nt">1</span><span class="o">,</span> <span class="nt">-1</span><span class="o">))</span>
        <span class="nt">shifted</span> <span class="o">(</span><span class="nt">0</span><span class="p">.</span><span class="nc">5u</span><span class="o">,</span> <span class="nt">-0</span><span class="p">.</span><span class="nc">5u</span><span class="o">);</span>

  <span class="nt">for</span> <span class="nt">i</span> <span class="o">:=</span> <span class="nt">2</span> <span class="nt">upto</span> <span class="nt">n</span><span class="o">:</span>
    <span class="nt">p</span> <span class="o">:=</span> <span class="nt">p</span> <span class="nt">transformed</span> <span class="nt">sw</span> <span class="nt">for</span> <span class="nt">j</span> <span class="o">:=</span> <span class="nt">nw</span><span class="o">,</span> <span class="nt">ne</span><span class="o">,</span> <span class="nt">se</span><span class="o">:</span> <span class="nt">--</span> <span class="nt">p</span> <span class="nt">transformed</span> <span class="nt">j</span> <span class="nt">endfor</span><span class="o">;</span>
  <span class="nt">endfor</span><span class="o">;</span>

  <span class="nt">drawpath</span> <span class="nt">p</span><span class="o">;</span> <span class="nt">drawpoints</span> <span class="nt">p</span><span class="o">;</span>
<span class="nt">enddef</span><span class="o">;</span>
</code></pre>

<p><code>(expr sidelength, n)</code> 为 <code>hilbert</code> 的参数列表，<code>expr</code> 表示参数 <code>sidelength</code> 和 <code>n</code> 的类型皆为 MetaPost 的表达式。除了 <code>expr</code> 之外，MetaPost 还支持 <code>text</code> 和 <code>suffix</code> 类型的参数。<code>text</code> 类型的参数可以是任意 MetaPost 语句，但结尾必须为 <code>;</code>。<code>suffix</code> 表示含有后缀的变量，可将该类变量其理解为数组。需要注意，宏的参数，在其替换文本中不能再重新声明或赋值。</p>
<p>现在调用 <code>hilbert</code> 宏，便可将其展开为任意阶数的 Hilbert 曲线的构造及绘制语句。例如，在边长为 8cm 的正方形区域内构造并绘制 4 阶的 Hilbert 曲线，只需</p>
<pre class="code literal-block"><span></span><code><span class="err">hilbert(8cm, 4);</span>
</code></pre>

<h2>条件</h2>
<p><code>hilbert</code> 宏有一个 Bug，它无法构造 1 阶 Hilbert 曲线——路径 <code>p</code> 的初始状态。要修复这个 Bug，需要使用条件语句</p>
<pre class="code literal-block"><span></span><code><span class="err">if 条件:</span>
<span class="err">  语句;</span>
<span class="err">elseif 条件:</span>
<span class="err">  语句;</span>
<span class="c">else:</span>
<span class="c">  语句;</span>
<span class="err">fi</span>
</code></pre>

<p>其中，<code>elseif</code> 部分可选。</p>
<p>可在构造 Hilbert 曲线的循环中，利用条件语句，将 <code>n = 1</code> 视为特殊情况，在这种情况中不对 <code>p</code> 进行变换，如此便可得到正确阶树的 Hilbert 曲线，亦即，将 <code>hilbert</code> 宏的替换文本中的</p>
<pre class="code literal-block"><span></span><code><span class="err">for i := 2 upto n:</span>
<span class="err">  p := p transformed sw for j := nw, ne, se: -- p transformed j endfor;</span>
<span class="err">endfor;</span>
</code></pre>

<p>修改为</p>
<pre class="code literal-block"><span></span><code><span class="err">if n &gt; 1:</span>
<span class="err">  for i := 2 upto n:</span>
<span class="err">    p := p transformed sw for j := nw, ne, se: -- p transformed j endfor;</span>
<span class="err">  endfor;</span>
<span class="err">fi</span>
</code></pre>

<p>如此，便修复了 <code>hilbert</code> 宏在曲线阶数上的 Bug。</p>
<h2>数据与绘图分离</h2>
<p><code>hilbert</code> 宏的定义还存在一个问题，它做的事情太多了，不仅负责 Hilbert 曲线的构造，还负责曲线的绘制。做的事情多，并不意味着功能更强大。若需要对线条的颜色以及粗细虚实予以调整，需要修改 <code>hilbert</code> 宏的定义。应对这些变化，最简单的方法是让 <code>hilbert</code> 不负责绘图，只负责生成 Hilbert 曲线路径。为达到这一目的，需要用 <code>vardef</code> 来定义 <code>hilbert</code> 宏，即</p>
<pre class="code literal-block"><span></span><code><span class="n">vardef</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">expr</span> <span class="n">sidelength</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> 
  <span class="n">numeric</span> <span class="n">u</span><span class="p">;</span> <span class="n">u</span> <span class="p">:</span><span class="o">=</span> <span class="mf">0.5</span><span class="n">sidelength</span><span class="p">;</span>
  <span class="n">pair</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">c</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">d</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>

  <span class="n">path</span> <span class="n">p</span><span class="p">;</span> 
  <span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span> <span class="o">--</span> <span class="n">b</span> <span class="o">--</span> <span class="n">c</span> <span class="o">--</span> <span class="n">d</span><span class="p">;</span>

  <span class="n">transform</span> <span class="n">sw</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">se</span><span class="p">;</span>
  <span class="n">sw</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">reflectedabout</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">nw</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">ne</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">se</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">reflectedabout</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>

  <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">2</span> <span class="n">upto</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">sw</span> <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="n">nw</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">se</span><span class="p">:</span> <span class="o">--</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">j</span> <span class="n">endfor</span><span class="p">;</span>
  <span class="n">endfor</span><span class="p">;</span>
  <span class="n">p</span>
<span class="n">enddef</span><span class="p">;</span>
</code></pre>

<p>使用 <code>vardef</code> 定义的宏，其替换文本的最后一句即为宏返回的结果。将 <code>p</code> 作为 <code>hilbert</code> 宏的替换文本的最后一句，便可使得 <code>hilbert</code> 返回 Hilbert 曲线路径。</p>
<p>若测试 <code>hilbert</code> 宏能否满足需求，只需</p>
<pre class="code literal-block"><span></span><code><span class="err">path p; p := hilbert(8cm, 3);</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p>使用 <code>randomized</code> 命令对 <code>p</code> 作轻微的随机扰动，可使得 Hilbert 曲线具备一丝艺术气息，</p>
<pre class="code literal-block"><span></span><code><span class="err">path p; p := hilbert(8cm, 3) randomized 5mm;</span>
<span class="err">drawpath p; drawpoints p;</span>
</code></pre>

<p><img alt="" src="../images/metafun/22.png"></p>
<p><code>randomized</code> 能够对出现在它之前的对象按指定幅度予以随机扰动。路径出现于 <code>randomized</code> 之前，则路径中的所有节点的位置会被随机扰动。</p>
<h2>变量的作用域</h2>
<p>调用 <code>hilbert</code> 宏，即使将其将其返回的路径赋予变量 <code>q</code>，但依然可以用 <code>p</code> 访问 <code>hilbert</code> 所生成的路径：</p>
<pre class="code literal-block"><span></span><code><span class="err">path q; q := hilbert(5cm, 3);</span>
<span class="err">drawpath p withcolor .625gren;</span>
<span class="err">drawpoints p withcolor .625red;</span>
</code></pre>

<p>这意味着在 <code>hilbert</code> 宏的定义中出现的变量 <code>p</code>，在 <code>hilbert</code> 宏的外部也是可见的。之所以出现这样的结果，原因在于 MetaPost 语言中，除了循环结构的变量之外，几乎所有的变量默认皆为全局变量。例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">for i := 1 upto 5:</span>
<span class="err">    path p;</span>
<span class="err">    p := fullsquare scaled (i * 1cm) shifted (i * 1cm, 0);</span>
<span class="err">endfor;</span>
<span class="err">drawpath p;</span>
</code></pre>

<p>其中，<code>p</code> 为全局变量，但 <code>i</code> 为局部变量。</p>
<p>若要构造一些局部变量，需要使用 <code>begingroup ... endgroup</code> 以及 <code>save</code> 语句。例如，</p>
<pre class="code literal-block"><span></span><code><span class="n">begingroup</span>
<span class="n">save</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
<span class="nb">numeric</span> <span class="n">s</span><span class="p">;</span> <span class="n">path</span> <span class="n">q</span><span class="p">;</span>
<span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="mi">5</span><span class="n">cm</span><span class="p">;</span>
<span class="n">q</span> <span class="p">:</span><span class="o">=</span> <span class="n">fullsquare</span> <span class="n">scaled</span> <span class="n">s</span> <span class="n">shifted</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">endgroup</span><span class="p">;</span>

<span class="n">drawpath</span> <span class="n">p</span><span class="p">;</span>
</code></pre>

<p>在绘制路径 <code>p</code> 时，mpost 会报错，因为所绘制的路径并不存在。</p>
<p><code>begingroup ... endgroup</code> 构造了一个作用域，<code>save</code> 则用于声明局部变量的名字。若该结构在宏的定义中使用，便可以对宏内所用的一些不想被外部所知的变量给予保护。</p>
<h2>线性方程</h2>
<p>mpost 具备线性方程求解的功能。基于这一功能，mpost 可动态确定变量类型。例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">a = 1;</span>
</code></pre>

<p>这里的 <code>=</code> 并非赋值运算符。MetaPost 的赋值运算是上文中一直使用的 <code>:=</code>。这里的 <code>=</code> 表示方程或等式。在上文讲述条件结构的时候，已见识了它。mpost 会对这个方程进行求解，结果是变量 <code>a</code> 的值为 1，因此这条语句等价于</p>
<pre class="code literal-block"><span></span><code><span class="err">numeric a;</span>
<span class="err">a := 1;</span>
</code></pre>

<p>对于</p>
<pre class="code literal-block"><span></span><code><span class="err">a + 2b = 5;</span>
<span class="err">3b = 7;</span>
</code></pre>

<p>mpost 的求解结果为</p>
<pre class="code literal-block"><span></span><code><span class="err">a = 0.33333;</span>
<span class="err">b = 2.33333;</span>
</code></pre>

<p>对于</p>
<pre class="code literal-block"><span></span><code><span class="err">a = (2cm, 3cm);</span>
</code></pre>

<p>mpost 会报错，它认为一个数值与一个点无法构成方程，但是将变量名称写成以 <code>z</code> 开头带有后缀的形式，便可构成方程，例如</p>
<pre class="code literal-block"><span></span><code><span class="err">z1 = (2cm, 3cm);</span>
</code></pre>

<p>mpost 会将 <code>z1</code> 视为一个点 <code>(x1, y1)</code>，因此上述方程本质上是</p>
<pre class="code literal-block"><span></span><code><span class="err">(x1, y1) = (2cm, 3cm);</span>
</code></pre>

<p>反之，倘若 mpost 求解了以下方程</p>
<pre class="code literal-block"><span></span><code><span class="err">x1 = 3cm; </span>
<span class="err">y1 = 4cm;</span>
</code></pre>

<p>就相当于定义了点 <code>z1 = (3cm, 4cm)</code>。变量名称的后缀，可以是数字，也可以是数字 + 字母，还可以是 <code>.</code> + 数字或字母，例如：</p>
<pre class="code literal-block"><span></span><code><span class="err">z3 = z1; z3r = z1; z.3 = z1; z.3r = z1;</span>
</code></pre>

<p>除了可用于节省变量的声明之外，利用 mpost 求解线性方程的功能确定两条线段的交点也极为方便。例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">path p, q;</span>
<span class="err">z0 = (0, 0); z1 = (7cm, 5cm); z2 = (0, 3cm); z3 = (7cm, 3cm);</span>
<span class="err">p := z0 -- z1;</span>
<span class="err">q := z2 -- z3;</span>
<span class="err">z4 = whatever[z0, z1] = whatever[z2, z3];</span>
<span class="err">drawpath p; drawpath q;</span>
<span class="err">drawpoints z4;</span>
</code></pre>

<p><img alt="" src="../images/metafun/23.png"></p>
<p><code>whatever[z0, z1]</code> 表示 <code>z0 -- z1</code> 上的任意一点。若写为 <code>0.5[z0, z1]</code> 表示线段 <code>z0 -- z1</code> 的中点。若写为 <code>1/3[z0, z1]</code> 则表示 <code>z0 -- z1</code> 距离 <code>z0</code> 最近的三等分点。<code>[z0, z1]</code> 这样的写法表示由线段 <code>z0 -- z1</code> 构成的区间。两个数也能构成区间，例如 <code>[2, 4]</code>，再例如 <code>0.5[2, 4]</code> 的结果为 3。</p>
<h2>MetaFun：MetaPost + ConTeXt</h2>
<p>MetaPost 绘制的图形，通过 MetaFun 便可与 ConTeXt 的排版元素取得结合，从而显著增强 ConTeXt 的排版能力。例如，可以将一条 Hilbert 曲线作为文本框的背景。当然，只要能够绘制 Hilbert 曲线，将其保存为单页面文件，几乎任何一个功能健全的排版软件都能够以该图形作为文本框的背景，但是一旦图形被保存为文件，这就意味着图形失去了可变性，只适于作为特定尺寸的文本框的背景。</p>
<p>假设将一条三阶 Hilbert 曲线以矢量图的形式保存为单页面文件 hilbert-3.pdf，那么在 ConTeXt 中可通过覆盖（Overlay）的方式将其作为文本框的背景图片，即</p>
<pre class="code literal-block"><span></span><code><span class="k">\usemodule</span><span class="na">[zhfonts]</span>

<span class="k">\defineoverlay</span><span class="na">[hilbert][{\externalfigure[hilbert-3.pdf]</span><span class="nb">}</span>]
<span class="k">\setupframed</span>
  [background=hilbert,
    width=8cm,
    height=4cm,
    align=middle,
    location=lohi,
    align=<span class="nb">{</span>middle,lohi,broad<span class="nb">}</span>]

<span class="k">\starttext</span>
<span class="k">\framed</span><span class="nb">{</span><span class="k">\bfd</span> 天地一指也<span class="k">\\</span> 万物一马也<span class="nb">}</span>
<span class="k">\stoptext</span>
</code></pre>

<p><img alt="" src="../images/metafun/24.png"></p>
<p>若直接以 hilbert-3.pdf 文件所包含的图形作为文本框（即 <code>\framed</code>）的背景，那么背景图片的尺寸默认是 hilbert-3.pdf 文件所包含的图形的尺寸。显然，这个尺寸太大了，背景图片超出了文本框。</p>
<p>理想的文本框背景应该与文本框的尺寸相等。可通过变量（TeX 宏） <code>\overlaywidth</code> 和 <code>\overlayheight</code> 获得当前的文本框的宽度和高度，并基于这两个尺寸，对背景图片的尺寸进行调整，使之适应文本框，即</p>
<pre class="code literal-block"><span></span><code><span class="k">\usemodule</span><span class="na">[zhfonts]</span>

<span class="k">\defineoverlay</span>
  [hilbert]
  [<span class="nb">{</span><span class="k">\externalfigure</span>
      [hilbert-3.pdf]
      [width=<span class="k">\overlaywidth</span>, height=<span class="k">\overlayheight</span>]<span class="nb">}</span>]
<span class="k">\setupframed</span>
  [background=hilbert,
    width=8cm,
    height=4cm,
    align=middle,
    location=lohi,
    align=<span class="nb">{</span>middle,lohi,broad<span class="nb">}</span>]

<span class="k">\starttext</span>
<span class="k">\framed</span><span class="nb">{</span><span class="k">\bfd</span> 天地一指也<span class="k">\\</span> 万物一马也<span class="nb">}</span>
<span class="k">\stoptext</span>
</code></pre>

<p><img alt="" src="../images/metafun/25.png"></p>
<p>现在，背景图片被硬性地塞入了文本框，结果导致 Hilbert 曲线的线条变细，并且横向的线条被圧扁了。这正是以图形文件中的图形作为文本框背景的弊端所在，即背景图形中的线条失真。此外，经过缩放的 Hilbert 曲线，虽然恰好能够充满文本框，但实际上并不正确，因为 3 阶的 Hilbert 曲线是不可能恰好充满它所填充的空间。这些失真在 MetaPost 绘图过程中不会出现。当 MetaPost 通过 MetaFun 与 ConTeXt 取得融合时，ConTeXt 的排版元素便能够享有这一优势。</p>
<p>为实现 MetaPost 与 ConTeXt 排版元素的融合，MetaFun 提供了 <code>uniqueMPgraphic</code> 环境，在该环境内编写 MetaPost 程序，然后这个环境可以像插图那样在 ConTeXt 排版元素中使用。例如，</p>
<pre class="code literal-block"><span></span><code>\<span class="n">startuniqueMPgraphic</span><span class="p">{</span><span class="n">hilbert</span><span class="o">-</span><span class="mi">3</span><span class="p">}</span>
<span class="n">vardef</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">expr</span> <span class="n">sidelength</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> 
  <span class="n">u</span> <span class="o">=</span> <span class="mf">0.5</span><span class="n">sidelength</span><span class="p">;</span>
  <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">z2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">z3</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">z4</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">;</span>

  <span class="n">path</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">z1</span> <span class="o">--</span> <span class="n">z2</span> <span class="o">--</span> <span class="n">z3</span> <span class="o">--</span> <span class="n">z4</span><span class="p">;</span>

  <span class="n">transform</span> <span class="n">sw</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">se</span><span class="p">;</span>
  <span class="n">sw</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">reflectedabout</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">nw</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">ne</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>
  <span class="n">se</span> <span class="p">:</span><span class="o">=</span> <span class="n">identity</span>
        <span class="n">scaled</span> <span class="mf">0.5</span>
        <span class="n">reflectedabout</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">shifted</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">u</span><span class="p">);</span>

  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">upto</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">sw</span> <span class="k">for</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="n">nw</span><span class="p">,</span> <span class="n">ne</span><span class="p">,</span> <span class="n">se</span><span class="p">:</span> <span class="o">--</span> <span class="n">p</span> <span class="n">transformed</span> <span class="n">j</span> <span class="n">endfor</span><span class="p">;</span>
  <span class="n">endfor</span><span class="p">;</span>
  <span class="n">p</span>
<span class="n">enddef</span><span class="p">;</span>

<span class="n">path</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">OverlayWidth</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">drawpath</span> <span class="n">p</span> <span class="n">yscaled</span> <span class="p">(</span><span class="n">OverlayHeight</span> <span class="o">/</span> <span class="n">OverlayWidth</span><span class="p">);</span>
\<span class="n">stopuniqueMPgraphic</span>
</code></pre>

<p>在上述名为 <code>hilbert-3</code> 的 <code>uniqueMPgraphic</code> 环境中，对 <code>hilbert</code> 宏所生成的 Hibert 曲线，根据变量 <code>OverlayWitdh</code> 和 <code>OverlayHeight</code> 的值给出了适应性的缩放，亦即在 <code>uniqueMPgraphic</code> 环境中，MetaPost 程序可以共享 ConTeXt 排版元素的一些变量。</p>
<p>若将上述 <code>uniqueMPgraphic</code> 环境作为文本框的背景图片，只需</p>
<pre class="code literal-block"><span></span><code><span class="k">\defineoverlay</span><span class="na">[hilbert][\uniqueMPgraphic{hilbert-3}]</span>
<span class="k">\setupframed</span>
  [background=hilbert,
    width=8cm,
    height=4cm,
    align=middle,
    location=lohi,
    align=<span class="nb">{</span>middle,lohi,broad<span class="nb">}</span>]

<span class="k">\starttext</span>
<span class="k">\framed</span><span class="nb">{</span><span class="k">\bfd</span> 天地一指也<span class="k">\\</span> 万物一马也<span class="nb">}</span>
<span class="k">\stoptext</span>
</code></pre>

<p>结果可得</p>
<p><img alt="" src="../images/metafun/26.png"></p>
<p>使用 <code>\framed</code> 的 <code>frame=off</code> 可以隐藏文本框的边框，这样便可得到以 3 阶 Hilbert 曲线作为背景的文本框，而且背景的尺寸能够适应文本框的尺寸的变化。例如，</p>
<pre class="code literal-block"><span></span><code><span class="k">\setupframed</span><span class="na">[frame=off]</span>
<span class="k">\midaligned</span><span class="nb">{</span><span class="k">\framed</span><span class="nb">{</span><span class="k">\bfd</span> 天地一指也<span class="k">\\</span> 万物一马也<span class="nb">}}</span>
<span class="k">\blank</span><span class="na">[1cm]</span>
<span class="k">\midaligned</span><span class="nb">{</span><span class="k">\framed</span><span class="na">[width=12cm, height=3cm]</span><span class="nb">{</span><span class="k">\bfd</span> 天地一指也<span class="k">\\</span> 万物一马也<span class="nb">}}</span>
</code></pre>

<p><img alt="" src="../images/metafun/27.png"></p>
<p>以上仅以文本框为例，简单介绍了 ConTeXt 与 MetaPost 的结合。事实上，对于 ConTeXt 的任一排版元素，只要它具备 <code>background</code> 选项，便可以利用 MetaPost 图形为其构建背景图形。即使一些排版元素不具备 <code>background</code> 选项，但是只要它们具备 <code>command</code> 选项，便可以通过嵌入文本框的方式与 MetaPost 图形结合。</p>
<h2>结语</h2>
<p>有关 MetaFun 更为详细的介绍见荷兰人 Hans Hagen 所写的 MetaFun 手册 <strong><sup><a href="../images/metafun/10.png">10</a></sup></strong> 。Hans Hagen 即是 ConTeXt 的开发者，也是 MetaFun 的开发者。</p>
<p>对于以编程的方式绘制精确二维矢量图这种任务而言，MetaPost 是一种功能强大的编程语言。不过，适合这一任务的功能强大的编程语言并不少，譬如 LaTeX 的小伙伴 pgf/tikz，擅长绘制三维矢量图的 Asymptote，擅长绘制图表的 gnuplot、MathGL 等。与这些同类相比，MetaPost 胜出之处在于语法的优雅。</p>
<p>MetaPost 语法的优雅一方面来自于它的宏编程特质。像每一种优雅都来自刻苦地训练一样，MetaPost 的优雅也并非朝发夕至之工可致。在编写这篇文章的一些简单示例的过程中，mpost 崩溃次数难以历数，而且它的每次崩溃几乎都会给出冗长的出错信息，需要像侦探一样从中查出端倪。因此，MetaPost 的优雅只是会向那些绘制精确矢量图这种任务乐此不疲的人绽放。另一方面，MetaPost MetaPost 绘图命令与英文的语法相近，即「谓语 + 宾语 + 定语 + 状语」的形式，例如，</p>
<pre class="code literal-block"><span></span><code><span class="err">主语 I（省略） + 谓语 draw + 路径 p + 定语 scaled 0.5 + 状语 withcolor .8red;</span>
</code></pre>

<p>MetaFun 的出现，为 MetaPost 在排版领域开辟了用武之地。在文档排版方面，利用 MetaPost 所绘制的精确的矢量图形为一些排版元素构造背景，使得文档的排版更为精美。</p>
<p>绘图是一门艺术。排版也是一门艺术。艺术的重要性在于它能够开拓人类的思维空间。使用 MetaPost 绘图，使用 ConTeXt 对文档进行排版则是技术。艺术的空间需要借助技术去探索或开拓。MetaFun 贯通了 MetaPost 和 ConTeXt，意味着具备了探索或开拓计算机绘图与排版相融合的艺术空间的一种工具。</p>
<hr>
<p><strong>引用的文献：</strong></p>
<p>[1]  <a href="https://segmentfault.com/a/1190000003779240">序幕有些长</a></p>
<p>[2]  <a href="https://segmentfault.com/a/1190000003786283">睦邻友好的 ConTeXt Standalone</a></p>
<p>[3]  <a href="https://segmentfault.com/a/1190000003790820">先写作，后排版</a></p>
<p>[4]  <a href="https://segmentfault.com/a/1190000003795931">ConTeXt MkIV 中文支持</a></p>
<p>[5]  <a href="http://segmentfault.com/a/1190000003797764">文稿的物理结构</a></p>
<p>[6]  <a href="http://segmentfault.com/a/1190000003798231">文稿的逻辑结构</a></p>
<p>[7]  <a href="http://segmentfault.com/a/1190000003803997">页面布局</a></p>
<p>[8]  <a href="http://www.pragma-ade.nl/general/manuals/ma-cb-en.pdf">ConTeXt Mark IV an excursion</a></p>
<p>[9]  <a href="http://pmrb.free.fr/contextref.pdf">ConTeXt Reference</a></p>
<p>[10]  <a href="http://www.pragma-ade.com/general/manuals/metafun-p.pdf">MetaFun Manual</a></p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/awk.html" class="u-url">AWK 小传</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/awk.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-10-20T18:22:36+08:00" itemprop="datePublished" title="2018-10-20 18:22">2018-10-20 18:22</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>awk 是一种专事文本解析与处理的解释型编程语言，其解释器与其同名<strong><sup>注 1</sup></strong>。awk 原始版本发布于 1977 年，后于 1985 年发布第一个增强版本。在这一时期，awk 羽翼渐丰，随后成为 Unix 系统的一个标准（POSIX 标准）组件。目前 Linux 系统配备的 awk 皆为 gawk，隶属 GNU 项目，伊始于 1986 年。</p>
<blockquote>
<p><strong>注 1</strong>：awk 得名于它的三位开发者 Alfred V. Aho、Peter J. Weinberger 以及 Brian W. Kernighan 名字的首字母。</p>
</blockquote>
<p>awk 的设计深受 Unix 系统中的文本检索工具 grep 与文本编辑工具 sed 的启发，其语法借鉴了 C 语言。</p>
<h2>模式-动作</h2>
<p>「模式-动作」逻辑是 awk 语言的精华所在。awk 认为自身所处理的文本文件里依序存储着一组记录。awk 默认将文件中的每一行视为一条记录<strong><sup>注 2</sup></strong>，通过模式检索特定记录，而后通过动作修改记录的内容。模式由逻辑表达式或正则表达式构成，而动作则由一组用于分析或处理文本的语句构成。在 awk 解释器看来，模式和动作形成的整体即程序，文件里的每条记录则为程序的输入数据，而动作所产生的结果则为程序的输出数据。</p>
<blockquote>
<p><strong>注 2</strong>：下文在讲述记录分割符变量 <code>RS</code> 时，再给出让 awk 将多行文本视为一条记录的方法。</p>
</blockquote>
<p>例如，对于任意一份文本文件 foo.txt，若仅输出其第三行，可通过 awk 程序</p>
<pre class="code literal-block"><span></span><span class="nb">NR</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span> <span class="kr">print</span> <span class="o">$</span><span class="mi">0</span> <span class="p">}</span>
</pre>


<p>来实现，其中 <code>NR == 3</code> 为模式，而 <code>print $0</code> 为动作。<code>NR</code> 与 <code>$0</code> 皆为 awk 解释器内部维护的变量，前者用于保存 awk 解释器目前所读入的记录的序号，后者用于保存记录的内容。</p>
<p>将上述 awk 程序以及 foo.txt 作为 awk 解释器的输入数据，即在终端中执行</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'NR == 3 { print $0 }'</span> foo.txt
</pre>


<p>则 awk 解释器的输出结果即为 foo.txt 的第三行——awk 解释器默认将其视为第三条记录。为了防止 Shell 误解 awk 程序中的一些成分，必须将后者用单引号拘禁。</p>
<p>上述命令诠释了 awk 解释器、awk 程序以及所处理的文本文件这三者之间的联系。在 awk 的实际应用中，我们需要对所处理的文本文件中的记录有足够的了解，剩下的任务则是编写 awk 程序，即</p>
<pre class="code literal-block"><span></span><span class="err">模式</span> <span class="p">{</span> <span class="err">动作</span> <span class="p">}</span>
</pre>


<p>awk 解释器会顺序读取所处理的文本文件里的每一条记录，并验证它是否与模式相匹配。凡是与模式相匹配的记录，便会受模式之后的动作的操控。</p>
<p>模式-动作可叠加起来作用于文件的每一条记录。例如，</p>
<pre class="code literal-block"><span></span><span class="go">awk 'NR == 3 { print $0 }; NR == 4 { print $0 }' foo.txt</span>
</pre>


<p>可以输出 foo.txt 的第 3、4 行。</p>
<p>不妨将 awk 程序里的动作理解为电路，将模式理解为开关。记录与模式匹配时，相当于触动了开关，使得电路得以导通。多条模式-动作，相当于有多个候选的开关及电路。</p>
<p>模式可以为空，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'{ print $0 }'</span> foo.txt
</pre>


<p>此时，awk 会将动作作用于每一条记录。类似地，动作也可以为空，例如</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'NR == 3'</span> foo.txt
</pre>


<p>此时，awk 会输出与模式相匹配的每一条记录，这一动作正是 <code>{ print $0 }</code>。</p>
<p>模式-动作的逻辑本质上是所有编程语言中的条件分支结构的泛化。Erlang、Racket、OCaml、Haskell、Swift 等语言提供了令其爱好者们引以为傲的模式匹配的语法所反映的也是这一逻辑。现在，知道了早在 1977 年 awk 便已经极为自然地建立了这一逻辑，应当由衷而叹，太阳底下果然没什么新鲜事！</p>
<h2>脚本</h2>
<p>为了让 awk 解释器能够在读取文件之前以及所有记录处理殆尽之后也能够有所动作，awk 语言提供了 <code>BEGIN</code> 和 <code>END</code> 这两个特殊的模式。因此较为完整的 awk 程序，其结构通常为</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span> <span class="err">读取文件之前的动作</span> <span class="p">}</span>
<span class="err">模式</span> <span class="mi">1</span> <span class="p">{</span> <span class="err">动作</span> <span class="mi">1</span> <span class="p">}</span>
<span class="err">模式</span> <span class="mi">2</span> <span class="p">{</span> <span class="err">动作</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">...</span> <span class="p">...</span> <span class="p">...</span>
<span class="err">模式</span> <span class="nx">n</span> <span class="p">{</span> <span class="err">动作</span> <span class="nx">n</span> <span class="p">}</span>
<span class="nb">END</span> <span class="p">{</span> <span class="err">所有记录处理殆尽之后的动作</span> <span class="p">}</span>
</pre>


<p>如此便难以在终端里以命令参数的形式将程序交于 awk 解释器。再者，对于复杂的 awk 程序，若欲重复使用，命令参数的形式也多极为不便。为此，awk 解释器支持以脚本的形式载入程序，亦即可将 awk 程序保存为一份文件，而后让 awk 读取该文件以获得程序。此种文件即 awk 脚本。</p>
<p>awk 解释器可通过 <code>-f</code> 选项载入脚本中的程序。例如，制作一份简单的 awk 脚本 hello-world.awk，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> cat &lt;&lt; <span class="s1">'EOF'</span> &gt; hello-world.awk
<span class="go">BEGIN {</span>
<span class="go">        print "Hello"</span>
<span class="go">}</span>

<span class="go">NR == 5 {</span>
<span class="go">        print $0</span>
<span class="go">}</span>

<span class="go">NR == 6 {</span>
<span class="go">        print $0</span>
<span class="go">}</span>

<span class="go">END {</span>
<span class="go">        print "world!"</span>
<span class="go">}</span>
<span class="go">EOF</span>
</pre>


<p>然后随意建立一份文本文件 foo.txt，</p>
<pre class="code literal-block"><span></span>$ cat <span class="s">&lt;&lt; EOF &gt; foo.txt</span>
<span class="s">以指喻指之非指</span>
<span class="s">不若以非指喻指之非指也</span>
<span class="s">以马喻马之非马</span>
<span class="s">不若以非马喻马之非马也</span>
<span class="s">天地一指也</span>
<span class="s">万物一马也</span>
<span class="s">EOF</span>
</pre>


<p>若执行</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk -f hello-world.awk foo.txt
</pre>


<p>则结果为</p>
<pre class="code literal-block"><span></span>Hello
天地一指也
万物一马也
world!
</pre>


<p>脚本 hello-world.awk 的内容可简化为</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span>
        <span class="kr">print</span> <span class="s2">"Hello"</span>
<span class="p">}</span>

<span class="nb">NR</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="nb">NR</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">{</span>
        <span class="kr">print</span> <span class="o">$</span><span class="mi">0</span>
<span class="p">}</span>

<span class="nb">END</span> <span class="p">{</span>
        <span class="kr">print</span> <span class="s2">"world!"</span>
<span class="p">}</span>
</pre>


<p>还可进一步简化为</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span>
        <span class="kr">print</span> <span class="s2">"Hello"</span>
<span class="p">}</span>

<span class="nb">NR</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="nb">NR</span> <span class="o">==</span> <span class="mi">6</span>

<span class="nb">END</span> <span class="p">{</span>
        <span class="kr">print</span> <span class="s2">"world!"</span>
<span class="p">}</span>
</pre>


<p><code>||</code> 是逻辑运算「或」。awk 中基本的逻辑运算符号皆与 C语言同。</p>
<p>在 awk 语言中，<code>;</code> 与换行等价，因此上述内容亦可写为</p>
<pre class="code literal-block"><span></span>BEGIN { print "Hello" }; NR == 5 || NR == 6; END { print "world!"}
</pre>


<h2>流程控制语句</h2>
<p>awk 提供了 <code>if</code> ... <code>else if</code> ... <code>else</code> 条件分支以及 <code>for</code>、<code>while</code>、<code>do ... while</code> 等循环结构的语法，用法几近于 C 语言，无需赘述。</p>
<h2>正则表达式</h2>
<p>若使用正则表达式作为模式，则记录与模式的匹配所表示的逻辑是前者包含着可与后者匹配的文本。</p>
<p>例如，若只输出上一节的 foo.txt 文件中含有「马」的记录，可以用 <code>马</code> 作为模式，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/马/'</span> foo.txt
<span class="go">以马喻马之非马</span>
<span class="go">不若以非马喻马之非马也</span>
<span class="go">万物一马也</span>
</pre>


<p>awk 解释器输出的是 foo.txt 文件中含有可与正则表达式 <code>马</code> 匹配的文本的记录。在 awk 语言中，正则表达式的两侧以 <code>/</code> 为界。</p>
<p>下面给出几个略微复杂一点的正则表达式作为模式的例子。只输出 foo.txt 中以 <code>不若</code> 作为开头的记录，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/^不若/'</span> foo.txt
<span class="go">不若以非指喻指之非指也</span>
<span class="go">不若以非马喻马之非马也</span>
</pre>


<p>只输出 foo.txt 中以 <code>也</code> 作为结尾的记录，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/也$/'</span> foo.txt
<span class="go">不若以非指喻指之非指也</span>
<span class="go">不若以非马喻马之非马也</span>
<span class="go">天地一指也</span>
<span class="go">万物一马也</span>
</pre>


<p>只输出 foo.txt 中含有至少两个 <code>马</code> 字的记录，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/马.*马/'</span> foo.txt
<span class="go">以马喻马之非马</span>
<span class="go">不若以非马喻马之非马也</span>
</pre>


<p>awk 的正则表达式取自 egrep。egrep 为 grep 的扩展版本，支持的正则表达式较 grep 更为丰富。因此若熟悉 awk 的正则表达式，则自会熟悉 grep/egrep 的用法，反之亦然。</p>
<p>对于正则表达式与记录的匹配，awk 提供了逻辑运算符 <code>~</code> 与 <code>!~</code>，前者类似 <code>==</code>，表示匹配，而后者类似 <code>!=</code>，表示不匹配。因此</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/马.*马/'</span> foo.txt
</pre>


<p>可写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'$0 ~ /马.*马/'</span> foo.txt
</pre>


<p>还可以写为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'{ if ($0 ~ /马.*马/) print $0 }'</span> foo.txt
</pre>


<h2>变量</h2>
<p>awk 的变量可无需初始化便可使用。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'NR == 1 { print a; print a + 1 }'</span> foo.txt

<span class="go">1</span>
</pre>


<p>即输出了空行和内容为 <code>1</code> 的行。之所以会输出空行，是因为变量 <code>a</code> 未经初始化便在语句「<code>print a</code>」中使用，awk 解释器默认其值为空文本，即 <code>""</code>，从而导致 「<code>print a</code>」输出空行。但是在「<code>print a + 1</code>」中，awk 解释器发现 <code>a</code> 出现于算术表达式中，因此便将其值由空字串转化为数字 0，从而导致「<code>print a + 1</code>」输出内容为 <code>1</code> 的行。</p>
<p>事实上，awk 的变量只有两种类型，文本和数字。awk 解释器会根据变量是否出现于算术表达式之中而对其值为文本还是数字进行推断。</p>
<p>在 awk 程序中，所有的变量皆为全局变量，除非它以函数的参数形式出现。</p>
<h2>函数</h2>
<p>awk 的函数，其一般形式为</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="err">函数名</span><span class="p">(</span><span class="err">参数</span> <span class="mi">1</span><span class="p">,</span> <span class="err">参数</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...,</span> <span class="err">参数</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">函数体</span>
<span class="p">}</span>
</pre>


<p>函数的调用与 C 同，但函数名与参数列表的左括号之间不能存在空格。</p>
<p>在函数中，除了作为参数的变量，其他所有变量皆能为函数外部可见。例如，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> cat &lt;&lt; <span class="s1">'EOF'</span> &gt; func-test.awk
<span class="go">NR == 1 {</span>
<span class="go">        t = mul(2, 3)</span>
<span class="go">        print "t = " t "; z = " z "; x = " x</span>
<span class="go">}</span>

<span class="go">function mul(x, y) {</span>
<span class="go">        z = x * y</span>
<span class="go">        return z</span>
<span class="go">}</span>
<span class="go">EOF</span>
<span class="gp">$</span> awk -f func-test.awk foo.txt
<span class="go">t = 6; z = 6; x = </span>
</pre>


<p>在与模式 <code>NR == 1</code> 相应的动作里，虽未对变量 <code>z</code> 进行赋值，但程序的输出结果却表明其值为 <code>6</code>，这是因为函数 <code>mul</code> 中的变量 <code>z</code> 在函数的外部可见。不过，在动作里调用 <code>mul</code> 时，将 <code>2</code> 赋予函数的参数 <code>x</code>，但动作输出的 <code>x</code>，其值为空文本。因此，若在 awk 程序中对变量的作用域进行限定，唯一的办法是让变量以函数参数的形式出现。</p>
<p>awk 的变量颇类似 Bash，但 Bash 在函数内部可通过关键字 <code>local</code> 将变量的作用域限定在函数之内。不过，awk 的作者在函数的写法上给出了一个建议：可将作用域限定于函数内部的变量置于参数列表尾部，并通过一组空格，使之与函数的参数有所区分。例如，</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span>    <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">z</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span>
        <span class="k">return</span> <span class="nx">z</span>
<span class="p">}</span>
</pre>


<p>awk 默认将变量作为全局变量的做法，使得编写一个略微复杂一些的程序的过程像是在编筐或织布，全局变量像是纬线，操作变量的语句则像是经线。</p>
<h2>数组</h2>
<p>awk 提供了数组类型。数组元素可以异构，但并非连续存储于一段内存空间。例如，</p>
<pre class="code literal-block"><span></span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"abc"</span><span class="p">;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"马"</span><span class="p">;</span>  <span class="nx">a</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"三十三"</span>
</pre>


<p>这个数组，虽然含有下标为 <code>33</code> 的元素，但是并非由 34 个元素构成，而是由 4 个元素构成，而且这 4 个元素在数组中的排列也未必是按照下标的顺序。awk 并未对数组元素的排列给出确切的定义，这主要依赖于 awk 解释器的具体实现。</p>
<p>数组元素在排列上的不确定，意味着 awk 的数组仅支持顺序访问，但不支持随机访问。访问数组中的每个值，可采用 <code>for (下标变量 in 数组) { ... }</code> 语法，例如，</p>
<pre class="code literal-block"><span></span><span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="kr">print</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre>


<p>若以</p>
<pre class="code literal-block"><span></span>for (i = 0; i &lt; n; i++) { print a[i] }
</pre>


<p>访问数组元素，前提是要保证数组元素的下标的确从 <code>0</code> 到 <code>n</code>。</p>
<p>实际上，awk 数组的下标并非数字，而是文本。例如，<code>a[3]</code> 和 <code>a["3"]</code> 皆能访问下标为 <code>3</code> 的元素。Bash 的数组亦如此。</p>
<h2>输入与输出</h2>
<p>命令</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'程序'</span> 文本文件
</pre>


<p>或 </p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk -f 脚本 文本文件
</pre>


<p>是 awk 程序运行的一般方式。程序所需的外部数据可经由文本文件以记录的形式传入。</p>
<p>若不向 awk 解释器提供文本文件，那么 awk 解释器便会将标准输入（stdin）作为程序所需的外部数据的来源。这意味着可以通过管道向 awk 程序传递记录。例如，以下程序可去除文本 <code>"    白马非马    "</code> 首尾的空白，</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"    白马非马    "</span> <span class="p">|</span> awk <span class="s1">'{ match($0, / *([^ ]+) */, a); print a[1] }'</span>
</pre>


<p>若利用 awk 的默认以空格作为列分隔符并且去除列内前导空白字符的特性，可将上述 awk 程序简化为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">"    白马非马    "</span> <span class="p">|</span> awk <span class="s1">'{ print $1 }'</span>
</pre>


<p>awk 解释器对于每条记录，默认以空白字符作为分割符，将记录内容斩为多段，每一段称为域；awk 会将域的数量存于内置变量 <code>NF</code>。域的内容依次存于 awk 解释器的内置变量 <code>$1</code>、<code>$2</code>、...、<code>$n</code>，并将各段内容的前导空白字符（空格或制表符）消除。<code>$0</code> 存储未分割的整条记录。</p>
<p>对记录进行分割，这一特性使得 awk 程序在处理类似矩阵形式的文本表现的简短精悍，经常能以简短的一行程序完成其他编程语言动辄需要数十行代码方能完成的任务。例如，假设文件 emp.txt 内容为</p>
<pre class="code literal-block"><span></span>张三  4.00  0
李四  3.75  0
王五  4.00  10
郑六  5.00  20
赵七  5.50  22
孙八  4.25  18
</pre>


<p>记录了一组雇员的姓名、时薪以及工作时长。现在要制作一份薪水报表，即统计哪些人参与了工作，应发多少钱。若采用 awk 完成该任务，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'$3 &gt; 0 { print $1 "\t" $2 * $3 }'</span> emp.txt
</pre>


<p>结果可得</p>
<pre class="code literal-block"><span></span>王五  40
郑六  100
赵七  121
孙八  76.5
</pre>


<p>若不仅给出每个人的薪水情况，还要给出总的支出金额，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'$3 &gt; 0 { x = $2 * $3; s += x; print $1 "\t" x }; END {print "\n总额\t" s}'</span> emp.txt
<span class="go">王五  40</span>
<span class="go">郑六  100</span>
<span class="go">赵七  121</span>
<span class="go">孙八  76.5</span>

<span class="go">总额  337.5</span>
</pre>


<p>awk 解释器的内置变量 <code>RS</code> 和  <code>FS</code> 分别用于设定记录分割符和域分割符，亦即通过设定此二者，能够让 awk 解释器以记录和域的形式理解输入的数据。显然，应当在 awk 解释器读取文件设置 <code>RS</code> 和  <code>FS</code>，因此，它们的设定应当在 <code>BEGIN</code> 模式所对应的动作里进行，例如，</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span> <span class="nb">RS</span> <span class="o">=</span> <span class="nb">FS</span> <span class="o">=</span> <span class="s2">""</span> <span class="p">}</span>
</pre>


<p>此时，<code>RS</code> 和 <code>FS</code>  皆为空文本，但二者含义不同，前者表示一个或多个空行作为记录分割符，而后者则以空文本作为域分割符。</p>
<p>对于 Markdown 格式的中文文档，各个段落以一个或多个空行隔开，而各个汉字之间则以空文本隔开。若将 <code>RS</code> 和 <code>FS</code> 设为空文本，那么便可以很容易写出一个统计文档中汉字频率的 awk 程序。例如，统计一份文档中出现最多的十个汉字，只需</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span> <span class="nb">RS</span> <span class="o">=</span> <span class="nb">FS</span> <span class="o">=</span> <span class="s2">""</span> <span class="p">}</span>
<span class="p">{</span> 
        <span class="c1"># 移除标点符号、数字、英文字母以及空白字符</span>
        <span class="kr">gsub</span><span class="p">(</span><span class="sr">/[.,:;!?(){}'"，。：；！？（）《》“” ‘’a-zA-Z0-9 　]/</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nb">NF</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">count</span><span class="p">[</span><span class="o">$</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span> 
<span class="p">}</span>
<span class="nb">END</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">in</span> <span class="nx">count</span><span class="p">)</span> <span class="kr">print</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">count</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|</span> <span class="s2">"sort -rn -k 2 | head"</span> <span class="p">}</span>
</pre>


<p>我用这个程序统计的《庄子·逍遥游》中出现最多的十个汉字及出现次数为</p>
<pre class="code literal-block"><span></span>之 70
而 55
也 51
不 42
其 35
者 26
为 25
无 24
大 24
有 22
</pre>


<p>上述的 awk 程序，在实现汉字出现次数的排序以及排序结果的部分输出时，借助了 awk 的 <code>print</code> 函数与 sort 和 head 命令的管道衔接。此举似乎有些胜之不武，但是也没什么不妥，反而显现了 awk 在文本输出方面与 Linux（或其他类 Unix 系统）系统命令行环境的亲和性。</p>
<p>awk 解释器通过 <code>RS</code> 与 <code>FS</code> 理解作为输入的文件。对于 awk 程序的输出，则存在这相应的变量  <code>ORS</code> 与 <code>OFS</code>，awk 解释器通过它们理解如何将程序所得结果输出。</p>
<h2>结语</h2>
<p>一些繁琐的文本分析方面的问题，通常能够以简短的 awk 程序来解决。有些人由此看到了 awk 之美，有些人看到的则是 awk 之丑。因此，awk 的一行程序，吸引了许多人，也吓走了许多人。</p>
<p>在我看来，awk 不美，不丑，也不老。像大多数依然健在的古老的工具那样，只做一些恰如其分的事，这反而使之难以被取代。</p>
<p>egrep 和 sed 也只做恰如其分之事，前者专事文件检索，后者专事文本编辑。此二者所具有的功能，awk 皆能实现，但 awk 的出现并未取代它们。因为有些任务，用 grep 和 sed 可以更快捷地完成，而用 awk 就有些繁琐。例如，若获取 foo.txt 中至少含有两个 <code>马</code> 字的行及其序号，可完成这一任务的 awk 命令为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'/马.*马/ { print NR ":" $0 }'</span> foo.txt
</pre>


<p>若是用 egrep，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> egrep -n <span class="s1">'马.*马'</span> foo.txt
</pre>


<p>若删除 foo.txt 文件中以 <code>天地</code> 和 <code>万物</code> 开始的行，可完成这一任务的 awk 命令为</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> awk <span class="s1">'$0 !~ /^天地/ || '</span><span class="nv">$0</span> !~ /^万物/<span class="err">'</span> foo.txt &gt; new-foo.txt
<span class="gp">$</span> mv new-foo.txt foo.txt
</pre>


<p>若是用 sed，只需</p>
<pre class="code literal-block"><span></span><span class="gp">$</span> sed -i <span class="s1">'/^天地/d; /^万物/d'</span> foo.txt
</pre>


<p>功能更强大的事物的出现，并不意味着功能孱弱的事物失去价值，反而可能更为彰显后者的价值。所以，不要随便地就对别人说，「我已习得 python，还有必要再学 awk 吗？」倘若 awk 不能而且无意于取代 egrep 和 sed，那么 python 当如何取代 awk 呢？</p>
<p>本文所展现的 awk 功能约有十之六七，旨在揭示 awk 的主要功用。掌握这些功能，足以胜任常规的文本处理任务。本文中出现的文字注释形式，便是借助 awk 生成，程序为</p>
<pre class="code literal-block"><span></span><span class="nb">BEGIN</span> <span class="p">{</span>
    <span class="nx">note_pat</span> <span class="o">=</span> <span class="s2">"\\\\note{([^}]+)}"</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="p">{</span>
    <span class="c1"># 注解 -&gt; 上标</span>
    <span class="nx">current_note</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="kr">match</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">note_pat</span><span class="p">,</span> <span class="nx">s</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">notes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="kr">sub</span><span class="p">(</span><span class="nx">note_pat</span><span class="p">,</span> <span class="s2">"**&lt;sup&gt;注 "</span> <span class="nx">i</span><span class="o">++</span> <span class="s2">"&lt;/sup&gt;**"</span><span class="p">,</span> <span class="o">$</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1"># 输出处理后的段落及注解列表</span>
    <span class="kr">print</span> <span class="o">$</span><span class="mi">0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">current_note</span><span class="p">)</span> <span class="p">{</span>  <span class="c1"># 段后增加注解</span>
        <span class="kr">print</span> <span class="s2">""</span>
        <span class="nx">it</span> <span class="o">=</span> <span class="nx">current_note</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">it</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">print</span> <span class="s2">"&gt; 注 "</span> <span class="nx">it</span> <span class="s2">"："</span> <span class="nx">notes</span><span class="p">[</span><span class="nx">it</span><span class="p">]</span>
            <span class="nx">it</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>有关 awk 的更为详尽的知识可从 awk 的三位开发者撰写的《The AWK Programming Language》一书中获得。这本书虽然写于 1988 年，但其内容依然适于现在的 awk 。此外，这本书在介绍 AWK 的编程示例中，言简意赅地介绍了文本处理、数据库、编译原理、排序以及图的遍历等计算机科学基础知识。</p>
<p>也许每一本讲授编程语言的书，都应该借鉴《The AWK Programming Language》的写法。</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="../posts/nikola-tips.html" class="u-url">Nikola 琐事</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Garfileo
            </span></p>
            <p class="dateline">
            <a href="../posts/nikola-tips.html" rel="bookmark">
            <time class="published dt-published" datetime="2018-04-26T10:03:25+08:00" itemprop="datePublished" title="2018-04-26 10:03">2018-04-26 10:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>Nikola 是我用了 3 年的静态网页生成工具，这个 Github 主页上的所有页面皆由它生成。它的安装与基本用法可参考《<a href="https://www.getnikola.com/getting-started.html">Nikola 入门文档</a>》，对于 Linux 环境，建议在 virtualenv + python 3 环境中安装它。它的更详细的用法，见《<a href="https://www.getnikola.com/handbook.html">Nikola 手册</a>》。本文仅记录我在使用 Nikola 过程中遇到的一些小问题以及不甚高明的对策，仅作备忘之用。</p>
<h2>自定义首页</h2>
<p>Nikola 会自动生成首页，将近期的文章内容收集到一个页面，该页面对应的文件为 index.html。这份文件默认会被放到站点的根目录里，所以，它就成了站点的首页。我觉得 Nikola 这个功能很鸡肋，因为我想自己定义首页，而不是这种自动生成的东西。该怎么办呢？</p>
<p>首先，在 conf.py 文件里，将 <code>INDEX_PATH</code> 设为</p>
<pre class="code literal-block"><span></span>INDEX_PATH = "blog"
</pre>


<p>这样，Nikola 就会将这个自动生成的 index.html 文件放到 <code>站点根目录/blog</code> 目录里，从而令它失去了担当站点首页的资格。理论上，也可以随便取个目录名来用，例如
·</p>
<pre class="code literal-block"><span></span>INDEX_PATH = "obsolete"
</pre>


<p>用这种乾坤大挪移的办法，算是将这个鸡肋的站点首页「消灭」了。接下来，就是建立一个自定义的首页，以后手工来维护它。方法很简单，只需要在 <code>PAGES</code> 目录，任意建立一份源文件，将其 <code>slug</code> 设为 <code>index.html</code> 即可。</p>
<p><code>PAGES</code> 目录，就是在 conf.py 文件中设定的目录。例如，我的设定是：</p>
<pre class="code literal-block"><span></span>PAGES = (
    ("stories/*.md", "", "story.tmpl"),
)
</pre>


<p>这就意味着，我可以在 <code>stories</code> 目录建立 <code>slug</code> 设为 <code>index.html</code> 的源文件（至于它对应的文件名是什么，并不重要）。假设这份源文件是 Markdown 格式，那么所谓 <code>slug</code> 就是文件头中的 <code>slug</code> 条目，例如：</p>
<pre class="code literal-block"><span></span>&lt;!-- 
.. title: 
.. slug: index
--&gt;
</pre>


<p>剩下的内容可自由定义。</p>
<p>当网站内容重新发布时，这份源文件就会被转化为网站根目录中的 index.html 文件。因为 Nikola 就是这样对待 <code>PAGES</code> 目录中的源文件的，会把它们「平铺」在网站的根目录里。</p>
<h2>图片目录冲突</h2>
<p>在 conf.py 文件中，我设定了专门用于放图片的目录 images：</p>
<pre class="code literal-block"><span></span>FILES_FOLDERS = {'files': 'files',
                 'meta-doc': 'meta-doc',
                 'mycss': 'mycss',
                 'MathJax': 'MathJax',
                 'images': 'images'} # &lt;&lt;&lt;----- here ----------
</pre>


<p>但是 Nikola 有个自动缩放图片的功能，它会将自动缩放的图片也存放在一个名为 images 的目录，这样就与我设定的目录发生了冲突，而且 Nikola 在生成网页文件的时候会罢工。</p>
<p>解决这个问题的最简单的办法是禁用自动缩放图片功能，即注释掉 conf.py 文件中的下面几行：</p>
<pre class="code literal-block"><span></span># IMAGE_FOLDERS = {'images': 'images'}
# IMAGE_THUMBNAIL_SIZE = 400
# IMAGE_THUMBNAIL_FORMAT = '{name}.thumbnail{ext}'
</pre>


<h2>数学公式支持</h2>
<p>在文章的 Markdown 头部，增加</p>
<pre class="code literal-block"><span></span><span class="cp">.. has_math: true</span>
</pre>


<p>若所使用的 Nikola 主题的模板提供了数学公式支持<sup>注 1</sup>，那么 Nikola 默认会通过 MathJax 的 CDN 实现数学公式的渲染。倘若在 conf.py 文件中，开启 KaTeX，即</p>
<pre class="code literal-block"><span></span>USE_KATEX = True
</pre>


<p>那么，Nikola 便会通过 KaTeX 的 CDN 实现数学公式的渲染。</p>
<blockquote>
<p>注 1：lib/python-版本号/site-packages/nikola/data/theme/主题/templates/math_helper.tmpl 文件。</p>
</blockquote>
<p>若想部署本地的 MathJax 或 KaTeX 数学公式渲染支持，只需下载它们的包，放在站点根目录，然后在 conf.py 的 <code>FILES_FOLDERS</code> 中增加相应的目录名，最后修改 Nikola 主题模板中的数学支持语句，将 CDN 换成本地的 MathJax 或 KaTeX 目录。</p>
<h2>发布到 Github</h2>
<p>若通过 ssh key 发布，记得将 .git/config 中的 <code>url</code> 的值设为</p>
<pre class="code literal-block"><span></span>git@github.com:liyanrui/liyanrui.github.io.git
</pre>
</div>
    </div>
    </article>
</div>





        
        <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script><script>
                renderMathInElement(document.body,
                    {
                        delimiters: [
                            {left: "$$", right: "$$", display: true},
                            {left: "\\[", right: "\\]", display: true},
                            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
                            {left: "\\(", right: "\\)", display: false}
                        ]
                    }
                );
            </script></main><footer id="footer"><p>我的邮箱：lyr.m2@live.cn</p>
            
        </footer>
</div>
    
            <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
